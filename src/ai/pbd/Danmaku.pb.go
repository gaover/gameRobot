// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: Danmaku.proto

package pbd

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// 弹幕广场挂机信息
type DanmakuHangup struct {
	Status               *E_DANMAKU_HANGUP `protobuf:"varint,1,opt,name=status,enum=pbd.E_DANMAKU_HANGUP" json:"status,omitempty"`
	Level                *int32            `protobuf:"zigzag32,2,opt,name=level" json:"level,omitempty"`
	VipLevel             *int32            `protobuf:"zigzag32,3,opt,name=vip_level" json:"vip_level,omitempty"`
	BeginTimestamp       *int64            `protobuf:"zigzag64,4,opt,name=begin_timestamp" json:"begin_timestamp,omitempty"`
	LeftTime             *int64            `protobuf:"zigzag64,5,opt,name=left_time" json:"left_time,omitempty"`
	GetExp               *int64            `protobuf:"zigzag64,6,opt,name=get_exp" json:"get_exp,omitempty"`
	BeforeMidnightTime   *int64            `protobuf:"zigzag64,7,opt,name=before_midnight_time" json:"before_midnight_time,omitempty"`
	TodayHangupedTime    *int64            `protobuf:"zigzag64,8,opt,name=today_hanguped_time" json:"today_hanguped_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *DanmakuHangup) Reset()         { *m = DanmakuHangup{} }
func (m *DanmakuHangup) String() string { return proto.CompactTextString(m) }
func (*DanmakuHangup) ProtoMessage()    {}
func (*DanmakuHangup) Descriptor() ([]byte, []int) {
	return fileDescriptor_de03538b722fc581, []int{0}
}
func (m *DanmakuHangup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DanmakuHangup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DanmakuHangup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DanmakuHangup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DanmakuHangup.Merge(m, src)
}
func (m *DanmakuHangup) XXX_Size() int {
	return m.Size()
}
func (m *DanmakuHangup) XXX_DiscardUnknown() {
	xxx_messageInfo_DanmakuHangup.DiscardUnknown(m)
}

var xxx_messageInfo_DanmakuHangup proto.InternalMessageInfo

func (m *DanmakuHangup) GetStatus() E_DANMAKU_HANGUP {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return E_DANMAKU_HANGUP_EDH_INIT
}

func (m *DanmakuHangup) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *DanmakuHangup) GetVipLevel() int32 {
	if m != nil && m.VipLevel != nil {
		return *m.VipLevel
	}
	return 0
}

func (m *DanmakuHangup) GetBeginTimestamp() int64 {
	if m != nil && m.BeginTimestamp != nil {
		return *m.BeginTimestamp
	}
	return 0
}

func (m *DanmakuHangup) GetLeftTime() int64 {
	if m != nil && m.LeftTime != nil {
		return *m.LeftTime
	}
	return 0
}

func (m *DanmakuHangup) GetGetExp() int64 {
	if m != nil && m.GetExp != nil {
		return *m.GetExp
	}
	return 0
}

func (m *DanmakuHangup) GetBeforeMidnightTime() int64 {
	if m != nil && m.BeforeMidnightTime != nil {
		return *m.BeforeMidnightTime
	}
	return 0
}

func (m *DanmakuHangup) GetTodayHangupedTime() int64 {
	if m != nil && m.TodayHangupedTime != nil {
		return *m.TodayHangupedTime
	}
	return 0
}

// 弹幕广场相关信息
type DbDanmakuInfo struct {
	HangupInfo           *DanmakuHangup `protobuf:"bytes,1,opt,name=hangup_info" json:"hangup_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *DbDanmakuInfo) Reset()         { *m = DbDanmakuInfo{} }
func (m *DbDanmakuInfo) String() string { return proto.CompactTextString(m) }
func (*DbDanmakuInfo) ProtoMessage()    {}
func (*DbDanmakuInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_de03538b722fc581, []int{1}
}
func (m *DbDanmakuInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DbDanmakuInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DbDanmakuInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DbDanmakuInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DbDanmakuInfo.Merge(m, src)
}
func (m *DbDanmakuInfo) XXX_Size() int {
	return m.Size()
}
func (m *DbDanmakuInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DbDanmakuInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DbDanmakuInfo proto.InternalMessageInfo

func (m *DbDanmakuInfo) GetHangupInfo() *DanmakuHangup {
	if m != nil {
		return m.HangupInfo
	}
	return nil
}

// 发送弹幕
type C2S_SendDanmaku struct {
	RoleIndex            *int64   `protobuf:"zigzag64,1,opt,name=role_index" json:"role_index,omitempty"`
	Color                *int32   `protobuf:"zigzag32,2,opt,name=color" json:"color,omitempty"`
	Layout               *int32   `protobuf:"zigzag32,3,opt,name=layout" json:"layout,omitempty"`
	NickName             []byte   `protobuf:"bytes,4,opt,name=nick_name" json:"nick_name,omitempty"`
	Msg                  []byte   `protobuf:"bytes,5,opt,name=msg" json:"msg,omitempty"`
	SceneId              *int32   `protobuf:"zigzag32,6,opt,name=scene_id" json:"scene_id,omitempty"`
	VipLevel             *int32   `protobuf:"zigzag32,7,opt,name=vip_level" json:"vip_level,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2S_SendDanmaku) Reset()         { *m = C2S_SendDanmaku{} }
func (m *C2S_SendDanmaku) String() string { return proto.CompactTextString(m) }
func (*C2S_SendDanmaku) ProtoMessage()    {}
func (*C2S_SendDanmaku) Descriptor() ([]byte, []int) {
	return fileDescriptor_de03538b722fc581, []int{2}
}
func (m *C2S_SendDanmaku) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2S_SendDanmaku) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2S_SendDanmaku.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2S_SendDanmaku) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2S_SendDanmaku.Merge(m, src)
}
func (m *C2S_SendDanmaku) XXX_Size() int {
	return m.Size()
}
func (m *C2S_SendDanmaku) XXX_DiscardUnknown() {
	xxx_messageInfo_C2S_SendDanmaku.DiscardUnknown(m)
}

var xxx_messageInfo_C2S_SendDanmaku proto.InternalMessageInfo

func (m *C2S_SendDanmaku) GetRoleIndex() int64 {
	if m != nil && m.RoleIndex != nil {
		return *m.RoleIndex
	}
	return 0
}

func (m *C2S_SendDanmaku) GetColor() int32 {
	if m != nil && m.Color != nil {
		return *m.Color
	}
	return 0
}

func (m *C2S_SendDanmaku) GetLayout() int32 {
	if m != nil && m.Layout != nil {
		return *m.Layout
	}
	return 0
}

func (m *C2S_SendDanmaku) GetNickName() []byte {
	if m != nil {
		return m.NickName
	}
	return nil
}

func (m *C2S_SendDanmaku) GetMsg() []byte {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *C2S_SendDanmaku) GetSceneId() int32 {
	if m != nil && m.SceneId != nil {
		return *m.SceneId
	}
	return 0
}

func (m *C2S_SendDanmaku) GetVipLevel() int32 {
	if m != nil && m.VipLevel != nil {
		return *m.VipLevel
	}
	return 0
}

// 服务器转发弹幕
type S2C_SendDanmaku struct {
	RoleIndex            *int64   `protobuf:"zigzag64,1,opt,name=role_index" json:"role_index,omitempty"`
	Color                *int32   `protobuf:"zigzag32,2,opt,name=color" json:"color,omitempty"`
	Layout               *int32   `protobuf:"zigzag32,3,opt,name=layout" json:"layout,omitempty"`
	VipLevel             *int32   `protobuf:"zigzag32,4,opt,name=vip_level" json:"vip_level,omitempty"`
	NickName             []byte   `protobuf:"bytes,5,opt,name=nick_name" json:"nick_name,omitempty"`
	Msg                  []byte   `protobuf:"bytes,6,opt,name=msg" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2C_SendDanmaku) Reset()         { *m = S2C_SendDanmaku{} }
func (m *S2C_SendDanmaku) String() string { return proto.CompactTextString(m) }
func (*S2C_SendDanmaku) ProtoMessage()    {}
func (*S2C_SendDanmaku) Descriptor() ([]byte, []int) {
	return fileDescriptor_de03538b722fc581, []int{3}
}
func (m *S2C_SendDanmaku) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_SendDanmaku) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_SendDanmaku.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2C_SendDanmaku) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_SendDanmaku.Merge(m, src)
}
func (m *S2C_SendDanmaku) XXX_Size() int {
	return m.Size()
}
func (m *S2C_SendDanmaku) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_SendDanmaku.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_SendDanmaku proto.InternalMessageInfo

func (m *S2C_SendDanmaku) GetRoleIndex() int64 {
	if m != nil && m.RoleIndex != nil {
		return *m.RoleIndex
	}
	return 0
}

func (m *S2C_SendDanmaku) GetColor() int32 {
	if m != nil && m.Color != nil {
		return *m.Color
	}
	return 0
}

func (m *S2C_SendDanmaku) GetLayout() int32 {
	if m != nil && m.Layout != nil {
		return *m.Layout
	}
	return 0
}

func (m *S2C_SendDanmaku) GetVipLevel() int32 {
	if m != nil && m.VipLevel != nil {
		return *m.VipLevel
	}
	return 0
}

func (m *S2C_SendDanmaku) GetNickName() []byte {
	if m != nil {
		return m.NickName
	}
	return nil
}

func (m *S2C_SendDanmaku) GetMsg() []byte {
	if m != nil {
		return m.Msg
	}
	return nil
}

// 挂机开始
type C2S_HangUpBegin struct {
	RoleIndex            *int64   `protobuf:"zigzag64,1,opt,name=role_index" json:"role_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2S_HangUpBegin) Reset()         { *m = C2S_HangUpBegin{} }
func (m *C2S_HangUpBegin) String() string { return proto.CompactTextString(m) }
func (*C2S_HangUpBegin) ProtoMessage()    {}
func (*C2S_HangUpBegin) Descriptor() ([]byte, []int) {
	return fileDescriptor_de03538b722fc581, []int{4}
}
func (m *C2S_HangUpBegin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2S_HangUpBegin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2S_HangUpBegin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2S_HangUpBegin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2S_HangUpBegin.Merge(m, src)
}
func (m *C2S_HangUpBegin) XXX_Size() int {
	return m.Size()
}
func (m *C2S_HangUpBegin) XXX_DiscardUnknown() {
	xxx_messageInfo_C2S_HangUpBegin.DiscardUnknown(m)
}

var xxx_messageInfo_C2S_HangUpBegin proto.InternalMessageInfo

func (m *C2S_HangUpBegin) GetRoleIndex() int64 {
	if m != nil && m.RoleIndex != nil {
		return *m.RoleIndex
	}
	return 0
}

type S2C_HangUpBegin struct {
	RetCode              *E_MSG_RET_CODE `protobuf:"varint,1,opt,name=ret_code,enum=pbd.E_MSG_RET_CODE" json:"ret_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *S2C_HangUpBegin) Reset()         { *m = S2C_HangUpBegin{} }
func (m *S2C_HangUpBegin) String() string { return proto.CompactTextString(m) }
func (*S2C_HangUpBegin) ProtoMessage()    {}
func (*S2C_HangUpBegin) Descriptor() ([]byte, []int) {
	return fileDescriptor_de03538b722fc581, []int{5}
}
func (m *S2C_HangUpBegin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_HangUpBegin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_HangUpBegin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2C_HangUpBegin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_HangUpBegin.Merge(m, src)
}
func (m *S2C_HangUpBegin) XXX_Size() int {
	return m.Size()
}
func (m *S2C_HangUpBegin) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_HangUpBegin.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_HangUpBegin proto.InternalMessageInfo

func (m *S2C_HangUpBegin) GetRetCode() E_MSG_RET_CODE {
	if m != nil && m.RetCode != nil {
		return *m.RetCode
	}
	return E_MSG_RET_CODE_Msg_Ret_Code_Unknow
}

// 挂机结束(领取经验)
type C2S_HangUpEnd struct {
	RoleIndex            *int64   `protobuf:"zigzag64,1,opt,name=role_index" json:"role_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2S_HangUpEnd) Reset()         { *m = C2S_HangUpEnd{} }
func (m *C2S_HangUpEnd) String() string { return proto.CompactTextString(m) }
func (*C2S_HangUpEnd) ProtoMessage()    {}
func (*C2S_HangUpEnd) Descriptor() ([]byte, []int) {
	return fileDescriptor_de03538b722fc581, []int{6}
}
func (m *C2S_HangUpEnd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2S_HangUpEnd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2S_HangUpEnd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2S_HangUpEnd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2S_HangUpEnd.Merge(m, src)
}
func (m *C2S_HangUpEnd) XXX_Size() int {
	return m.Size()
}
func (m *C2S_HangUpEnd) XXX_DiscardUnknown() {
	xxx_messageInfo_C2S_HangUpEnd.DiscardUnknown(m)
}

var xxx_messageInfo_C2S_HangUpEnd proto.InternalMessageInfo

func (m *C2S_HangUpEnd) GetRoleIndex() int64 {
	if m != nil && m.RoleIndex != nil {
		return *m.RoleIndex
	}
	return 0
}

type S2C_HangUpEnd struct {
	RetCode              *E_MSG_RET_CODE `protobuf:"varint,1,opt,name=ret_code,enum=pbd.E_MSG_RET_CODE" json:"ret_code,omitempty"`
	GetExp               *int64          `protobuf:"zigzag64,2,opt,name=get_exp" json:"get_exp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *S2C_HangUpEnd) Reset()         { *m = S2C_HangUpEnd{} }
func (m *S2C_HangUpEnd) String() string { return proto.CompactTextString(m) }
func (*S2C_HangUpEnd) ProtoMessage()    {}
func (*S2C_HangUpEnd) Descriptor() ([]byte, []int) {
	return fileDescriptor_de03538b722fc581, []int{7}
}
func (m *S2C_HangUpEnd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_HangUpEnd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_HangUpEnd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2C_HangUpEnd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_HangUpEnd.Merge(m, src)
}
func (m *S2C_HangUpEnd) XXX_Size() int {
	return m.Size()
}
func (m *S2C_HangUpEnd) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_HangUpEnd.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_HangUpEnd proto.InternalMessageInfo

func (m *S2C_HangUpEnd) GetRetCode() E_MSG_RET_CODE {
	if m != nil && m.RetCode != nil {
		return *m.RetCode
	}
	return E_MSG_RET_CODE_Msg_Ret_Code_Unknow
}

func (m *S2C_HangUpEnd) GetGetExp() int64 {
	if m != nil && m.GetExp != nil {
		return *m.GetExp
	}
	return 0
}

// 挂机信息查询
type C2S_HangUpInfo struct {
	RoleIndex            *int64   `protobuf:"zigzag64,1,opt,name=role_index" json:"role_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2S_HangUpInfo) Reset()         { *m = C2S_HangUpInfo{} }
func (m *C2S_HangUpInfo) String() string { return proto.CompactTextString(m) }
func (*C2S_HangUpInfo) ProtoMessage()    {}
func (*C2S_HangUpInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_de03538b722fc581, []int{8}
}
func (m *C2S_HangUpInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2S_HangUpInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2S_HangUpInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2S_HangUpInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2S_HangUpInfo.Merge(m, src)
}
func (m *C2S_HangUpInfo) XXX_Size() int {
	return m.Size()
}
func (m *C2S_HangUpInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_C2S_HangUpInfo.DiscardUnknown(m)
}

var xxx_messageInfo_C2S_HangUpInfo proto.InternalMessageInfo

func (m *C2S_HangUpInfo) GetRoleIndex() int64 {
	if m != nil && m.RoleIndex != nil {
		return *m.RoleIndex
	}
	return 0
}

type S2C_HangUpInfo struct {
	Status               *E_DANMAKU_HANGUP `protobuf:"varint,1,opt,name=status,enum=pbd.E_DANMAKU_HANGUP" json:"status,omitempty"`
	GetExp               *int64            `protobuf:"zigzag64,2,opt,name=get_exp" json:"get_exp,omitempty"`
	LeftTime             *int64            `protobuf:"zigzag64,3,opt,name=left_time" json:"left_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *S2C_HangUpInfo) Reset()         { *m = S2C_HangUpInfo{} }
func (m *S2C_HangUpInfo) String() string { return proto.CompactTextString(m) }
func (*S2C_HangUpInfo) ProtoMessage()    {}
func (*S2C_HangUpInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_de03538b722fc581, []int{9}
}
func (m *S2C_HangUpInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2C_HangUpInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2C_HangUpInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2C_HangUpInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2C_HangUpInfo.Merge(m, src)
}
func (m *S2C_HangUpInfo) XXX_Size() int {
	return m.Size()
}
func (m *S2C_HangUpInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_S2C_HangUpInfo.DiscardUnknown(m)
}

var xxx_messageInfo_S2C_HangUpInfo proto.InternalMessageInfo

func (m *S2C_HangUpInfo) GetStatus() E_DANMAKU_HANGUP {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return E_DANMAKU_HANGUP_EDH_INIT
}

func (m *S2C_HangUpInfo) GetGetExp() int64 {
	if m != nil && m.GetExp != nil {
		return *m.GetExp
	}
	return 0
}

func (m *S2C_HangUpInfo) GetLeftTime() int64 {
	if m != nil && m.LeftTime != nil {
		return *m.LeftTime
	}
	return 0
}

func init() {
	proto.RegisterType((*DanmakuHangup)(nil), "pbd.danmaku_hangup")
	proto.RegisterType((*DbDanmakuInfo)(nil), "pbd.db_danmaku_info")
	proto.RegisterType((*C2S_SendDanmaku)(nil), "pbd.C2S_SendDanmaku")
	proto.RegisterType((*S2C_SendDanmaku)(nil), "pbd.S2C_SendDanmaku")
	proto.RegisterType((*C2S_HangUpBegin)(nil), "pbd.C2S_HangUpBegin")
	proto.RegisterType((*S2C_HangUpBegin)(nil), "pbd.S2C_HangUpBegin")
	proto.RegisterType((*C2S_HangUpEnd)(nil), "pbd.C2S_HangUpEnd")
	proto.RegisterType((*S2C_HangUpEnd)(nil), "pbd.S2C_HangUpEnd")
	proto.RegisterType((*C2S_HangUpInfo)(nil), "pbd.C2S_HangUpInfo")
	proto.RegisterType((*S2C_HangUpInfo)(nil), "pbd.S2C_HangUpInfo")
}

func init() { proto.RegisterFile("Danmaku.proto", fileDescriptor_de03538b722fc581) }

var fileDescriptor_de03538b722fc581 = []byte{
	// 478 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x93, 0x41, 0x6e, 0xd3, 0x40,
	0x14, 0x86, 0x71, 0xd3, 0xa4, 0xe9, 0x4b, 0x62, 0x37, 0x13, 0x10, 0x16, 0xa0, 0x28, 0x32, 0x44,
	0xca, 0x2a, 0x8b, 0xac, 0x90, 0x58, 0xa5, 0x89, 0x95, 0x22, 0xd4, 0x82, 0x08, 0x59, 0xb1, 0x18,
	0xd9, 0x99, 0x17, 0xd7, 0xaa, 0x3d, 0x63, 0xd9, 0xe3, 0xd2, 0x1e, 0x81, 0x1b, 0x70, 0x24, 0x96,
	0x70, 0x03, 0x14, 0x2e, 0x82, 0x66, 0x6c, 0xe4, 0xb4, 0x64, 0xd1, 0x05, 0xcb, 0xfc, 0xf3, 0xe7,
	0xfd, 0xff, 0x37, 0xf3, 0x0c, 0x9d, 0xb9, 0xc7, 0x63, 0xef, 0x2a, 0x1f, 0x27, 0xa9, 0x90, 0x82,
	0xd4, 0x12, 0x9f, 0x3d, 0xeb, 0xb8, 0x3c, 0x8f, 0xe7, 0xb8, 0x29, 0x34, 0xe7, 0xa7, 0x01, 0x26,
	0x2b, 0x5c, 0xf4, 0xd2, 0xe3, 0x41, 0x9e, 0x90, 0x21, 0x34, 0x32, 0xe9, 0xc9, 0x3c, 0xb3, 0x8d,
	0x81, 0x31, 0x32, 0x27, 0x4f, 0xc6, 0x89, 0xcf, 0xc6, 0x2e, 0x9d, 0x4f, 0x2f, 0xce, 0xa7, 0xef,
	0x56, 0xf4, 0x6c, 0x7a, 0xb1, 0x58, 0x7d, 0x20, 0x1d, 0xa8, 0x47, 0x78, 0x8d, 0x91, 0x7d, 0x30,
	0x30, 0x46, 0x5d, 0xd2, 0x85, 0xe3, 0xeb, 0x30, 0xa1, 0x85, 0x54, 0xd3, 0xd2, 0x53, 0xb0, 0x7c,
	0x0c, 0x42, 0x4e, 0x65, 0x18, 0x63, 0x26, 0xbd, 0x38, 0xb1, 0x0f, 0x07, 0xc6, 0x88, 0x28, 0x6f,
	0x84, 0x1b, 0xa9, 0x75, 0xbb, 0xae, 0x25, 0x0b, 0x8e, 0x02, 0x94, 0x14, 0x6f, 0x12, 0xbb, 0xa1,
	0x85, 0x17, 0xf0, 0xd8, 0xc7, 0x8d, 0x48, 0x91, 0xc6, 0x21, 0xe3, 0x61, 0x70, 0x59, 0xda, 0x8f,
	0xf4, 0xe9, 0x73, 0xe8, 0x49, 0xc1, 0xbc, 0xdb, 0xb2, 0x33, 0xb2, 0xe2, 0xb0, 0xa9, 0x0e, 0x9d,
	0x37, 0x60, 0x31, 0x9f, 0xfe, 0xa5, 0x0a, 0xf9, 0x46, 0x90, 0x11, 0xb4, 0x0a, 0xa7, 0xfe, 0xa9,
	0xc1, 0x5a, 0x93, 0x9e, 0x06, 0xbb, 0x4b, 0xef, 0x7c, 0x35, 0xc0, 0x9a, 0x4d, 0x96, 0x74, 0x89,
	0x9c, 0x95, 0xd7, 0x47, 0x08, 0x40, 0x2a, 0x22, 0xa4, 0x21, 0x67, 0x78, 0xa3, 0xff, 0x4c, 0x14,
	0xfe, 0x5a, 0x44, 0x22, 0x2d, 0xf1, 0x4d, 0x68, 0x44, 0xde, 0xad, 0xc8, 0x65, 0xc9, 0xde, 0x85,
	0x63, 0x1e, 0xae, 0xaf, 0x28, 0xf7, 0x62, 0xd4, 0xd4, 0x6d, 0xd2, 0x82, 0x5a, 0x9c, 0x05, 0x9a,
	0xb7, 0x4d, 0x4e, 0xa0, 0x99, 0xad, 0x91, 0x23, 0x0d, 0x99, 0x06, 0xbe, 0x77, 0x81, 0x8a, 0xb2,
	0xeb, 0x7c, 0x01, 0x6b, 0x39, 0x99, 0xfd, 0x87, 0x2a, 0xd5, 0xe0, 0xc3, 0x7f, 0xdb, 0xd5, 0x77,
	0xdb, 0xa9, 0x2e, 0x6d, 0x67, 0x58, 0xdc, 0xc1, 0x99, 0xc7, 0x83, 0x55, 0x72, 0xaa, 0xde, 0x70,
	0x5f, 0xb0, 0xf3, 0xba, 0xe8, 0xb7, 0x6b, 0x1b, 0x42, 0x33, 0x45, 0x49, 0xd7, 0x82, 0x61, 0xb9,
	0x3e, 0xbd, 0x72, 0x7d, 0xce, 0x97, 0x0b, 0xfa, 0xd1, 0xfd, 0x44, 0x67, 0xef, 0xe7, 0xae, 0xf3,
	0x12, 0x3a, 0x55, 0x80, 0xcb, 0xd9, 0xde, 0xf1, 0x0b, 0xe8, 0x54, 0xe3, 0x95, 0xe9, 0x61, 0xc3,
	0x77, 0x77, 0xe9, 0x40, 0x0f, 0x7a, 0x05, 0x66, 0x95, 0xf6, 0x56, 0xed, 0xc3, 0xbe, 0xb8, 0xcf,
	0x60, 0x56, 0x71, 0xda, 0xf5, 0xc0, 0x2f, 0xe1, 0x7e, 0xde, 0xdd, 0xfd, 0x56, 0x8f, 0x40, 0x4e,
	0x4f, 0xbe, 0x6f, 0xfb, 0xc6, 0x8f, 0x6d, 0xdf, 0xf8, 0xb5, 0xed, 0x1b, 0xdf, 0x7e, 0xf7, 0x1f,
	0xfd, 0x09, 0x00, 0x00, 0xff, 0xff, 0x3d, 0x89, 0x2c, 0x42, 0x9d, 0x03, 0x00, 0x00,
}

func (m *DanmakuHangup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DanmakuHangup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DanmakuHangup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TodayHangupedTime != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint64(*m.TodayHangupedTime)<<1)^uint64((*m.TodayHangupedTime>>63))))
		i--
		dAtA[i] = 0x40
	}
	if m.BeforeMidnightTime != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint64(*m.BeforeMidnightTime)<<1)^uint64((*m.BeforeMidnightTime>>63))))
		i--
		dAtA[i] = 0x38
	}
	if m.GetExp != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint64(*m.GetExp)<<1)^uint64((*m.GetExp>>63))))
		i--
		dAtA[i] = 0x30
	}
	if m.LeftTime != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint64(*m.LeftTime)<<1)^uint64((*m.LeftTime>>63))))
		i--
		dAtA[i] = 0x28
	}
	if m.BeginTimestamp != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint64(*m.BeginTimestamp)<<1)^uint64((*m.BeginTimestamp>>63))))
		i--
		dAtA[i] = 0x20
	}
	if m.VipLevel != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint32(*m.VipLevel)<<1)^uint32((*m.VipLevel>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.Level != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Status != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64(*m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DbDanmakuInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DbDanmakuInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DbDanmakuInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HangupInfo != nil {
		{
			size, err := m.HangupInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDanmaku(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C2S_SendDanmaku) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2S_SendDanmaku) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2S_SendDanmaku) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VipLevel != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint32(*m.VipLevel)<<1)^uint32((*m.VipLevel>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.SceneId != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint32(*m.SceneId)<<1)^uint32((*m.SceneId>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Msg != nil {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDanmaku(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x2a
	}
	if m.NickName != nil {
		i -= len(m.NickName)
		copy(dAtA[i:], m.NickName)
		i = encodeVarintDanmaku(dAtA, i, uint64(len(m.NickName)))
		i--
		dAtA[i] = 0x22
	}
	if m.Layout != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint32(*m.Layout)<<1)^uint32((*m.Layout>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.Color != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint32(*m.Color)<<1)^uint32((*m.Color>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.RoleIndex != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint64(*m.RoleIndex)<<1)^uint64((*m.RoleIndex>>63))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2C_SendDanmaku) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_SendDanmaku) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2C_SendDanmaku) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Msg != nil {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDanmaku(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x32
	}
	if m.NickName != nil {
		i -= len(m.NickName)
		copy(dAtA[i:], m.NickName)
		i = encodeVarintDanmaku(dAtA, i, uint64(len(m.NickName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.VipLevel != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint32(*m.VipLevel)<<1)^uint32((*m.VipLevel>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Layout != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint32(*m.Layout)<<1)^uint32((*m.Layout>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.Color != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint32(*m.Color)<<1)^uint32((*m.Color>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.RoleIndex != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint64(*m.RoleIndex)<<1)^uint64((*m.RoleIndex>>63))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2S_HangUpBegin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2S_HangUpBegin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2S_HangUpBegin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RoleIndex != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint64(*m.RoleIndex)<<1)^uint64((*m.RoleIndex>>63))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2C_HangUpBegin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_HangUpBegin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2C_HangUpBegin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RetCode != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64(*m.RetCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2S_HangUpEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2S_HangUpEnd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2S_HangUpEnd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RoleIndex != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint64(*m.RoleIndex)<<1)^uint64((*m.RoleIndex>>63))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2C_HangUpEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_HangUpEnd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2C_HangUpEnd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GetExp != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint64(*m.GetExp)<<1)^uint64((*m.GetExp>>63))))
		i--
		dAtA[i] = 0x10
	}
	if m.RetCode != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64(*m.RetCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2S_HangUpInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2S_HangUpInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2S_HangUpInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RoleIndex != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint64(*m.RoleIndex)<<1)^uint64((*m.RoleIndex>>63))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2C_HangUpInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2C_HangUpInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2C_HangUpInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LeftTime != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint64(*m.LeftTime)<<1)^uint64((*m.LeftTime>>63))))
		i--
		dAtA[i] = 0x18
	}
	if m.GetExp != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64((uint64(*m.GetExp)<<1)^uint64((*m.GetExp>>63))))
		i--
		dAtA[i] = 0x10
	}
	if m.Status != nil {
		i = encodeVarintDanmaku(dAtA, i, uint64(*m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDanmaku(dAtA []byte, offset int, v uint64) int {
	offset -= sovDanmaku(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DanmakuHangup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		n += 1 + sovDanmaku(uint64(*m.Status))
	}
	if m.Level != nil {
		n += 1 + sozDanmaku(uint64(*m.Level))
	}
	if m.VipLevel != nil {
		n += 1 + sozDanmaku(uint64(*m.VipLevel))
	}
	if m.BeginTimestamp != nil {
		n += 1 + sozDanmaku(uint64(*m.BeginTimestamp))
	}
	if m.LeftTime != nil {
		n += 1 + sozDanmaku(uint64(*m.LeftTime))
	}
	if m.GetExp != nil {
		n += 1 + sozDanmaku(uint64(*m.GetExp))
	}
	if m.BeforeMidnightTime != nil {
		n += 1 + sozDanmaku(uint64(*m.BeforeMidnightTime))
	}
	if m.TodayHangupedTime != nil {
		n += 1 + sozDanmaku(uint64(*m.TodayHangupedTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DbDanmakuInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HangupInfo != nil {
		l = m.HangupInfo.Size()
		n += 1 + l + sovDanmaku(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2S_SendDanmaku) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoleIndex != nil {
		n += 1 + sozDanmaku(uint64(*m.RoleIndex))
	}
	if m.Color != nil {
		n += 1 + sozDanmaku(uint64(*m.Color))
	}
	if m.Layout != nil {
		n += 1 + sozDanmaku(uint64(*m.Layout))
	}
	if m.NickName != nil {
		l = len(m.NickName)
		n += 1 + l + sovDanmaku(uint64(l))
	}
	if m.Msg != nil {
		l = len(m.Msg)
		n += 1 + l + sovDanmaku(uint64(l))
	}
	if m.SceneId != nil {
		n += 1 + sozDanmaku(uint64(*m.SceneId))
	}
	if m.VipLevel != nil {
		n += 1 + sozDanmaku(uint64(*m.VipLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2C_SendDanmaku) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoleIndex != nil {
		n += 1 + sozDanmaku(uint64(*m.RoleIndex))
	}
	if m.Color != nil {
		n += 1 + sozDanmaku(uint64(*m.Color))
	}
	if m.Layout != nil {
		n += 1 + sozDanmaku(uint64(*m.Layout))
	}
	if m.VipLevel != nil {
		n += 1 + sozDanmaku(uint64(*m.VipLevel))
	}
	if m.NickName != nil {
		l = len(m.NickName)
		n += 1 + l + sovDanmaku(uint64(l))
	}
	if m.Msg != nil {
		l = len(m.Msg)
		n += 1 + l + sovDanmaku(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2S_HangUpBegin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoleIndex != nil {
		n += 1 + sozDanmaku(uint64(*m.RoleIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2C_HangUpBegin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != nil {
		n += 1 + sovDanmaku(uint64(*m.RetCode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2S_HangUpEnd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoleIndex != nil {
		n += 1 + sozDanmaku(uint64(*m.RoleIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2C_HangUpEnd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != nil {
		n += 1 + sovDanmaku(uint64(*m.RetCode))
	}
	if m.GetExp != nil {
		n += 1 + sozDanmaku(uint64(*m.GetExp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2S_HangUpInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoleIndex != nil {
		n += 1 + sozDanmaku(uint64(*m.RoleIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2C_HangUpInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		n += 1 + sovDanmaku(uint64(*m.Status))
	}
	if m.GetExp != nil {
		n += 1 + sozDanmaku(uint64(*m.GetExp))
	}
	if m.LeftTime != nil {
		n += 1 + sozDanmaku(uint64(*m.LeftTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDanmaku(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDanmaku(x uint64) (n int) {
	return sovDanmaku(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DanmakuHangup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmaku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: danmaku_hangup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: danmaku_hangup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v E_DANMAKU_HANGUP
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= E_DANMAKU_HANGUP(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.VipLevel = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginTimestamp", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.BeginTimestamp = &v2
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.LeftTime = &v2
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetExp", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.GetExp = &v2
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeforeMidnightTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.BeforeMidnightTime = &v2
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TodayHangupedTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.TodayHangupedTime = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipDanmaku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDanmaku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DbDanmakuInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmaku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: db_danmaku_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: db_danmaku_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HangupInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDanmaku
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDanmaku
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HangupInfo == nil {
				m.HangupInfo = &DanmakuHangup{}
			}
			if err := m.HangupInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDanmaku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDanmaku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2S_SendDanmaku) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmaku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2S_SendDanmaku: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2S_SendDanmaku: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.RoleIndex = &v2
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Color = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layout", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Layout = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDanmaku
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDanmaku
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = append(m.NickName[:0], dAtA[iNdEx:postIndex]...)
			if m.NickName == nil {
				m.NickName = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDanmaku
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDanmaku
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg[:0], dAtA[iNdEx:postIndex]...)
			if m.Msg == nil {
				m.Msg = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SceneId = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.VipLevel = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDanmaku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDanmaku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_SendDanmaku) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmaku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_SendDanmaku: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_SendDanmaku: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.RoleIndex = &v2
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Color = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layout", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Layout = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.VipLevel = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDanmaku
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDanmaku
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = append(m.NickName[:0], dAtA[iNdEx:postIndex]...)
			if m.NickName == nil {
				m.NickName = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDanmaku
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDanmaku
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg[:0], dAtA[iNdEx:postIndex]...)
			if m.Msg == nil {
				m.Msg = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDanmaku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDanmaku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2S_HangUpBegin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmaku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2S_HangUpBegin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2S_HangUpBegin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.RoleIndex = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipDanmaku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDanmaku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_HangUpBegin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmaku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_HangUpBegin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_HangUpBegin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			var v E_MSG_RET_CODE
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= E_MSG_RET_CODE(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RetCode = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDanmaku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDanmaku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2S_HangUpEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmaku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2S_HangUpEnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2S_HangUpEnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.RoleIndex = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipDanmaku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDanmaku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_HangUpEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmaku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_HangUpEnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_HangUpEnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			var v E_MSG_RET_CODE
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= E_MSG_RET_CODE(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RetCode = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetExp", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.GetExp = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipDanmaku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDanmaku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2S_HangUpInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmaku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2S_HangUpInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2S_HangUpInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.RoleIndex = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipDanmaku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDanmaku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2C_HangUpInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmaku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2C_HangUpInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2C_HangUpInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v E_DANMAKU_HANGUP
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= E_DANMAKU_HANGUP(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetExp", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.GetExp = &v2
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.LeftTime = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipDanmaku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDanmaku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDanmaku(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDanmaku
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDanmaku
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDanmaku
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDanmaku
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDanmaku
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDanmaku        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDanmaku          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDanmaku = fmt.Errorf("proto: unexpected end of group")
)
