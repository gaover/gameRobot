// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ServerDef.proto

package pbd

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Excel:sign签到.xls sheet:签到奖励表
type LuaSignReward struct {
	ID                   *int32           `protobuf:"zigzag32,1,opt,name=ID" json:"ID,omitempty"`
	Reward               []*SignDayReward `protobuf:"bytes,2,rep,name=reward" json:"reward,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *LuaSignReward) Reset()         { *m = LuaSignReward{} }
func (m *LuaSignReward) String() string { return proto.CompactTextString(m) }
func (*LuaSignReward) ProtoMessage()    {}
func (*LuaSignReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{0}
}
func (m *LuaSignReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaSignReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaSignReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaSignReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaSignReward.Merge(m, src)
}
func (m *LuaSignReward) XXX_Size() int {
	return m.Size()
}
func (m *LuaSignReward) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaSignReward.DiscardUnknown(m)
}

var xxx_messageInfo_LuaSignReward proto.InternalMessageInfo

func (m *LuaSignReward) GetID() int32 {
	if m != nil && m.ID != nil {
		return *m.ID
	}
	return 0
}

func (m *LuaSignReward) GetReward() []*SignDayReward {
	if m != nil {
		return m.Reward
	}
	return nil
}

// Excel:道具商店表.xls sheet:汽车商店
type LuaParkShop struct {
	ItemId               *int32   `protobuf:"zigzag32,1,opt,name=itemId" json:"itemId,omitempty"`
	CarId                *int32   `protobuf:"zigzag32,2,opt,name=carId" json:"carId,omitempty"`
	Num                  *int32   `protobuf:"zigzag32,3,opt,name=num" json:"num,omitempty"`
	CostType             *int32   `protobuf:"zigzag32,4,opt,name=costType" json:"costType,omitempty"`
	Price                *int32   `protobuf:"zigzag32,5,opt,name=price" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaParkShop) Reset()         { *m = LuaParkShop{} }
func (m *LuaParkShop) String() string { return proto.CompactTextString(m) }
func (*LuaParkShop) ProtoMessage()    {}
func (*LuaParkShop) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{1}
}
func (m *LuaParkShop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaParkShop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaParkShop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaParkShop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaParkShop.Merge(m, src)
}
func (m *LuaParkShop) XXX_Size() int {
	return m.Size()
}
func (m *LuaParkShop) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaParkShop.DiscardUnknown(m)
}

var xxx_messageInfo_LuaParkShop proto.InternalMessageInfo

func (m *LuaParkShop) GetItemId() int32 {
	if m != nil && m.ItemId != nil {
		return *m.ItemId
	}
	return 0
}

func (m *LuaParkShop) GetCarId() int32 {
	if m != nil && m.CarId != nil {
		return *m.CarId
	}
	return 0
}

func (m *LuaParkShop) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

func (m *LuaParkShop) GetCostType() int32 {
	if m != nil && m.CostType != nil {
		return *m.CostType
	}
	return 0
}

func (m *LuaParkShop) GetPrice() int32 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

// Excel:日常任务表.xls sheet:活跃度奖励
type LuaDailyActivity struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	ActivityValue        *int32   `protobuf:"zigzag32,2,opt,name=activityValue" json:"activityValue,omitempty"`
	Reward               []int32  `protobuf:"zigzag32,3,rep,name=reward" json:"reward,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaDailyActivity) Reset()         { *m = LuaDailyActivity{} }
func (m *LuaDailyActivity) String() string { return proto.CompactTextString(m) }
func (*LuaDailyActivity) ProtoMessage()    {}
func (*LuaDailyActivity) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{2}
}
func (m *LuaDailyActivity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaDailyActivity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaDailyActivity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaDailyActivity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaDailyActivity.Merge(m, src)
}
func (m *LuaDailyActivity) XXX_Size() int {
	return m.Size()
}
func (m *LuaDailyActivity) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaDailyActivity.DiscardUnknown(m)
}

var xxx_messageInfo_LuaDailyActivity proto.InternalMessageInfo

func (m *LuaDailyActivity) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaDailyActivity) GetActivityValue() int32 {
	if m != nil && m.ActivityValue != nil {
		return *m.ActivityValue
	}
	return 0
}

func (m *LuaDailyActivity) GetReward() []int32 {
	if m != nil {
		return m.Reward
	}
	return nil
}

// Excel:成就配置表.xls sheet:Sheet1
type LuaAchieve struct {
	Id                   *int32        `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	TypeName             []byte        `protobuf:"bytes,2,opt,name=typeName" json:"typeName,omitempty"`
	Name                 []byte        `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	Type                 *int32        `protobuf:"zigzag32,4,opt,name=type" json:"type,omitempty"`
	IsHide               *int32        `protobuf:"zigzag32,5,opt,name=isHide" json:"isHide,omitempty"`
	Des                  []byte        `protobuf:"bytes,6,opt,name=des" json:"des,omitempty"`
	ConditionValue       *int64        `protobuf:"zigzag64,7,opt,name=conditionValue" json:"conditionValue,omitempty"`
	AchievePoint         *int32        `protobuf:"zigzag32,8,opt,name=achievePoint" json:"achievePoint,omitempty"`
	RewardList           []*ItemConfig `protobuf:"bytes,9,rep,name=rewardList" json:"rewardList,omitempty"`
	Quality              *int32        `protobuf:"zigzag32,10,opt,name=quality" json:"quality,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaAchieve) Reset()         { *m = LuaAchieve{} }
func (m *LuaAchieve) String() string { return proto.CompactTextString(m) }
func (*LuaAchieve) ProtoMessage()    {}
func (*LuaAchieve) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{3}
}
func (m *LuaAchieve) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaAchieve) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaAchieve.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaAchieve) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaAchieve.Merge(m, src)
}
func (m *LuaAchieve) XXX_Size() int {
	return m.Size()
}
func (m *LuaAchieve) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaAchieve.DiscardUnknown(m)
}

var xxx_messageInfo_LuaAchieve proto.InternalMessageInfo

func (m *LuaAchieve) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaAchieve) GetTypeName() []byte {
	if m != nil {
		return m.TypeName
	}
	return nil
}

func (m *LuaAchieve) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *LuaAchieve) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaAchieve) GetIsHide() int32 {
	if m != nil && m.IsHide != nil {
		return *m.IsHide
	}
	return 0
}

func (m *LuaAchieve) GetDes() []byte {
	if m != nil {
		return m.Des
	}
	return nil
}

func (m *LuaAchieve) GetConditionValue() int64 {
	if m != nil && m.ConditionValue != nil {
		return *m.ConditionValue
	}
	return 0
}

func (m *LuaAchieve) GetAchievePoint() int32 {
	if m != nil && m.AchievePoint != nil {
		return *m.AchievePoint
	}
	return 0
}

func (m *LuaAchieve) GetRewardList() []*ItemConfig {
	if m != nil {
		return m.RewardList
	}
	return nil
}

func (m *LuaAchieve) GetQuality() int32 {
	if m != nil && m.Quality != nil {
		return *m.Quality
	}
	return 0
}

// Excel:avatar表情.xls sheet:face_shop
type LuaFaceShop struct {
	Index                *int32   `protobuf:"zigzag32,1,opt,name=index" json:"index,omitempty"`
	Id                   *int32   `protobuf:"zigzag32,2,opt,name=id" json:"id,omitempty"`
	Duration             []int32  `protobuf:"zigzag32,3,rep,name=duration" json:"duration,omitempty"`
	CostType             *int32   `protobuf:"zigzag32,4,opt,name=costType" json:"costType,omitempty"`
	Price                []int32  `protobuf:"zigzag32,5,rep,name=price" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaFaceShop) Reset()         { *m = LuaFaceShop{} }
func (m *LuaFaceShop) String() string { return proto.CompactTextString(m) }
func (*LuaFaceShop) ProtoMessage()    {}
func (*LuaFaceShop) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{4}
}
func (m *LuaFaceShop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaFaceShop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaFaceShop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaFaceShop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaFaceShop.Merge(m, src)
}
func (m *LuaFaceShop) XXX_Size() int {
	return m.Size()
}
func (m *LuaFaceShop) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaFaceShop.DiscardUnknown(m)
}

var xxx_messageInfo_LuaFaceShop proto.InternalMessageInfo

func (m *LuaFaceShop) GetIndex() int32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *LuaFaceShop) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaFaceShop) GetDuration() []int32 {
	if m != nil {
		return m.Duration
	}
	return nil
}

func (m *LuaFaceShop) GetCostType() int32 {
	if m != nil && m.CostType != nil {
		return *m.CostType
	}
	return 0
}

func (m *LuaFaceShop) GetPrice() []int32 {
	if m != nil {
		return m.Price
	}
	return nil
}

// Excel:z自带BGM.xls sheet:BGM
type LuaBgm struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	BgmNameID            []byte   `protobuf:"bytes,2,opt,name=bgmNameID" json:"bgmNameID,omitempty"`
	Sound                []byte   `protobuf:"bytes,3,opt,name=sound" json:"sound,omitempty"`
	NeedVipLevel         *int32   `protobuf:"zigzag32,4,opt,name=needVipLevel" json:"needVipLevel,omitempty"`
	Time                 *float32 `protobuf:"fixed32,5,opt,name=time" json:"time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaBgm) Reset()         { *m = LuaBgm{} }
func (m *LuaBgm) String() string { return proto.CompactTextString(m) }
func (*LuaBgm) ProtoMessage()    {}
func (*LuaBgm) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{5}
}
func (m *LuaBgm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaBgm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaBgm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaBgm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaBgm.Merge(m, src)
}
func (m *LuaBgm) XXX_Size() int {
	return m.Size()
}
func (m *LuaBgm) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaBgm.DiscardUnknown(m)
}

var xxx_messageInfo_LuaBgm proto.InternalMessageInfo

func (m *LuaBgm) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaBgm) GetBgmNameID() []byte {
	if m != nil {
		return m.BgmNameID
	}
	return nil
}

func (m *LuaBgm) GetSound() []byte {
	if m != nil {
		return m.Sound
	}
	return nil
}

func (m *LuaBgm) GetNeedVipLevel() int32 {
	if m != nil && m.NeedVipLevel != nil {
		return *m.NeedVipLevel
	}
	return 0
}

func (m *LuaBgm) GetTime() float32 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

// Excel:竞技场表.xls sheet:挑战奖励表
type LuaArenaReward struct {
	Level                *int32        `protobuf:"zigzag32,1,opt,name=level" json:"level,omitempty"`
	WinRewardList        []*ItemConfig `protobuf:"bytes,2,rep,name=winRewardList" json:"winRewardList,omitempty"`
	LoseRewardList       []*ItemConfig `protobuf:"bytes,3,rep,name=loseRewardList" json:"loseRewardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaArenaReward) Reset()         { *m = LuaArenaReward{} }
func (m *LuaArenaReward) String() string { return proto.CompactTextString(m) }
func (*LuaArenaReward) ProtoMessage()    {}
func (*LuaArenaReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{6}
}
func (m *LuaArenaReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaArenaReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaArenaReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaArenaReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaArenaReward.Merge(m, src)
}
func (m *LuaArenaReward) XXX_Size() int {
	return m.Size()
}
func (m *LuaArenaReward) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaArenaReward.DiscardUnknown(m)
}

var xxx_messageInfo_LuaArenaReward proto.InternalMessageInfo

func (m *LuaArenaReward) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaArenaReward) GetWinRewardList() []*ItemConfig {
	if m != nil {
		return m.WinRewardList
	}
	return nil
}

func (m *LuaArenaReward) GetLoseRewardList() []*ItemConfig {
	if m != nil {
		return m.LoseRewardList
	}
	return nil
}

// Excel:竞技场表.xls sheet:挑战对手选取表
type LuaArenaSelectRule struct {
	Id                   *int32          `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	RankRect             []int32         `protobuf:"zigzag32,2,rep,name=rankRect" json:"rankRect,omitempty"`
	PosRectList          []*LuaArenaRect `protobuf:"bytes,3,rep,name=posRectList" json:"posRectList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *LuaArenaSelectRule) Reset()         { *m = LuaArenaSelectRule{} }
func (m *LuaArenaSelectRule) String() string { return proto.CompactTextString(m) }
func (*LuaArenaSelectRule) ProtoMessage()    {}
func (*LuaArenaSelectRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{7}
}
func (m *LuaArenaSelectRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaArenaSelectRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaArenaSelectRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaArenaSelectRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaArenaSelectRule.Merge(m, src)
}
func (m *LuaArenaSelectRule) XXX_Size() int {
	return m.Size()
}
func (m *LuaArenaSelectRule) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaArenaSelectRule.DiscardUnknown(m)
}

var xxx_messageInfo_LuaArenaSelectRule proto.InternalMessageInfo

func (m *LuaArenaSelectRule) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaArenaSelectRule) GetRankRect() []int32 {
	if m != nil {
		return m.RankRect
	}
	return nil
}

func (m *LuaArenaSelectRule) GetPosRectList() []*LuaArenaRect {
	if m != nil {
		return m.PosRectList
	}
	return nil
}

// Excel:f副本表.xls sheet:精英章节表
type LuaDangerChapter struct {
	Id                   *int32        `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte        `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	DupList              []int32       `protobuf:"zigzag32,3,rep,name=dupList" json:"dupList,omitempty"`
	Icon                 []byte        `protobuf:"bytes,4,opt,name=icon" json:"icon,omitempty"`
	Title                []byte        `protobuf:"bytes,5,opt,name=title" json:"title,omitempty"`
	LockIcon             []byte        `protobuf:"bytes,6,opt,name=lockIcon" json:"lockIcon,omitempty"`
	RewardList           []*ItemConfig `protobuf:"bytes,7,rep,name=rewardList" json:"rewardList,omitempty"`
	SharePic             []byte        `protobuf:"bytes,8,opt,name=sharePic" json:"sharePic,omitempty"`
	EnemyPos             *LuaPos       `protobuf:"bytes,9,opt,name=enemyPos" json:"enemyPos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaDangerChapter) Reset()         { *m = LuaDangerChapter{} }
func (m *LuaDangerChapter) String() string { return proto.CompactTextString(m) }
func (*LuaDangerChapter) ProtoMessage()    {}
func (*LuaDangerChapter) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{8}
}
func (m *LuaDangerChapter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaDangerChapter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaDangerChapter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaDangerChapter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaDangerChapter.Merge(m, src)
}
func (m *LuaDangerChapter) XXX_Size() int {
	return m.Size()
}
func (m *LuaDangerChapter) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaDangerChapter.DiscardUnknown(m)
}

var xxx_messageInfo_LuaDangerChapter proto.InternalMessageInfo

func (m *LuaDangerChapter) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaDangerChapter) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaDangerChapter) GetDupList() []int32 {
	if m != nil {
		return m.DupList
	}
	return nil
}

func (m *LuaDangerChapter) GetIcon() []byte {
	if m != nil {
		return m.Icon
	}
	return nil
}

func (m *LuaDangerChapter) GetTitle() []byte {
	if m != nil {
		return m.Title
	}
	return nil
}

func (m *LuaDangerChapter) GetLockIcon() []byte {
	if m != nil {
		return m.LockIcon
	}
	return nil
}

func (m *LuaDangerChapter) GetRewardList() []*ItemConfig {
	if m != nil {
		return m.RewardList
	}
	return nil
}

func (m *LuaDangerChapter) GetSharePic() []byte {
	if m != nil {
		return m.SharePic
	}
	return nil
}

func (m *LuaDangerChapter) GetEnemyPos() *LuaPos {
	if m != nil {
		return m.EnemyPos
	}
	return nil
}

// Excel:x小助手表.xls sheet:游戏提示表
type LuaAssistantTip struct {
	Id                   *int32      `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	QuestionID           []byte      `protobuf:"bytes,2,opt,name=questionID" json:"questionID,omitempty"`
	AnswerID             []byte      `protobuf:"bytes,3,opt,name=answerID" json:"answerID,omitempty"`
	Icon                 []byte      `protobuf:"bytes,4,opt,name=icon" json:"icon,omitempty"`
	Reward               *ItemConfig `protobuf:"bytes,5,opt,name=reward" json:"reward,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *LuaAssistantTip) Reset()         { *m = LuaAssistantTip{} }
func (m *LuaAssistantTip) String() string { return proto.CompactTextString(m) }
func (*LuaAssistantTip) ProtoMessage()    {}
func (*LuaAssistantTip) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{9}
}
func (m *LuaAssistantTip) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaAssistantTip) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaAssistantTip.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaAssistantTip) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaAssistantTip.Merge(m, src)
}
func (m *LuaAssistantTip) XXX_Size() int {
	return m.Size()
}
func (m *LuaAssistantTip) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaAssistantTip.DiscardUnknown(m)
}

var xxx_messageInfo_LuaAssistantTip proto.InternalMessageInfo

func (m *LuaAssistantTip) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaAssistantTip) GetQuestionID() []byte {
	if m != nil {
		return m.QuestionID
	}
	return nil
}

func (m *LuaAssistantTip) GetAnswerID() []byte {
	if m != nil {
		return m.AnswerID
	}
	return nil
}

func (m *LuaAssistantTip) GetIcon() []byte {
	if m != nil {
		return m.Icon
	}
	return nil
}

func (m *LuaAssistantTip) GetReward() *ItemConfig {
	if m != nil {
		return m.Reward
	}
	return nil
}

// Excel:equip装备.xls sheet:载具合成
type LuaVehicleCompose struct {
	Quality              *int32        `protobuf:"zigzag32,1,opt,name=quality" json:"quality,omitempty"`
	NeedItemList         []*ItemConfig `protobuf:"bytes,2,rep,name=needItemList" json:"needItemList,omitempty"`
	NeedLevel            *int32        `protobuf:"zigzag32,3,opt,name=needLevel" json:"needLevel,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaVehicleCompose) Reset()         { *m = LuaVehicleCompose{} }
func (m *LuaVehicleCompose) String() string { return proto.CompactTextString(m) }
func (*LuaVehicleCompose) ProtoMessage()    {}
func (*LuaVehicleCompose) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{10}
}
func (m *LuaVehicleCompose) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaVehicleCompose) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaVehicleCompose.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaVehicleCompose) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaVehicleCompose.Merge(m, src)
}
func (m *LuaVehicleCompose) XXX_Size() int {
	return m.Size()
}
func (m *LuaVehicleCompose) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaVehicleCompose.DiscardUnknown(m)
}

var xxx_messageInfo_LuaVehicleCompose proto.InternalMessageInfo

func (m *LuaVehicleCompose) GetQuality() int32 {
	if m != nil && m.Quality != nil {
		return *m.Quality
	}
	return 0
}

func (m *LuaVehicleCompose) GetNeedItemList() []*ItemConfig {
	if m != nil {
		return m.NeedItemList
	}
	return nil
}

func (m *LuaVehicleCompose) GetNeedLevel() int32 {
	if m != nil && m.NeedLevel != nil {
		return *m.NeedLevel
	}
	return 0
}

// Excel:f副本表.xls sheet:章节表
type LuaChapter struct {
	Id                   *int32        `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte        `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	DupList              []int32       `protobuf:"zigzag32,3,rep,name=dupList" json:"dupList,omitempty"`
	Icon                 []byte        `protobuf:"bytes,4,opt,name=icon" json:"icon,omitempty"`
	Title                []byte        `protobuf:"bytes,5,opt,name=title" json:"title,omitempty"`
	LockIcon             []byte        `protobuf:"bytes,6,opt,name=lockIcon" json:"lockIcon,omitempty"`
	RewardList           []*ItemConfig `protobuf:"bytes,7,rep,name=rewardList" json:"rewardList,omitempty"`
	SharePic             []byte        `protobuf:"bytes,8,opt,name=sharePic" json:"sharePic,omitempty"`
	EnemyPos             *LuaPos       `protobuf:"bytes,9,opt,name=enemyPos" json:"enemyPos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaChapter) Reset()         { *m = LuaChapter{} }
func (m *LuaChapter) String() string { return proto.CompactTextString(m) }
func (*LuaChapter) ProtoMessage()    {}
func (*LuaChapter) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{11}
}
func (m *LuaChapter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaChapter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaChapter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaChapter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaChapter.Merge(m, src)
}
func (m *LuaChapter) XXX_Size() int {
	return m.Size()
}
func (m *LuaChapter) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaChapter.DiscardUnknown(m)
}

var xxx_messageInfo_LuaChapter proto.InternalMessageInfo

func (m *LuaChapter) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaChapter) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaChapter) GetDupList() []int32 {
	if m != nil {
		return m.DupList
	}
	return nil
}

func (m *LuaChapter) GetIcon() []byte {
	if m != nil {
		return m.Icon
	}
	return nil
}

func (m *LuaChapter) GetTitle() []byte {
	if m != nil {
		return m.Title
	}
	return nil
}

func (m *LuaChapter) GetLockIcon() []byte {
	if m != nil {
		return m.LockIcon
	}
	return nil
}

func (m *LuaChapter) GetRewardList() []*ItemConfig {
	if m != nil {
		return m.RewardList
	}
	return nil
}

func (m *LuaChapter) GetSharePic() []byte {
	if m != nil {
		return m.SharePic
	}
	return nil
}

func (m *LuaChapter) GetEnemyPos() *LuaPos {
	if m != nil {
		return m.EnemyPos
	}
	return nil
}

// Excel:场景表.xls sheet:建筑表
type LuaBuilding struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte   `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	ZOrder               *int32   `protobuf:"zigzag32,3,opt,name=zOrder" json:"zOrder,omitempty"`
	Type                 *int32   `protobuf:"zigzag32,4,opt,name=type" json:"type,omitempty"`
	ResType              *int32   `protobuf:"zigzag32,5,opt,name=resType" json:"resType,omitempty"`
	Res                  []byte   `protobuf:"bytes,6,opt,name=res" json:"res,omitempty"`
	Pos                  *LuaPos  `protobuf:"bytes,7,opt,name=pos" json:"pos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaBuilding) Reset()         { *m = LuaBuilding{} }
func (m *LuaBuilding) String() string { return proto.CompactTextString(m) }
func (*LuaBuilding) ProtoMessage()    {}
func (*LuaBuilding) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{12}
}
func (m *LuaBuilding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaBuilding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaBuilding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaBuilding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaBuilding.Merge(m, src)
}
func (m *LuaBuilding) XXX_Size() int {
	return m.Size()
}
func (m *LuaBuilding) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaBuilding.DiscardUnknown(m)
}

var xxx_messageInfo_LuaBuilding proto.InternalMessageInfo

func (m *LuaBuilding) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaBuilding) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaBuilding) GetZOrder() int32 {
	if m != nil && m.ZOrder != nil {
		return *m.ZOrder
	}
	return 0
}

func (m *LuaBuilding) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaBuilding) GetResType() int32 {
	if m != nil && m.ResType != nil {
		return *m.ResType
	}
	return 0
}

func (m *LuaBuilding) GetRes() []byte {
	if m != nil {
		return m.Res
	}
	return nil
}

func (m *LuaBuilding) GetPos() *LuaPos {
	if m != nil {
		return m.Pos
	}
	return nil
}

// Excel:道具商店表.xls sheet:棒棒糖商店
type LuaDiamondShop struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	ItemID               *int32   `protobuf:"zigzag32,2,opt,name=itemID" json:"itemID,omitempty"`
	Num                  *int32   `protobuf:"zigzag32,3,opt,name=num" json:"num,omitempty"`
	CostType             *int32   `protobuf:"zigzag32,4,opt,name=costType" json:"costType,omitempty"`
	Price                *int32   `protobuf:"zigzag32,5,opt,name=price" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaDiamondShop) Reset()         { *m = LuaDiamondShop{} }
func (m *LuaDiamondShop) String() string { return proto.CompactTextString(m) }
func (*LuaDiamondShop) ProtoMessage()    {}
func (*LuaDiamondShop) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{13}
}
func (m *LuaDiamondShop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaDiamondShop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaDiamondShop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaDiamondShop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaDiamondShop.Merge(m, src)
}
func (m *LuaDiamondShop) XXX_Size() int {
	return m.Size()
}
func (m *LuaDiamondShop) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaDiamondShop.DiscardUnknown(m)
}

var xxx_messageInfo_LuaDiamondShop proto.InternalMessageInfo

func (m *LuaDiamondShop) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaDiamondShop) GetItemID() int32 {
	if m != nil && m.ItemID != nil {
		return *m.ItemID
	}
	return 0
}

func (m *LuaDiamondShop) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

func (m *LuaDiamondShop) GetCostType() int32 {
	if m != nil && m.CostType != nil {
		return *m.CostType
	}
	return 0
}

func (m *LuaDiamondShop) GetPrice() int32 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

// Excel:q抢车位.xls sheet:破坏效果
type LuaParkBreak struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte   `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	DescID               []byte   `protobuf:"bytes,3,opt,name=descID" json:"descID,omitempty"`
	Res                  []byte   `protobuf:"bytes,4,opt,name=res" json:"res,omitempty"`
	Effect               []byte   `protobuf:"bytes,5,opt,name=effect" json:"effect,omitempty"`
	ValueList            []int32  `protobuf:"zigzag32,6,rep,name=valueList" json:"valueList,omitempty"`
	Sound                []byte   `protobuf:"bytes,7,opt,name=sound" json:"sound,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaParkBreak) Reset()         { *m = LuaParkBreak{} }
func (m *LuaParkBreak) String() string { return proto.CompactTextString(m) }
func (*LuaParkBreak) ProtoMessage()    {}
func (*LuaParkBreak) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{14}
}
func (m *LuaParkBreak) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaParkBreak) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaParkBreak.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaParkBreak) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaParkBreak.Merge(m, src)
}
func (m *LuaParkBreak) XXX_Size() int {
	return m.Size()
}
func (m *LuaParkBreak) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaParkBreak.DiscardUnknown(m)
}

var xxx_messageInfo_LuaParkBreak proto.InternalMessageInfo

func (m *LuaParkBreak) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaParkBreak) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaParkBreak) GetDescID() []byte {
	if m != nil {
		return m.DescID
	}
	return nil
}

func (m *LuaParkBreak) GetRes() []byte {
	if m != nil {
		return m.Res
	}
	return nil
}

func (m *LuaParkBreak) GetEffect() []byte {
	if m != nil {
		return m.Effect
	}
	return nil
}

func (m *LuaParkBreak) GetValueList() []int32 {
	if m != nil {
		return m.ValueList
	}
	return nil
}

func (m *LuaParkBreak) GetSound() []byte {
	if m != nil {
		return m.Sound
	}
	return nil
}

// Excel:q抢车位.xls sheet:车辆列表
type LuaParkCar struct {
	Id                      *int32      `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID                  []byte      `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	Icon                    *int32      `protobuf:"zigzag32,3,opt,name=icon" json:"icon,omitempty"`
	Quality                 *int32      `protobuf:"zigzag32,4,opt,name=quality" json:"quality,omitempty"`
	MaxLevel                *int32      `protobuf:"zigzag32,5,opt,name=maxLevel" json:"maxLevel,omitempty"`
	ParkTime                *int32      `protobuf:"zigzag32,6,opt,name=parkTime" json:"parkTime,omitempty"`
	ProtectValue            *int32      `protobuf:"zigzag32,7,opt,name=protectValue" json:"protectValue,omitempty"`
	LastProtectValue        *int32      `protobuf:"zigzag32,8,opt,name=lastProtectValue" json:"lastProtectValue,omitempty"`
	RepairCostCount         *int32      `protobuf:"zigzag32,9,opt,name=repairCostCount" json:"repairCostCount,omitempty"`
	DecomposeGetCount       *int32      `protobuf:"zigzag32,10,opt,name=decomposeGetCount" json:"decomposeGetCount,omitempty"`
	ParkUnitBenefit         *ItemConfig `protobuf:"bytes,11,opt,name=parkUnitBenefit" json:"parkUnitBenefit,omitempty"`
	AddParkUnitBenefitRate  *float32    `protobuf:"fixed32,12,opt,name=addParkUnitBenefitRate" json:"addParkUnitBenefitRate,omitempty"`
	SayYesReduceMaxParkTime *int32      `protobuf:"zigzag32,13,opt,name=sayYesReduceMaxParkTime" json:"sayYesReduceMaxParkTime,omitempty"`
	ParkOffset              *LuaPos     `protobuf:"bytes,14,opt,name=parkOffset" json:"parkOffset,omitempty"`
	ShowOffset              *LuaPos     `protobuf:"bytes,15,opt,name=showOffset" json:"showOffset,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}    `json:"-"`
	XXX_unrecognized        []byte      `json:"-"`
	XXX_sizecache           int32       `json:"-"`
}

func (m *LuaParkCar) Reset()         { *m = LuaParkCar{} }
func (m *LuaParkCar) String() string { return proto.CompactTextString(m) }
func (*LuaParkCar) ProtoMessage()    {}
func (*LuaParkCar) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{15}
}
func (m *LuaParkCar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaParkCar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaParkCar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaParkCar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaParkCar.Merge(m, src)
}
func (m *LuaParkCar) XXX_Size() int {
	return m.Size()
}
func (m *LuaParkCar) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaParkCar.DiscardUnknown(m)
}

var xxx_messageInfo_LuaParkCar proto.InternalMessageInfo

func (m *LuaParkCar) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaParkCar) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaParkCar) GetIcon() int32 {
	if m != nil && m.Icon != nil {
		return *m.Icon
	}
	return 0
}

func (m *LuaParkCar) GetQuality() int32 {
	if m != nil && m.Quality != nil {
		return *m.Quality
	}
	return 0
}

func (m *LuaParkCar) GetMaxLevel() int32 {
	if m != nil && m.MaxLevel != nil {
		return *m.MaxLevel
	}
	return 0
}

func (m *LuaParkCar) GetParkTime() int32 {
	if m != nil && m.ParkTime != nil {
		return *m.ParkTime
	}
	return 0
}

func (m *LuaParkCar) GetProtectValue() int32 {
	if m != nil && m.ProtectValue != nil {
		return *m.ProtectValue
	}
	return 0
}

func (m *LuaParkCar) GetLastProtectValue() int32 {
	if m != nil && m.LastProtectValue != nil {
		return *m.LastProtectValue
	}
	return 0
}

func (m *LuaParkCar) GetRepairCostCount() int32 {
	if m != nil && m.RepairCostCount != nil {
		return *m.RepairCostCount
	}
	return 0
}

func (m *LuaParkCar) GetDecomposeGetCount() int32 {
	if m != nil && m.DecomposeGetCount != nil {
		return *m.DecomposeGetCount
	}
	return 0
}

func (m *LuaParkCar) GetParkUnitBenefit() *ItemConfig {
	if m != nil {
		return m.ParkUnitBenefit
	}
	return nil
}

func (m *LuaParkCar) GetAddParkUnitBenefitRate() float32 {
	if m != nil && m.AddParkUnitBenefitRate != nil {
		return *m.AddParkUnitBenefitRate
	}
	return 0
}

func (m *LuaParkCar) GetSayYesReduceMaxParkTime() int32 {
	if m != nil && m.SayYesReduceMaxParkTime != nil {
		return *m.SayYesReduceMaxParkTime
	}
	return 0
}

func (m *LuaParkCar) GetParkOffset() *LuaPos {
	if m != nil {
		return m.ParkOffset
	}
	return nil
}

func (m *LuaParkCar) GetShowOffset() *LuaPos {
	if m != nil {
		return m.ShowOffset
	}
	return nil
}

// Excel:pet宠物.xls sheet:宠物被动技能
type LuaPetPassiveTalent struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	TalentId             []byte   `protobuf:"bytes,2,opt,name=talentId" json:"talentId,omitempty"`
	TalentDesId          []byte   `protobuf:"bytes,3,opt,name=talentDesId" json:"talentDesId,omitempty"`
	IconId               []byte   `protobuf:"bytes,4,opt,name=iconId" json:"iconId,omitempty"`
	Weight               *int32   `protobuf:"zigzag32,5,opt,name=weight" json:"weight,omitempty"`
	Type                 *int32   `protobuf:"zigzag32,6,opt,name=type" json:"type,omitempty"`
	ArgList              []int32  `protobuf:"zigzag32,7,rep,name=argList" json:"argList,omitempty"`
	ValueList            []int32  `protobuf:"zigzag32,8,rep,name=valueList" json:"valueList,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaPetPassiveTalent) Reset()         { *m = LuaPetPassiveTalent{} }
func (m *LuaPetPassiveTalent) String() string { return proto.CompactTextString(m) }
func (*LuaPetPassiveTalent) ProtoMessage()    {}
func (*LuaPetPassiveTalent) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{16}
}
func (m *LuaPetPassiveTalent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaPetPassiveTalent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaPetPassiveTalent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaPetPassiveTalent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaPetPassiveTalent.Merge(m, src)
}
func (m *LuaPetPassiveTalent) XXX_Size() int {
	return m.Size()
}
func (m *LuaPetPassiveTalent) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaPetPassiveTalent.DiscardUnknown(m)
}

var xxx_messageInfo_LuaPetPassiveTalent proto.InternalMessageInfo

func (m *LuaPetPassiveTalent) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaPetPassiveTalent) GetTalentId() []byte {
	if m != nil {
		return m.TalentId
	}
	return nil
}

func (m *LuaPetPassiveTalent) GetTalentDesId() []byte {
	if m != nil {
		return m.TalentDesId
	}
	return nil
}

func (m *LuaPetPassiveTalent) GetIconId() []byte {
	if m != nil {
		return m.IconId
	}
	return nil
}

func (m *LuaPetPassiveTalent) GetWeight() int32 {
	if m != nil && m.Weight != nil {
		return *m.Weight
	}
	return 0
}

func (m *LuaPetPassiveTalent) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaPetPassiveTalent) GetArgList() []int32 {
	if m != nil {
		return m.ArgList
	}
	return nil
}

func (m *LuaPetPassiveTalent) GetValueList() []int32 {
	if m != nil {
		return m.ValueList
	}
	return nil
}

// Excel:t图鉴表.xls sheet:装备图鉴奖励
type LuaEquipManual struct {
	Num                  *int32      `protobuf:"zigzag32,1,opt,name=num" json:"num,omitempty"`
	Reward               *ItemConfig `protobuf:"bytes,2,opt,name=reward" json:"reward,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *LuaEquipManual) Reset()         { *m = LuaEquipManual{} }
func (m *LuaEquipManual) String() string { return proto.CompactTextString(m) }
func (*LuaEquipManual) ProtoMessage()    {}
func (*LuaEquipManual) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{17}
}
func (m *LuaEquipManual) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaEquipManual) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaEquipManual.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaEquipManual) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaEquipManual.Merge(m, src)
}
func (m *LuaEquipManual) XXX_Size() int {
	return m.Size()
}
func (m *LuaEquipManual) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaEquipManual.DiscardUnknown(m)
}

var xxx_messageInfo_LuaEquipManual proto.InternalMessageInfo

func (m *LuaEquipManual) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

func (m *LuaEquipManual) GetReward() *ItemConfig {
	if m != nil {
		return m.Reward
	}
	return nil
}

// Excel:道具商店表.xls sheet:小游戏商店
type LuaMinigameShop struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	ItemID               *int32   `protobuf:"zigzag32,2,opt,name=itemID" json:"itemID,omitempty"`
	Num                  *int32   `protobuf:"zigzag32,3,opt,name=num" json:"num,omitempty"`
	CostType             *int32   `protobuf:"zigzag32,4,opt,name=costType" json:"costType,omitempty"`
	Price                *int32   `protobuf:"zigzag32,5,opt,name=price" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaMinigameShop) Reset()         { *m = LuaMinigameShop{} }
func (m *LuaMinigameShop) String() string { return proto.CompactTextString(m) }
func (*LuaMinigameShop) ProtoMessage()    {}
func (*LuaMinigameShop) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{18}
}
func (m *LuaMinigameShop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaMinigameShop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaMinigameShop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaMinigameShop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaMinigameShop.Merge(m, src)
}
func (m *LuaMinigameShop) XXX_Size() int {
	return m.Size()
}
func (m *LuaMinigameShop) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaMinigameShop.DiscardUnknown(m)
}

var xxx_messageInfo_LuaMinigameShop proto.InternalMessageInfo

func (m *LuaMinigameShop) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaMinigameShop) GetItemID() int32 {
	if m != nil && m.ItemID != nil {
		return *m.ItemID
	}
	return 0
}

func (m *LuaMinigameShop) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

func (m *LuaMinigameShop) GetCostType() int32 {
	if m != nil && m.CostType != nil {
		return *m.CostType
	}
	return 0
}

func (m *LuaMinigameShop) GetPrice() int32 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

// Excel:场景表.xls sheet:传送信息表
type LuaTransInfo struct {
	Id                   *int32    `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	TargetID             *int32    `protobuf:"zigzag32,2,opt,name=targetID" json:"targetID,omitempty"`
	Rect                 []*LuaPos `protobuf:"bytes,3,rep,name=rect" json:"rect,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *LuaTransInfo) Reset()         { *m = LuaTransInfo{} }
func (m *LuaTransInfo) String() string { return proto.CompactTextString(m) }
func (*LuaTransInfo) ProtoMessage()    {}
func (*LuaTransInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{19}
}
func (m *LuaTransInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaTransInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaTransInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaTransInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaTransInfo.Merge(m, src)
}
func (m *LuaTransInfo) XXX_Size() int {
	return m.Size()
}
func (m *LuaTransInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaTransInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LuaTransInfo proto.InternalMessageInfo

func (m *LuaTransInfo) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaTransInfo) GetTargetID() int32 {
	if m != nil && m.TargetID != nil {
		return *m.TargetID
	}
	return 0
}

func (m *LuaTransInfo) GetRect() []*LuaPos {
	if m != nil {
		return m.Rect
	}
	return nil
}

// Excel:j技能表.xls sheet:技能表
type LuaSkill struct {
	Id                   *int32         `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte         `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	DescID               []byte         `protobuf:"bytes,3,opt,name=descID" json:"descID,omitempty"`
	ArmaType             *int32         `protobuf:"zigzag32,4,opt,name=armaType" json:"armaType,omitempty"`
	Type                 *int32         `protobuf:"zigzag32,5,opt,name=type" json:"type,omitempty"`
	EventConList         []int32        `protobuf:"zigzag32,6,rep,name=eventConList" json:"eventConList,omitempty"`
	EventValList         []int32        `protobuf:"zigzag32,7,rep,name=eventValList" json:"eventValList,omitempty"`
	AtkEffList           []int32        `protobuf:"zigzag32,8,rep,name=atkEffList" json:"atkEffList,omitempty"`
	DefEffList           []int32        `protobuf:"zigzag32,9,rep,name=defEffList" json:"defEffList,omitempty"`
	PreAtkEffList        []int32        `protobuf:"zigzag32,10,rep,name=preAtkEffList" json:"preAtkEffList,omitempty"`
	PreDefEffList        []int32        `protobuf:"zigzag32,11,rep,name=preDefEffList" json:"preDefEffList,omitempty"`
	AtkSound             []byte         `protobuf:"bytes,12,opt,name=atkSound" json:"atkSound,omitempty"`
	FlyEffIDList         []int32        `protobuf:"zigzag32,13,rep,name=flyEffIDList" json:"flyEffIDList,omitempty"`
	HurtEffIDList        []int32        `protobuf:"zigzag32,14,rep,name=hurtEffIDList" json:"hurtEffIDList,omitempty"`
	ResIndex             *int32         `protobuf:"zigzag32,15,opt,name=resIndex" json:"resIndex,omitempty"`
	PreAnim              []byte         `protobuf:"bytes,16,opt,name=preAnim" json:"preAnim,omitempty"`
	PreTime              *float32       `protobuf:"fixed32,17,opt,name=preTime" json:"preTime,omitempty"`
	FlyAnim              []byte         `protobuf:"bytes,18,opt,name=flyAnim" json:"flyAnim,omitempty"`
	AtkAnim              []byte         `protobuf:"bytes,19,opt,name=atkAnim" json:"atkAnim,omitempty"`
	AtkTimeList          []float32      `protobuf:"fixed32,20,rep,name=atkTimeList" json:"atkTimeList,omitempty"`
	AtkHurtPerList       []int32        `protobuf:"zigzag32,21,rep,name=atkHurtPerList" json:"atkHurtPerList,omitempty"`
	AtkSoundList         [][]byte       `protobuf:"bytes,22,rep,name=atkSoundList" json:"atkSoundList,omitempty"`
	ShakeTimeList        []*ShakeConfig `protobuf:"bytes,23,rep,name=shakeTimeList" json:"shakeTimeList,omitempty"`
	AtkEndTime           *float32       `protobuf:"fixed32,24,opt,name=atkEndTime" json:"atkEndTime,omitempty"`
	TargetType           *int32         `protobuf:"zigzag32,25,opt,name=targetType" json:"targetType,omitempty"`
	DisType              *int32         `protobuf:"zigzag32,26,opt,name=disType" json:"disType,omitempty"`
	StartBuffTargetList  []int32        `protobuf:"zigzag32,27,rep,name=startBuffTargetList" json:"startBuffTargetList,omitempty"`
	StartBuffList        []int32        `protobuf:"zigzag32,28,rep,name=startBuffList" json:"startBuffList,omitempty"`
	EndBuffTargetList    []int32        `protobuf:"zigzag32,29,rep,name=endBuffTargetList" json:"endBuffTargetList,omitempty"`
	EndBuffList          []int32        `protobuf:"zigzag32,30,rep,name=endBuffList" json:"endBuffList,omitempty"`
	DamageType           *int32         `protobuf:"zigzag32,31,opt,name=damageType" json:"damageType,omitempty"`
	PerHurtList          []int32        `protobuf:"zigzag32,32,rep,name=perHurtList" json:"perHurtList,omitempty"`
	FixHurtList          []int32        `protobuf:"zigzag32,33,rep,name=fixHurtList" json:"fixHurtList,omitempty"`
	HurtSound            []byte         `protobuf:"bytes,34,opt,name=hurtSound" json:"hurtSound,omitempty"`
	HurtTypeData         []int32        `protobuf:"zigzag32,35,rep,name=hurtTypeData" json:"hurtTypeData,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *LuaSkill) Reset()         { *m = LuaSkill{} }
func (m *LuaSkill) String() string { return proto.CompactTextString(m) }
func (*LuaSkill) ProtoMessage()    {}
func (*LuaSkill) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{20}
}
func (m *LuaSkill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaSkill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaSkill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaSkill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaSkill.Merge(m, src)
}
func (m *LuaSkill) XXX_Size() int {
	return m.Size()
}
func (m *LuaSkill) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaSkill.DiscardUnknown(m)
}

var xxx_messageInfo_LuaSkill proto.InternalMessageInfo

func (m *LuaSkill) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaSkill) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaSkill) GetDescID() []byte {
	if m != nil {
		return m.DescID
	}
	return nil
}

func (m *LuaSkill) GetArmaType() int32 {
	if m != nil && m.ArmaType != nil {
		return *m.ArmaType
	}
	return 0
}

func (m *LuaSkill) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaSkill) GetEventConList() []int32 {
	if m != nil {
		return m.EventConList
	}
	return nil
}

func (m *LuaSkill) GetEventValList() []int32 {
	if m != nil {
		return m.EventValList
	}
	return nil
}

func (m *LuaSkill) GetAtkEffList() []int32 {
	if m != nil {
		return m.AtkEffList
	}
	return nil
}

func (m *LuaSkill) GetDefEffList() []int32 {
	if m != nil {
		return m.DefEffList
	}
	return nil
}

func (m *LuaSkill) GetPreAtkEffList() []int32 {
	if m != nil {
		return m.PreAtkEffList
	}
	return nil
}

func (m *LuaSkill) GetPreDefEffList() []int32 {
	if m != nil {
		return m.PreDefEffList
	}
	return nil
}

func (m *LuaSkill) GetAtkSound() []byte {
	if m != nil {
		return m.AtkSound
	}
	return nil
}

func (m *LuaSkill) GetFlyEffIDList() []int32 {
	if m != nil {
		return m.FlyEffIDList
	}
	return nil
}

func (m *LuaSkill) GetHurtEffIDList() []int32 {
	if m != nil {
		return m.HurtEffIDList
	}
	return nil
}

func (m *LuaSkill) GetResIndex() int32 {
	if m != nil && m.ResIndex != nil {
		return *m.ResIndex
	}
	return 0
}

func (m *LuaSkill) GetPreAnim() []byte {
	if m != nil {
		return m.PreAnim
	}
	return nil
}

func (m *LuaSkill) GetPreTime() float32 {
	if m != nil && m.PreTime != nil {
		return *m.PreTime
	}
	return 0
}

func (m *LuaSkill) GetFlyAnim() []byte {
	if m != nil {
		return m.FlyAnim
	}
	return nil
}

func (m *LuaSkill) GetAtkAnim() []byte {
	if m != nil {
		return m.AtkAnim
	}
	return nil
}

func (m *LuaSkill) GetAtkTimeList() []float32 {
	if m != nil {
		return m.AtkTimeList
	}
	return nil
}

func (m *LuaSkill) GetAtkHurtPerList() []int32 {
	if m != nil {
		return m.AtkHurtPerList
	}
	return nil
}

func (m *LuaSkill) GetAtkSoundList() [][]byte {
	if m != nil {
		return m.AtkSoundList
	}
	return nil
}

func (m *LuaSkill) GetShakeTimeList() []*ShakeConfig {
	if m != nil {
		return m.ShakeTimeList
	}
	return nil
}

func (m *LuaSkill) GetAtkEndTime() float32 {
	if m != nil && m.AtkEndTime != nil {
		return *m.AtkEndTime
	}
	return 0
}

func (m *LuaSkill) GetTargetType() int32 {
	if m != nil && m.TargetType != nil {
		return *m.TargetType
	}
	return 0
}

func (m *LuaSkill) GetDisType() int32 {
	if m != nil && m.DisType != nil {
		return *m.DisType
	}
	return 0
}

func (m *LuaSkill) GetStartBuffTargetList() []int32 {
	if m != nil {
		return m.StartBuffTargetList
	}
	return nil
}

func (m *LuaSkill) GetStartBuffList() []int32 {
	if m != nil {
		return m.StartBuffList
	}
	return nil
}

func (m *LuaSkill) GetEndBuffTargetList() []int32 {
	if m != nil {
		return m.EndBuffTargetList
	}
	return nil
}

func (m *LuaSkill) GetEndBuffList() []int32 {
	if m != nil {
		return m.EndBuffList
	}
	return nil
}

func (m *LuaSkill) GetDamageType() int32 {
	if m != nil && m.DamageType != nil {
		return *m.DamageType
	}
	return 0
}

func (m *LuaSkill) GetPerHurtList() []int32 {
	if m != nil {
		return m.PerHurtList
	}
	return nil
}

func (m *LuaSkill) GetFixHurtList() []int32 {
	if m != nil {
		return m.FixHurtList
	}
	return nil
}

func (m *LuaSkill) GetHurtSound() []byte {
	if m != nil {
		return m.HurtSound
	}
	return nil
}

func (m *LuaSkill) GetHurtTypeData() []int32 {
	if m != nil {
		return m.HurtTypeData
	}
	return nil
}

// Excel:购买消耗表.xls sheet:购买体力消耗表
type LuaBuyStamina struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	Diamond              *int32   `protobuf:"zigzag32,2,opt,name=diamond" json:"diamond,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaBuyStamina) Reset()         { *m = LuaBuyStamina{} }
func (m *LuaBuyStamina) String() string { return proto.CompactTextString(m) }
func (*LuaBuyStamina) ProtoMessage()    {}
func (*LuaBuyStamina) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{21}
}
func (m *LuaBuyStamina) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaBuyStamina) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaBuyStamina.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaBuyStamina) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaBuyStamina.Merge(m, src)
}
func (m *LuaBuyStamina) XXX_Size() int {
	return m.Size()
}
func (m *LuaBuyStamina) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaBuyStamina.DiscardUnknown(m)
}

var xxx_messageInfo_LuaBuyStamina proto.InternalMessageInfo

func (m *LuaBuyStamina) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaBuyStamina) GetDiamond() int32 {
	if m != nil && m.Diamond != nil {
		return *m.Diamond
	}
	return 0
}

// Excel:二次元配置表.xls sheet:BOSS表
type LuaGuadraticBoss struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	EnterType            *int32   `protobuf:"zigzag32,2,opt,name=enterType" json:"enterType,omitempty"`
	ExitType             *int32   `protobuf:"zigzag32,3,opt,name=exitType" json:"exitType,omitempty"`
	MoveSpeed            *int32   `protobuf:"zigzag32,4,opt,name=moveSpeed" json:"moveSpeed,omitempty"`
	EnterTime            *int32   `protobuf:"zigzag32,5,opt,name=enterTime" json:"enterTime,omitempty"`
	EnterHurt            *int32   `protobuf:"zigzag32,6,opt,name=enterHurt" json:"enterHurt,omitempty"`
	EnterHurtSize        *LuaSize `protobuf:"bytes,7,opt,name=enterHurtSize" json:"enterHurtSize,omitempty"`
	Res                  []byte   `protobuf:"bytes,8,opt,name=res" json:"res,omitempty"`
	EnterSound           []byte   `protobuf:"bytes,9,opt,name=enterSound" json:"enterSound,omitempty"`
	SkillList            []int32  `protobuf:"zigzag32,10,rep,name=skillList" json:"skillList,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaGuadraticBoss) Reset()         { *m = LuaGuadraticBoss{} }
func (m *LuaGuadraticBoss) String() string { return proto.CompactTextString(m) }
func (*LuaGuadraticBoss) ProtoMessage()    {}
func (*LuaGuadraticBoss) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{22}
}
func (m *LuaGuadraticBoss) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaGuadraticBoss) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaGuadraticBoss.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaGuadraticBoss) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaGuadraticBoss.Merge(m, src)
}
func (m *LuaGuadraticBoss) XXX_Size() int {
	return m.Size()
}
func (m *LuaGuadraticBoss) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaGuadraticBoss.DiscardUnknown(m)
}

var xxx_messageInfo_LuaGuadraticBoss proto.InternalMessageInfo

func (m *LuaGuadraticBoss) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaGuadraticBoss) GetEnterType() int32 {
	if m != nil && m.EnterType != nil {
		return *m.EnterType
	}
	return 0
}

func (m *LuaGuadraticBoss) GetExitType() int32 {
	if m != nil && m.ExitType != nil {
		return *m.ExitType
	}
	return 0
}

func (m *LuaGuadraticBoss) GetMoveSpeed() int32 {
	if m != nil && m.MoveSpeed != nil {
		return *m.MoveSpeed
	}
	return 0
}

func (m *LuaGuadraticBoss) GetEnterTime() int32 {
	if m != nil && m.EnterTime != nil {
		return *m.EnterTime
	}
	return 0
}

func (m *LuaGuadraticBoss) GetEnterHurt() int32 {
	if m != nil && m.EnterHurt != nil {
		return *m.EnterHurt
	}
	return 0
}

func (m *LuaGuadraticBoss) GetEnterHurtSize() *LuaSize {
	if m != nil {
		return m.EnterHurtSize
	}
	return nil
}

func (m *LuaGuadraticBoss) GetRes() []byte {
	if m != nil {
		return m.Res
	}
	return nil
}

func (m *LuaGuadraticBoss) GetEnterSound() []byte {
	if m != nil {
		return m.EnterSound
	}
	return nil
}

func (m *LuaGuadraticBoss) GetSkillList() []int32 {
	if m != nil {
		return m.SkillList
	}
	return nil
}

// Excel:vip表.xls sheet:充值表
type LuaVipSale struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	Price                *int32   `protobuf:"zigzag32,2,opt,name=price" json:"price,omitempty"`
	BaseDiamond          *int32   `protobuf:"zigzag32,3,opt,name=baseDiamond" json:"baseDiamond,omitempty"`
	ExtraDiamond         *int32   `protobuf:"zigzag32,4,opt,name=extraDiamond" json:"extraDiamond,omitempty"`
	FirstFlag            *int32   `protobuf:"zigzag32,5,opt,name=firstFlag" json:"firstFlag,omitempty"`
	FirstExtraDiamond    *int32   `protobuf:"zigzag32,6,opt,name=firstExtraDiamond" json:"firstExtraDiamond,omitempty"`
	IapID                []byte   `protobuf:"bytes,7,opt,name=iapID" json:"iapID,omitempty"`
	IapSuffix            []byte   `protobuf:"bytes,8,opt,name=iapSuffix" json:"iapSuffix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaVipSale) Reset()         { *m = LuaVipSale{} }
func (m *LuaVipSale) String() string { return proto.CompactTextString(m) }
func (*LuaVipSale) ProtoMessage()    {}
func (*LuaVipSale) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{23}
}
func (m *LuaVipSale) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaVipSale) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaVipSale.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaVipSale) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaVipSale.Merge(m, src)
}
func (m *LuaVipSale) XXX_Size() int {
	return m.Size()
}
func (m *LuaVipSale) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaVipSale.DiscardUnknown(m)
}

var xxx_messageInfo_LuaVipSale proto.InternalMessageInfo

func (m *LuaVipSale) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaVipSale) GetPrice() int32 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

func (m *LuaVipSale) GetBaseDiamond() int32 {
	if m != nil && m.BaseDiamond != nil {
		return *m.BaseDiamond
	}
	return 0
}

func (m *LuaVipSale) GetExtraDiamond() int32 {
	if m != nil && m.ExtraDiamond != nil {
		return *m.ExtraDiamond
	}
	return 0
}

func (m *LuaVipSale) GetFirstFlag() int32 {
	if m != nil && m.FirstFlag != nil {
		return *m.FirstFlag
	}
	return 0
}

func (m *LuaVipSale) GetFirstExtraDiamond() int32 {
	if m != nil && m.FirstExtraDiamond != nil {
		return *m.FirstExtraDiamond
	}
	return 0
}

func (m *LuaVipSale) GetIapID() []byte {
	if m != nil {
		return m.IapID
	}
	return nil
}

func (m *LuaVipSale) GetIapSuffix() []byte {
	if m != nil {
		return m.IapSuffix
	}
	return nil
}

// Excel:j技能表.xls sheet:嘴炮技能
type LuaZuipao struct {
	Level                *int32   `protobuf:"zigzag32,1,opt,name=level" json:"level,omitempty"`
	SkillID              *int32   `protobuf:"zigzag32,2,opt,name=skillID" json:"skillID,omitempty"`
	FaceCount            *int32   `protobuf:"zigzag32,3,opt,name=faceCount" json:"faceCount,omitempty"`
	NeedLevel            *int32   `protobuf:"zigzag32,4,opt,name=needLevel" json:"needLevel,omitempty"`
	AddEnergyPercent     *float32 `protobuf:"fixed32,5,opt,name=addEnergyPercent" json:"addEnergyPercent,omitempty"`
	SkillLevelList       []int32  `protobuf:"varint,6,rep,name=skillLevelList" json:"skillLevelList,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaZuipao) Reset()         { *m = LuaZuipao{} }
func (m *LuaZuipao) String() string { return proto.CompactTextString(m) }
func (*LuaZuipao) ProtoMessage()    {}
func (*LuaZuipao) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{24}
}
func (m *LuaZuipao) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaZuipao) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaZuipao.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaZuipao) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaZuipao.Merge(m, src)
}
func (m *LuaZuipao) XXX_Size() int {
	return m.Size()
}
func (m *LuaZuipao) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaZuipao.DiscardUnknown(m)
}

var xxx_messageInfo_LuaZuipao proto.InternalMessageInfo

func (m *LuaZuipao) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaZuipao) GetSkillID() int32 {
	if m != nil && m.SkillID != nil {
		return *m.SkillID
	}
	return 0
}

func (m *LuaZuipao) GetFaceCount() int32 {
	if m != nil && m.FaceCount != nil {
		return *m.FaceCount
	}
	return 0
}

func (m *LuaZuipao) GetNeedLevel() int32 {
	if m != nil && m.NeedLevel != nil {
		return *m.NeedLevel
	}
	return 0
}

func (m *LuaZuipao) GetAddEnergyPercent() float32 {
	if m != nil && m.AddEnergyPercent != nil {
		return *m.AddEnergyPercent
	}
	return 0
}

func (m *LuaZuipao) GetSkillLevelList() []int32 {
	if m != nil {
		return m.SkillLevelList
	}
	return nil
}

// Excel:道具商店表.xls sheet:汽车商店等级随机表
type LuaParkShopRandom struct {
	Level                *int32                   `protobuf:"zigzag32,1,opt,name=level" json:"level,omitempty"`
	ItemIdList           []*ShopRandomSectionList `protobuf:"bytes,2,rep,name=itemIdList" json:"itemIdList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *LuaParkShopRandom) Reset()         { *m = LuaParkShopRandom{} }
func (m *LuaParkShopRandom) String() string { return proto.CompactTextString(m) }
func (*LuaParkShopRandom) ProtoMessage()    {}
func (*LuaParkShopRandom) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{25}
}
func (m *LuaParkShopRandom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaParkShopRandom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaParkShopRandom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaParkShopRandom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaParkShopRandom.Merge(m, src)
}
func (m *LuaParkShopRandom) XXX_Size() int {
	return m.Size()
}
func (m *LuaParkShopRandom) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaParkShopRandom.DiscardUnknown(m)
}

var xxx_messageInfo_LuaParkShopRandom proto.InternalMessageInfo

func (m *LuaParkShopRandom) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaParkShopRandom) GetItemIdList() []*ShopRandomSectionList {
	if m != nil {
		return m.ItemIdList
	}
	return nil
}

// Excel:n扭蛋机.xls sheet:扭蛋机表
type LuaNiudan struct {
	Id                   *int32              `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	PreviewReward        []int32             `protobuf:"zigzag32,2,rep,name=previewReward" json:"previewReward,omitempty"`
	Showspeed            *int32              `protobuf:"zigzag32,3,opt,name=showspeed" json:"showspeed,omitempty"`
	Markshow             *int32              `protobuf:"zigzag32,4,opt,name=markshow" json:"markshow,omitempty"`
	ButtonList           []*NiudanButtonInfo `protobuf:"bytes,5,rep,name=button_list" json:"button_list,omitempty"`
	TextQuality          []int32             `protobuf:"zigzag32,6,rep,name=text_quality" json:"text_quality,omitempty"`
	TextProb             []int32             `protobuf:"zigzag32,7,rep,name=text_prob" json:"text_prob,omitempty"`
	TextDesID            []byte              `protobuf:"bytes,8,opt,name=text_desID" json:"text_desID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *LuaNiudan) Reset()         { *m = LuaNiudan{} }
func (m *LuaNiudan) String() string { return proto.CompactTextString(m) }
func (*LuaNiudan) ProtoMessage()    {}
func (*LuaNiudan) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{26}
}
func (m *LuaNiudan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaNiudan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaNiudan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaNiudan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaNiudan.Merge(m, src)
}
func (m *LuaNiudan) XXX_Size() int {
	return m.Size()
}
func (m *LuaNiudan) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaNiudan.DiscardUnknown(m)
}

var xxx_messageInfo_LuaNiudan proto.InternalMessageInfo

func (m *LuaNiudan) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaNiudan) GetPreviewReward() []int32 {
	if m != nil {
		return m.PreviewReward
	}
	return nil
}

func (m *LuaNiudan) GetShowspeed() int32 {
	if m != nil && m.Showspeed != nil {
		return *m.Showspeed
	}
	return 0
}

func (m *LuaNiudan) GetMarkshow() int32 {
	if m != nil && m.Markshow != nil {
		return *m.Markshow
	}
	return 0
}

func (m *LuaNiudan) GetButtonList() []*NiudanButtonInfo {
	if m != nil {
		return m.ButtonList
	}
	return nil
}

func (m *LuaNiudan) GetTextQuality() []int32 {
	if m != nil {
		return m.TextQuality
	}
	return nil
}

func (m *LuaNiudan) GetTextProb() []int32 {
	if m != nil {
		return m.TextProb
	}
	return nil
}

func (m *LuaNiudan) GetTextDesID() []byte {
	if m != nil {
		return m.TextDesID
	}
	return nil
}

// Excel:pet宠物.xls sheet:宠物属性
type LuaPet struct {
	Id                   *int32        `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte        `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	DesID                []byte        `protobuf:"bytes,3,opt,name=desID" json:"desID,omitempty"`
	PaintID              *int32        `protobuf:"zigzag32,4,opt,name=paintID" json:"paintID,omitempty"`
	IconID               *int32        `protobuf:"zigzag32,5,opt,name=iconID" json:"iconID,omitempty"`
	SkillIcon            *int32        `protobuf:"zigzag32,6,opt,name=skillIcon" json:"skillIcon,omitempty"`
	EvolveLevel          *int32        `protobuf:"zigzag32,7,opt,name=evolveLevel" json:"evolveLevel,omitempty"`
	EvolvePetId          *int32        `protobuf:"zigzag32,8,opt,name=evolvePetId" json:"evolvePetId,omitempty"`
	EvolveCostList       []*ItemConfig `protobuf:"bytes,9,rep,name=evolveCostList" json:"evolveCostList,omitempty"`
	Res                  []byte        `protobuf:"bytes,10,opt,name=res" json:"res,omitempty"`
	ActNormalList        []int32       `protobuf:"zigzag32,11,rep,name=actNormalList" json:"actNormalList,omitempty"`
	ActSkillList         []int32       `protobuf:"zigzag32,12,rep,name=actSkillList" json:"actSkillList,omitempty"`
	ActSkillProbList     []int32       `protobuf:"zigzag32,13,rep,name=actSkillProbList" json:"actSkillProbList,omitempty"`
	DiedSound            []byte        `protobuf:"bytes,14,opt,name=diedSound" json:"diedSound,omitempty"`
	HurtPauseFrame       *int32        `protobuf:"zigzag32,15,opt,name=hurtPauseFrame" json:"hurtPauseFrame,omitempty"`
	BoundingBox          *LuaRect      `protobuf:"bytes,16,opt,name=boundingBox" json:"boundingBox,omitempty"`
	HitPos               *LuaPos       `protobuf:"bytes,17,opt,name=hitPos" json:"hitPos,omitempty"`
	TopPos               *LuaPos       `protobuf:"bytes,18,opt,name=topPos" json:"topPos,omitempty"`
	MaxLevel             *int32        `protobuf:"zigzag32,19,opt,name=maxLevel" json:"maxLevel,omitempty"`
	Weight               *int32        `protobuf:"zigzag32,20,opt,name=weight" json:"weight,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaPet) Reset()         { *m = LuaPet{} }
func (m *LuaPet) String() string { return proto.CompactTextString(m) }
func (*LuaPet) ProtoMessage()    {}
func (*LuaPet) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{27}
}
func (m *LuaPet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaPet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaPet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaPet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaPet.Merge(m, src)
}
func (m *LuaPet) XXX_Size() int {
	return m.Size()
}
func (m *LuaPet) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaPet.DiscardUnknown(m)
}

var xxx_messageInfo_LuaPet proto.InternalMessageInfo

func (m *LuaPet) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaPet) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaPet) GetDesID() []byte {
	if m != nil {
		return m.DesID
	}
	return nil
}

func (m *LuaPet) GetPaintID() int32 {
	if m != nil && m.PaintID != nil {
		return *m.PaintID
	}
	return 0
}

func (m *LuaPet) GetIconID() int32 {
	if m != nil && m.IconID != nil {
		return *m.IconID
	}
	return 0
}

func (m *LuaPet) GetSkillIcon() int32 {
	if m != nil && m.SkillIcon != nil {
		return *m.SkillIcon
	}
	return 0
}

func (m *LuaPet) GetEvolveLevel() int32 {
	if m != nil && m.EvolveLevel != nil {
		return *m.EvolveLevel
	}
	return 0
}

func (m *LuaPet) GetEvolvePetId() int32 {
	if m != nil && m.EvolvePetId != nil {
		return *m.EvolvePetId
	}
	return 0
}

func (m *LuaPet) GetEvolveCostList() []*ItemConfig {
	if m != nil {
		return m.EvolveCostList
	}
	return nil
}

func (m *LuaPet) GetRes() []byte {
	if m != nil {
		return m.Res
	}
	return nil
}

func (m *LuaPet) GetActNormalList() []int32 {
	if m != nil {
		return m.ActNormalList
	}
	return nil
}

func (m *LuaPet) GetActSkillList() []int32 {
	if m != nil {
		return m.ActSkillList
	}
	return nil
}

func (m *LuaPet) GetActSkillProbList() []int32 {
	if m != nil {
		return m.ActSkillProbList
	}
	return nil
}

func (m *LuaPet) GetDiedSound() []byte {
	if m != nil {
		return m.DiedSound
	}
	return nil
}

func (m *LuaPet) GetHurtPauseFrame() int32 {
	if m != nil && m.HurtPauseFrame != nil {
		return *m.HurtPauseFrame
	}
	return 0
}

func (m *LuaPet) GetBoundingBox() *LuaRect {
	if m != nil {
		return m.BoundingBox
	}
	return nil
}

func (m *LuaPet) GetHitPos() *LuaPos {
	if m != nil {
		return m.HitPos
	}
	return nil
}

func (m *LuaPet) GetTopPos() *LuaPos {
	if m != nil {
		return m.TopPos
	}
	return nil
}

func (m *LuaPet) GetMaxLevel() int32 {
	if m != nil && m.MaxLevel != nil {
		return *m.MaxLevel
	}
	return 0
}

func (m *LuaPet) GetWeight() int32 {
	if m != nil && m.Weight != nil {
		return *m.Weight
	}
	return 0
}

// Excel:q抢车位.xls sheet:停车场分线表
type LuaParkPlace struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	SceneID              *int32   `protobuf:"zigzag32,2,opt,name=sceneID" json:"sceneID,omitempty"`
	NameID               []byte   `protobuf:"bytes,3,opt,name=nameID" json:"nameID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaParkPlace) Reset()         { *m = LuaParkPlace{} }
func (m *LuaParkPlace) String() string { return proto.CompactTextString(m) }
func (*LuaParkPlace) ProtoMessage()    {}
func (*LuaParkPlace) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{28}
}
func (m *LuaParkPlace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaParkPlace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaParkPlace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaParkPlace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaParkPlace.Merge(m, src)
}
func (m *LuaParkPlace) XXX_Size() int {
	return m.Size()
}
func (m *LuaParkPlace) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaParkPlace.DiscardUnknown(m)
}

var xxx_messageInfo_LuaParkPlace proto.InternalMessageInfo

func (m *LuaParkPlace) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaParkPlace) GetSceneID() int32 {
	if m != nil && m.SceneID != nil {
		return *m.SceneID
	}
	return 0
}

func (m *LuaParkPlace) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

// Excel:出生数据.xls sheet:角色创建表
type LuaRoleCreate struct {
	Id                   *int32        `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	HatList              []*ItemConfig `protobuf:"bytes,2,rep,name=hatList" json:"hatList,omitempty"`
	FaceList             []*FaceConfig `protobuf:"bytes,3,rep,name=faceList" json:"faceList,omitempty"`
	WeaponList           []*ItemConfig `protobuf:"bytes,4,rep,name=weaponList" json:"weaponList,omitempty"`
	WingList             []*ItemConfig `protobuf:"bytes,5,rep,name=wingList" json:"wingList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaRoleCreate) Reset()         { *m = LuaRoleCreate{} }
func (m *LuaRoleCreate) String() string { return proto.CompactTextString(m) }
func (*LuaRoleCreate) ProtoMessage()    {}
func (*LuaRoleCreate) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{29}
}
func (m *LuaRoleCreate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaRoleCreate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaRoleCreate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaRoleCreate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaRoleCreate.Merge(m, src)
}
func (m *LuaRoleCreate) XXX_Size() int {
	return m.Size()
}
func (m *LuaRoleCreate) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaRoleCreate.DiscardUnknown(m)
}

var xxx_messageInfo_LuaRoleCreate proto.InternalMessageInfo

func (m *LuaRoleCreate) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaRoleCreate) GetHatList() []*ItemConfig {
	if m != nil {
		return m.HatList
	}
	return nil
}

func (m *LuaRoleCreate) GetFaceList() []*FaceConfig {
	if m != nil {
		return m.FaceList
	}
	return nil
}

func (m *LuaRoleCreate) GetWeaponList() []*ItemConfig {
	if m != nil {
		return m.WeaponList
	}
	return nil
}

func (m *LuaRoleCreate) GetWingList() []*ItemConfig {
	if m != nil {
		return m.WingList
	}
	return nil
}

// Excel:道具商店表.xls sheet:扭蛋机商店等级随机表
type LuaNiudanShopRandom struct {
	Level                *int32                   `protobuf:"zigzag32,1,opt,name=level" json:"level,omitempty"`
	ItemIdList           []*ShopRandomSectionList `protobuf:"bytes,2,rep,name=itemIdList" json:"itemIdList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *LuaNiudanShopRandom) Reset()         { *m = LuaNiudanShopRandom{} }
func (m *LuaNiudanShopRandom) String() string { return proto.CompactTextString(m) }
func (*LuaNiudanShopRandom) ProtoMessage()    {}
func (*LuaNiudanShopRandom) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{30}
}
func (m *LuaNiudanShopRandom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaNiudanShopRandom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaNiudanShopRandom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaNiudanShopRandom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaNiudanShopRandom.Merge(m, src)
}
func (m *LuaNiudanShopRandom) XXX_Size() int {
	return m.Size()
}
func (m *LuaNiudanShopRandom) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaNiudanShopRandom.DiscardUnknown(m)
}

var xxx_messageInfo_LuaNiudanShopRandom proto.InternalMessageInfo

func (m *LuaNiudanShopRandom) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaNiudanShopRandom) GetItemIdList() []*ShopRandomSectionList {
	if m != nil {
		return m.ItemIdList
	}
	return nil
}

// Excel:道具商店表.xls sheet:技能书商店等级随机表
type LuaSkillShopRandom struct {
	Level                *int32                   `protobuf:"zigzag32,1,opt,name=level" json:"level,omitempty"`
	ItemIdList           []*ShopRandomSectionList `protobuf:"bytes,2,rep,name=itemIdList" json:"itemIdList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *LuaSkillShopRandom) Reset()         { *m = LuaSkillShopRandom{} }
func (m *LuaSkillShopRandom) String() string { return proto.CompactTextString(m) }
func (*LuaSkillShopRandom) ProtoMessage()    {}
func (*LuaSkillShopRandom) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{31}
}
func (m *LuaSkillShopRandom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaSkillShopRandom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaSkillShopRandom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaSkillShopRandom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaSkillShopRandom.Merge(m, src)
}
func (m *LuaSkillShopRandom) XXX_Size() int {
	return m.Size()
}
func (m *LuaSkillShopRandom) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaSkillShopRandom.DiscardUnknown(m)
}

var xxx_messageInfo_LuaSkillShopRandom proto.InternalMessageInfo

func (m *LuaSkillShopRandom) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaSkillShopRandom) GetItemIdList() []*ShopRandomSectionList {
	if m != nil {
		return m.ItemIdList
	}
	return nil
}

// Excel:奖励表.xls sheet:奖励表
type LuaReward struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	ItemID               *int32   `protobuf:"zigzag32,2,opt,name=itemID" json:"itemID,omitempty"`
	Count                *int32   `protobuf:"zigzag32,3,opt,name=count" json:"count,omitempty"`
	MiniRate             *int32   `protobuf:"zigzag32,4,opt,name=miniRate" json:"miniRate,omitempty"`
	MaxRate              *int32   `protobuf:"zigzag32,5,opt,name=maxRate" json:"maxRate,omitempty"`
	IsResetTime          *int32   `protobuf:"zigzag32,6,opt,name=isResetTime" json:"isResetTime,omitempty"`
	GetTime              *int32   `protobuf:"zigzag32,7,opt,name=getTime" json:"getTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaReward) Reset()         { *m = LuaReward{} }
func (m *LuaReward) String() string { return proto.CompactTextString(m) }
func (*LuaReward) ProtoMessage()    {}
func (*LuaReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{32}
}
func (m *LuaReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaReward.Merge(m, src)
}
func (m *LuaReward) XXX_Size() int {
	return m.Size()
}
func (m *LuaReward) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaReward.DiscardUnknown(m)
}

var xxx_messageInfo_LuaReward proto.InternalMessageInfo

func (m *LuaReward) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaReward) GetItemID() int32 {
	if m != nil && m.ItemID != nil {
		return *m.ItemID
	}
	return 0
}

func (m *LuaReward) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *LuaReward) GetMiniRate() int32 {
	if m != nil && m.MiniRate != nil {
		return *m.MiniRate
	}
	return 0
}

func (m *LuaReward) GetMaxRate() int32 {
	if m != nil && m.MaxRate != nil {
		return *m.MaxRate
	}
	return 0
}

func (m *LuaReward) GetIsResetTime() int32 {
	if m != nil && m.IsResetTime != nil {
		return *m.IsResetTime
	}
	return 0
}

func (m *LuaReward) GetGetTime() int32 {
	if m != nil && m.GetTime != nil {
		return *m.GetTime
	}
	return 0
}

// Excel:pet宠物.xls sheet:宠物技能升级表
type LuaPetTalentLevel struct {
	Level                *int32   `protobuf:"zigzag32,1,opt,name=level" json:"level,omitempty"`
	ActLevelList         []int32  `protobuf:"zigzag32,2,rep,name=actLevelList" json:"actLevelList,omitempty"`
	PassiveLevelList     []int32  `protobuf:"zigzag32,3,rep,name=passiveLevelList" json:"passiveLevelList,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaPetTalentLevel) Reset()         { *m = LuaPetTalentLevel{} }
func (m *LuaPetTalentLevel) String() string { return proto.CompactTextString(m) }
func (*LuaPetTalentLevel) ProtoMessage()    {}
func (*LuaPetTalentLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{33}
}
func (m *LuaPetTalentLevel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaPetTalentLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaPetTalentLevel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaPetTalentLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaPetTalentLevel.Merge(m, src)
}
func (m *LuaPetTalentLevel) XXX_Size() int {
	return m.Size()
}
func (m *LuaPetTalentLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaPetTalentLevel.DiscardUnknown(m)
}

var xxx_messageInfo_LuaPetTalentLevel proto.InternalMessageInfo

func (m *LuaPetTalentLevel) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaPetTalentLevel) GetActLevelList() []int32 {
	if m != nil {
		return m.ActLevelList
	}
	return nil
}

func (m *LuaPetTalentLevel) GetPassiveLevelList() []int32 {
	if m != nil {
		return m.PassiveLevelList
	}
	return nil
}

// Excel:z走马灯表.xls sheet:走马灯
type LuaNotable struct {
	Type                 *int32   `protobuf:"zigzag32,1,opt,name=type" json:"type,omitempty"`
	ParameterList        []int32  `protobuf:"zigzag32,2,rep,name=parameter_list" json:"parameter_list,omitempty"`
	DesID                []byte   `protobuf:"bytes,3,opt,name=desID" json:"desID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaNotable) Reset()         { *m = LuaNotable{} }
func (m *LuaNotable) String() string { return proto.CompactTextString(m) }
func (*LuaNotable) ProtoMessage()    {}
func (*LuaNotable) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{34}
}
func (m *LuaNotable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaNotable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaNotable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaNotable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaNotable.Merge(m, src)
}
func (m *LuaNotable) XXX_Size() int {
	return m.Size()
}
func (m *LuaNotable) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaNotable.DiscardUnknown(m)
}

var xxx_messageInfo_LuaNotable proto.InternalMessageInfo

func (m *LuaNotable) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaNotable) GetParameterList() []int32 {
	if m != nil {
		return m.ParameterList
	}
	return nil
}

func (m *LuaNotable) GetDesID() []byte {
	if m != nil {
		return m.DesID
	}
	return nil
}

// Excel:avatar表情.xls sheet:face
type LuaFace struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte   `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	DesID                []byte   `protobuf:"bytes,3,opt,name=desID" json:"desID,omitempty"`
	ResID                *int32   `protobuf:"zigzag32,4,opt,name=resID" json:"resID,omitempty"`
	Atk                  *int32   `protobuf:"zigzag32,5,opt,name=atk" json:"atk,omitempty"`
	Hp                   *int32   `protobuf:"zigzag32,6,opt,name=hp" json:"hp,omitempty"`
	Def                  *int32   `protobuf:"zigzag32,7,opt,name=def" json:"def,omitempty"`
	Crit                 *int32   `protobuf:"zigzag32,8,opt,name=crit" json:"crit,omitempty"`
	Block                *int32   `protobuf:"zigzag32,9,opt,name=block" json:"block,omitempty"`
	Speed                *int32   `protobuf:"zigzag32,10,opt,name=speed" json:"speed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaFace) Reset()         { *m = LuaFace{} }
func (m *LuaFace) String() string { return proto.CompactTextString(m) }
func (*LuaFace) ProtoMessage()    {}
func (*LuaFace) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{35}
}
func (m *LuaFace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaFace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaFace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaFace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaFace.Merge(m, src)
}
func (m *LuaFace) XXX_Size() int {
	return m.Size()
}
func (m *LuaFace) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaFace.DiscardUnknown(m)
}

var xxx_messageInfo_LuaFace proto.InternalMessageInfo

func (m *LuaFace) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaFace) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaFace) GetDesID() []byte {
	if m != nil {
		return m.DesID
	}
	return nil
}

func (m *LuaFace) GetResID() int32 {
	if m != nil && m.ResID != nil {
		return *m.ResID
	}
	return 0
}

func (m *LuaFace) GetAtk() int32 {
	if m != nil && m.Atk != nil {
		return *m.Atk
	}
	return 0
}

func (m *LuaFace) GetHp() int32 {
	if m != nil && m.Hp != nil {
		return *m.Hp
	}
	return 0
}

func (m *LuaFace) GetDef() int32 {
	if m != nil && m.Def != nil {
		return *m.Def
	}
	return 0
}

func (m *LuaFace) GetCrit() int32 {
	if m != nil && m.Crit != nil {
		return *m.Crit
	}
	return 0
}

func (m *LuaFace) GetBlock() int32 {
	if m != nil && m.Block != nil {
		return *m.Block
	}
	return 0
}

func (m *LuaFace) GetSpeed() int32 {
	if m != nil && m.Speed != nil {
		return *m.Speed
	}
	return 0
}

// Excel:日常任务表.xls sheet:日常任务
type LuaDailyTask struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	SubTaskList          []int32  `protobuf:"zigzag32,2,rep,name=subTaskList" json:"subTaskList,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaDailyTask) Reset()         { *m = LuaDailyTask{} }
func (m *LuaDailyTask) String() string { return proto.CompactTextString(m) }
func (*LuaDailyTask) ProtoMessage()    {}
func (*LuaDailyTask) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{36}
}
func (m *LuaDailyTask) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaDailyTask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaDailyTask.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaDailyTask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaDailyTask.Merge(m, src)
}
func (m *LuaDailyTask) XXX_Size() int {
	return m.Size()
}
func (m *LuaDailyTask) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaDailyTask.DiscardUnknown(m)
}

var xxx_messageInfo_LuaDailyTask proto.InternalMessageInfo

func (m *LuaDailyTask) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaDailyTask) GetSubTaskList() []int32 {
	if m != nil {
		return m.SubTaskList
	}
	return nil
}

// Excel:竞技场表.xls sheet:木桩敌人表
type LuaArenaNpc struct {
	Rank                 *int32   `protobuf:"zigzag32,1,opt,name=rank" json:"rank,omitempty"`
	Name                 []byte   `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Temp                 *int32   `protobuf:"zigzag32,3,opt,name=temp" json:"temp,omitempty"`
	Pos                  *int32   `protobuf:"zigzag32,4,opt,name=pos" json:"pos,omitempty"`
	Level                *int32   `protobuf:"zigzag32,5,opt,name=level" json:"level,omitempty"`
	Dif                  *int32   `protobuf:"zigzag32,6,opt,name=dif" json:"dif,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaArenaNpc) Reset()         { *m = LuaArenaNpc{} }
func (m *LuaArenaNpc) String() string { return proto.CompactTextString(m) }
func (*LuaArenaNpc) ProtoMessage()    {}
func (*LuaArenaNpc) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{37}
}
func (m *LuaArenaNpc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaArenaNpc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaArenaNpc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaArenaNpc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaArenaNpc.Merge(m, src)
}
func (m *LuaArenaNpc) XXX_Size() int {
	return m.Size()
}
func (m *LuaArenaNpc) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaArenaNpc.DiscardUnknown(m)
}

var xxx_messageInfo_LuaArenaNpc proto.InternalMessageInfo

func (m *LuaArenaNpc) GetRank() int32 {
	if m != nil && m.Rank != nil {
		return *m.Rank
	}
	return 0
}

func (m *LuaArenaNpc) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *LuaArenaNpc) GetTemp() int32 {
	if m != nil && m.Temp != nil {
		return *m.Temp
	}
	return 0
}

func (m *LuaArenaNpc) GetPos() int32 {
	if m != nil && m.Pos != nil {
		return *m.Pos
	}
	return 0
}

func (m *LuaArenaNpc) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaArenaNpc) GetDif() int32 {
	if m != nil && m.Dif != nil {
		return *m.Dif
	}
	return 0
}

// Excel:卡牌表.xls sheet:卡牌技能表
type LuaCard struct {
	Id                   *int32    `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte    `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	DescID               []byte    `protobuf:"bytes,3,opt,name=descID" json:"descID,omitempty"`
	Type                 *int32    `protobuf:"zigzag32,4,opt,name=type" json:"type,omitempty"`
	Quality              *int32    `protobuf:"zigzag32,5,opt,name=quality" json:"quality,omitempty"`
	NeedEnergy           *int32    `protobuf:"zigzag32,6,opt,name=needEnergy" json:"needEnergy,omitempty"`
	Icon                 []byte    `protobuf:"bytes,7,opt,name=icon" json:"icon,omitempty"`
	GroupIcon            []byte    `protobuf:"bytes,8,opt,name=groupIcon" json:"groupIcon,omitempty"`
	TargetType           *int32    `protobuf:"zigzag32,9,opt,name=targetType" json:"targetType,omitempty"`
	TargetCount          *int32    `protobuf:"zigzag32,10,opt,name=targetCount" json:"targetCount,omitempty"`
	ReleaseEffID         *int32    `protobuf:"zigzag32,11,opt,name=releaseEffID" json:"releaseEffID,omitempty"`
	ReleasePos           *int32    `protobuf:"zigzag32,12,opt,name=releasePos" json:"releasePos,omitempty"`
	AtkTimeList          []float32 `protobuf:"fixed32,13,rep,name=atkTimeList" json:"atkTimeList,omitempty"`
	AtkHurtPerList       []int32   `protobuf:"zigzag32,14,rep,name=atkHurtPerList" json:"atkHurtPerList,omitempty"`
	AtkEndTime           *float32  `protobuf:"fixed32,15,opt,name=atkEndTime" json:"atkEndTime,omitempty"`
	HurtEffList          []int32   `protobuf:"zigzag32,16,rep,name=hurtEffList" json:"hurtEffList,omitempty"`
	PerValue             *int32    `protobuf:"zigzag32,17,opt,name=perValue" json:"perValue,omitempty"`
	FixValue             *int32    `protobuf:"zigzag32,18,opt,name=fixValue" json:"fixValue,omitempty"`
	BuffTargetList       []int32   `protobuf:"zigzag32,19,rep,name=buffTargetList" json:"buffTargetList,omitempty"`
	BuffList             []int32   `protobuf:"zigzag32,20,rep,name=buffList" json:"buffList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *LuaCard) Reset()         { *m = LuaCard{} }
func (m *LuaCard) String() string { return proto.CompactTextString(m) }
func (*LuaCard) ProtoMessage()    {}
func (*LuaCard) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{38}
}
func (m *LuaCard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaCard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaCard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaCard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaCard.Merge(m, src)
}
func (m *LuaCard) XXX_Size() int {
	return m.Size()
}
func (m *LuaCard) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaCard.DiscardUnknown(m)
}

var xxx_messageInfo_LuaCard proto.InternalMessageInfo

func (m *LuaCard) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaCard) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaCard) GetDescID() []byte {
	if m != nil {
		return m.DescID
	}
	return nil
}

func (m *LuaCard) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaCard) GetQuality() int32 {
	if m != nil && m.Quality != nil {
		return *m.Quality
	}
	return 0
}

func (m *LuaCard) GetNeedEnergy() int32 {
	if m != nil && m.NeedEnergy != nil {
		return *m.NeedEnergy
	}
	return 0
}

func (m *LuaCard) GetIcon() []byte {
	if m != nil {
		return m.Icon
	}
	return nil
}

func (m *LuaCard) GetGroupIcon() []byte {
	if m != nil {
		return m.GroupIcon
	}
	return nil
}

func (m *LuaCard) GetTargetType() int32 {
	if m != nil && m.TargetType != nil {
		return *m.TargetType
	}
	return 0
}

func (m *LuaCard) GetTargetCount() int32 {
	if m != nil && m.TargetCount != nil {
		return *m.TargetCount
	}
	return 0
}

func (m *LuaCard) GetReleaseEffID() int32 {
	if m != nil && m.ReleaseEffID != nil {
		return *m.ReleaseEffID
	}
	return 0
}

func (m *LuaCard) GetReleasePos() int32 {
	if m != nil && m.ReleasePos != nil {
		return *m.ReleasePos
	}
	return 0
}

func (m *LuaCard) GetAtkTimeList() []float32 {
	if m != nil {
		return m.AtkTimeList
	}
	return nil
}

func (m *LuaCard) GetAtkHurtPerList() []int32 {
	if m != nil {
		return m.AtkHurtPerList
	}
	return nil
}

func (m *LuaCard) GetAtkEndTime() float32 {
	if m != nil && m.AtkEndTime != nil {
		return *m.AtkEndTime
	}
	return 0
}

func (m *LuaCard) GetHurtEffList() []int32 {
	if m != nil {
		return m.HurtEffList
	}
	return nil
}

func (m *LuaCard) GetPerValue() int32 {
	if m != nil && m.PerValue != nil {
		return *m.PerValue
	}
	return 0
}

func (m *LuaCard) GetFixValue() int32 {
	if m != nil && m.FixValue != nil {
		return *m.FixValue
	}
	return 0
}

func (m *LuaCard) GetBuffTargetList() []int32 {
	if m != nil {
		return m.BuffTargetList
	}
	return nil
}

func (m *LuaCard) GetBuffList() []int32 {
	if m != nil {
		return m.BuffList
	}
	return nil
}

// Excel:g挂机经验表.xls sheet:挂机经验计算
type LuaHangup struct {
	Level                *int32   `protobuf:"zigzag32,1,opt,name=level" json:"level,omitempty"`
	TimeUplimit          *int32   `protobuf:"zigzag32,2,opt,name=timeUplimit" json:"timeUplimit,omitempty"`
	UnitTime             *int32   `protobuf:"zigzag32,3,opt,name=unitTime" json:"unitTime,omitempty"`
	UnitExp              *int32   `protobuf:"zigzag32,4,opt,name=unitExp" json:"unitExp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaHangup) Reset()         { *m = LuaHangup{} }
func (m *LuaHangup) String() string { return proto.CompactTextString(m) }
func (*LuaHangup) ProtoMessage()    {}
func (*LuaHangup) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{39}
}
func (m *LuaHangup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaHangup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaHangup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaHangup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaHangup.Merge(m, src)
}
func (m *LuaHangup) XXX_Size() int {
	return m.Size()
}
func (m *LuaHangup) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaHangup.DiscardUnknown(m)
}

var xxx_messageInfo_LuaHangup proto.InternalMessageInfo

func (m *LuaHangup) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaHangup) GetTimeUplimit() int32 {
	if m != nil && m.TimeUplimit != nil {
		return *m.TimeUplimit
	}
	return 0
}

func (m *LuaHangup) GetUnitTime() int32 {
	if m != nil && m.UnitTime != nil {
		return *m.UnitTime
	}
	return 0
}

func (m *LuaHangup) GetUnitExp() int32 {
	if m != nil && m.UnitExp != nil {
		return *m.UnitExp
	}
	return 0
}

// Excel:道具商店表.xls sheet:棒棒糖商店等级随机表
type LuaDiamondShopRandom struct {
	Level                *int32                   `protobuf:"zigzag32,1,opt,name=level" json:"level,omitempty"`
	ItemIdList           []*ShopRandomSectionList `protobuf:"bytes,2,rep,name=itemIdList" json:"itemIdList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *LuaDiamondShopRandom) Reset()         { *m = LuaDiamondShopRandom{} }
func (m *LuaDiamondShopRandom) String() string { return proto.CompactTextString(m) }
func (*LuaDiamondShopRandom) ProtoMessage()    {}
func (*LuaDiamondShopRandom) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{40}
}
func (m *LuaDiamondShopRandom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaDiamondShopRandom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaDiamondShopRandom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaDiamondShopRandom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaDiamondShopRandom.Merge(m, src)
}
func (m *LuaDiamondShopRandom) XXX_Size() int {
	return m.Size()
}
func (m *LuaDiamondShopRandom) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaDiamondShopRandom.DiscardUnknown(m)
}

var xxx_messageInfo_LuaDiamondShopRandom proto.InternalMessageInfo

func (m *LuaDiamondShopRandom) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaDiamondShopRandom) GetItemIdList() []*ShopRandomSectionList {
	if m != nil {
		return m.ItemIdList
	}
	return nil
}

// Excel:道具商店表.xls sheet:扭蛋机商店
type LuaNiudanShop struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	ItemID               *int32   `protobuf:"zigzag32,2,opt,name=itemID" json:"itemID,omitempty"`
	Num                  *int32   `protobuf:"zigzag32,3,opt,name=num" json:"num,omitempty"`
	CostType             *int32   `protobuf:"zigzag32,4,opt,name=costType" json:"costType,omitempty"`
	Price                *int32   `protobuf:"zigzag32,5,opt,name=price" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaNiudanShop) Reset()         { *m = LuaNiudanShop{} }
func (m *LuaNiudanShop) String() string { return proto.CompactTextString(m) }
func (*LuaNiudanShop) ProtoMessage()    {}
func (*LuaNiudanShop) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{41}
}
func (m *LuaNiudanShop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaNiudanShop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaNiudanShop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaNiudanShop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaNiudanShop.Merge(m, src)
}
func (m *LuaNiudanShop) XXX_Size() int {
	return m.Size()
}
func (m *LuaNiudanShop) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaNiudanShop.DiscardUnknown(m)
}

var xxx_messageInfo_LuaNiudanShop proto.InternalMessageInfo

func (m *LuaNiudanShop) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaNiudanShop) GetItemID() int32 {
	if m != nil && m.ItemID != nil {
		return *m.ItemID
	}
	return 0
}

func (m *LuaNiudanShop) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

func (m *LuaNiudanShop) GetCostType() int32 {
	if m != nil && m.CostType != nil {
		return *m.CostType
	}
	return 0
}

func (m *LuaNiudanShop) GetPrice() int32 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

// Excel:avatar表情.xls sheet:suit_shop
type LuaSuitShop struct {
	Index                *int32   `protobuf:"zigzag32,1,opt,name=index" json:"index,omitempty"`
	Id                   *int32   `protobuf:"zigzag32,2,opt,name=id" json:"id,omitempty"`
	Duration             []int32  `protobuf:"zigzag32,3,rep,name=duration" json:"duration,omitempty"`
	CostType             *int32   `protobuf:"zigzag32,4,opt,name=costType" json:"costType,omitempty"`
	Price                []int32  `protobuf:"zigzag32,5,rep,name=price" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaSuitShop) Reset()         { *m = LuaSuitShop{} }
func (m *LuaSuitShop) String() string { return proto.CompactTextString(m) }
func (*LuaSuitShop) ProtoMessage()    {}
func (*LuaSuitShop) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{42}
}
func (m *LuaSuitShop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaSuitShop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaSuitShop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaSuitShop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaSuitShop.Merge(m, src)
}
func (m *LuaSuitShop) XXX_Size() int {
	return m.Size()
}
func (m *LuaSuitShop) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaSuitShop.DiscardUnknown(m)
}

var xxx_messageInfo_LuaSuitShop proto.InternalMessageInfo

func (m *LuaSuitShop) GetIndex() int32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *LuaSuitShop) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaSuitShop) GetDuration() []int32 {
	if m != nil {
		return m.Duration
	}
	return nil
}

func (m *LuaSuitShop) GetCostType() int32 {
	if m != nil && m.CostType != nil {
		return *m.CostType
	}
	return 0
}

func (m *LuaSuitShop) GetPrice() []int32 {
	if m != nil {
		return m.Price
	}
	return nil
}

// Excel:f副本表.xls sheet:关卡表
type LuaRisk struct {
	Id                   *int32           `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte           `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	DesID                []byte           `protobuf:"bytes,3,opt,name=desID" json:"desID,omitempty"`
	WaveList             []int32          `protobuf:"zigzag32,4,rep,name=waveList" json:"waveList,omitempty"`
	Boss                 *int32           `protobuf:"zigzag32,5,opt,name=boss" json:"boss,omitempty"`
	Type                 *int32           `protobuf:"zigzag32,6,opt,name=type" json:"type,omitempty"`
	ShowType             *int32           `protobuf:"zigzag32,7,opt,name=showType" json:"showType,omitempty"`
	WinCostStamina       *int32           `protobuf:"zigzag32,8,opt,name=winCostStamina" json:"winCostStamina,omitempty"`
	LoseCostStamina      *int32           `protobuf:"zigzag32,9,opt,name=loseCostStamina" json:"loseCostStamina,omitempty"`
	OpenLevel            *int32           `protobuf:"zigzag32,10,opt,name=openLevel" json:"openLevel,omitempty"`
	OpenDupList          []*OpenDupConfig `protobuf:"bytes,11,rep,name=openDupList" json:"openDupList,omitempty"`
	WinCondList          []int32          `protobuf:"zigzag32,12,rep,name=winCondList" json:"winCondList,omitempty"`
	WinArgList           []int32          `protobuf:"zigzag32,13,rep,name=winArgList" json:"winArgList,omitempty"`
	LoseCondType         *int32           `protobuf:"zigzag32,14,opt,name=loseCondType" json:"loseCondType,omitempty"`
	LimitTime            *int32           `protobuf:"zigzag32,15,opt,name=limitTime" json:"limitTime,omitempty"`
	MapID                *int32           `protobuf:"zigzag32,16,opt,name=mapID" json:"mapID,omitempty"`
	StartScreen          *int32           `protobuf:"zigzag32,17,opt,name=startScreen" json:"startScreen,omitempty"`
	DropRang             []int32          `protobuf:"zigzag32,18,rep,name=dropRang" json:"dropRang,omitempty"`
	MonsterBoxID         *int32           `protobuf:"zigzag32,19,opt,name=monsterBoxID" json:"monsterBoxID,omitempty"`
	BossBoxID            *int32           `protobuf:"zigzag32,20,opt,name=bossBoxID" json:"bossBoxID,omitempty"`
	ShowRewardList       []int32          `protobuf:"zigzag32,21,rep,name=showRewardList" json:"showRewardList,omitempty"`
	GetRewardList        []*ItemConfig    `protobuf:"bytes,22,rep,name=getRewardList" json:"getRewardList,omitempty"`
	Icon                 []byte           `protobuf:"bytes,23,opt,name=icon" json:"icon,omitempty"`
	FirstDropItemList    []*ItemConfig    `protobuf:"bytes,24,rep,name=firstDropItemList" json:"firstDropItemList,omitempty"`
	SuggestFight         *int32           `protobuf:"zigzag32,25,opt,name=suggestFight" json:"suggestFight,omitempty"`
	FightCount           *int32           `protobuf:"zigzag32,26,opt,name=fightCount" json:"fightCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *LuaRisk) Reset()         { *m = LuaRisk{} }
func (m *LuaRisk) String() string { return proto.CompactTextString(m) }
func (*LuaRisk) ProtoMessage()    {}
func (*LuaRisk) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{43}
}
func (m *LuaRisk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaRisk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaRisk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaRisk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaRisk.Merge(m, src)
}
func (m *LuaRisk) XXX_Size() int {
	return m.Size()
}
func (m *LuaRisk) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaRisk.DiscardUnknown(m)
}

var xxx_messageInfo_LuaRisk proto.InternalMessageInfo

func (m *LuaRisk) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaRisk) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaRisk) GetDesID() []byte {
	if m != nil {
		return m.DesID
	}
	return nil
}

func (m *LuaRisk) GetWaveList() []int32 {
	if m != nil {
		return m.WaveList
	}
	return nil
}

func (m *LuaRisk) GetBoss() int32 {
	if m != nil && m.Boss != nil {
		return *m.Boss
	}
	return 0
}

func (m *LuaRisk) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaRisk) GetShowType() int32 {
	if m != nil && m.ShowType != nil {
		return *m.ShowType
	}
	return 0
}

func (m *LuaRisk) GetWinCostStamina() int32 {
	if m != nil && m.WinCostStamina != nil {
		return *m.WinCostStamina
	}
	return 0
}

func (m *LuaRisk) GetLoseCostStamina() int32 {
	if m != nil && m.LoseCostStamina != nil {
		return *m.LoseCostStamina
	}
	return 0
}

func (m *LuaRisk) GetOpenLevel() int32 {
	if m != nil && m.OpenLevel != nil {
		return *m.OpenLevel
	}
	return 0
}

func (m *LuaRisk) GetOpenDupList() []*OpenDupConfig {
	if m != nil {
		return m.OpenDupList
	}
	return nil
}

func (m *LuaRisk) GetWinCondList() []int32 {
	if m != nil {
		return m.WinCondList
	}
	return nil
}

func (m *LuaRisk) GetWinArgList() []int32 {
	if m != nil {
		return m.WinArgList
	}
	return nil
}

func (m *LuaRisk) GetLoseCondType() int32 {
	if m != nil && m.LoseCondType != nil {
		return *m.LoseCondType
	}
	return 0
}

func (m *LuaRisk) GetLimitTime() int32 {
	if m != nil && m.LimitTime != nil {
		return *m.LimitTime
	}
	return 0
}

func (m *LuaRisk) GetMapID() int32 {
	if m != nil && m.MapID != nil {
		return *m.MapID
	}
	return 0
}

func (m *LuaRisk) GetStartScreen() int32 {
	if m != nil && m.StartScreen != nil {
		return *m.StartScreen
	}
	return 0
}

func (m *LuaRisk) GetDropRang() []int32 {
	if m != nil {
		return m.DropRang
	}
	return nil
}

func (m *LuaRisk) GetMonsterBoxID() int32 {
	if m != nil && m.MonsterBoxID != nil {
		return *m.MonsterBoxID
	}
	return 0
}

func (m *LuaRisk) GetBossBoxID() int32 {
	if m != nil && m.BossBoxID != nil {
		return *m.BossBoxID
	}
	return 0
}

func (m *LuaRisk) GetShowRewardList() []int32 {
	if m != nil {
		return m.ShowRewardList
	}
	return nil
}

func (m *LuaRisk) GetGetRewardList() []*ItemConfig {
	if m != nil {
		return m.GetRewardList
	}
	return nil
}

func (m *LuaRisk) GetIcon() []byte {
	if m != nil {
		return m.Icon
	}
	return nil
}

func (m *LuaRisk) GetFirstDropItemList() []*ItemConfig {
	if m != nil {
		return m.FirstDropItemList
	}
	return nil
}

func (m *LuaRisk) GetSuggestFight() int32 {
	if m != nil && m.SuggestFight != nil {
		return *m.SuggestFight
	}
	return 0
}

func (m *LuaRisk) GetFightCount() int32 {
	if m != nil && m.FightCount != nil {
		return *m.FightCount
	}
	return 0
}

// Excel:二次元配置表.xls sheet:二次元成长奖励表
type LuaGuadraticLevelReward struct {
	Level                *int32        `protobuf:"zigzag32,1,opt,name=level" json:"level,omitempty"`
	RewardList           []*ItemConfig `protobuf:"bytes,2,rep,name=rewardList" json:"rewardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaGuadraticLevelReward) Reset()         { *m = LuaGuadraticLevelReward{} }
func (m *LuaGuadraticLevelReward) String() string { return proto.CompactTextString(m) }
func (*LuaGuadraticLevelReward) ProtoMessage()    {}
func (*LuaGuadraticLevelReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{44}
}
func (m *LuaGuadraticLevelReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaGuadraticLevelReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaGuadraticLevelReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaGuadraticLevelReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaGuadraticLevelReward.Merge(m, src)
}
func (m *LuaGuadraticLevelReward) XXX_Size() int {
	return m.Size()
}
func (m *LuaGuadraticLevelReward) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaGuadraticLevelReward.DiscardUnknown(m)
}

var xxx_messageInfo_LuaGuadraticLevelReward proto.InternalMessageInfo

func (m *LuaGuadraticLevelReward) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaGuadraticLevelReward) GetRewardList() []*ItemConfig {
	if m != nil {
		return m.RewardList
	}
	return nil
}

// Excel:道具商店表.xls sheet:黑市商店等级随机表
type LuaBlackShopRandom struct {
	Level                *int32                   `protobuf:"zigzag32,1,opt,name=level" json:"level,omitempty"`
	ItemIdList           []*ShopRandomSectionList `protobuf:"bytes,2,rep,name=itemIdList" json:"itemIdList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *LuaBlackShopRandom) Reset()         { *m = LuaBlackShopRandom{} }
func (m *LuaBlackShopRandom) String() string { return proto.CompactTextString(m) }
func (*LuaBlackShopRandom) ProtoMessage()    {}
func (*LuaBlackShopRandom) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{45}
}
func (m *LuaBlackShopRandom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaBlackShopRandom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaBlackShopRandom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaBlackShopRandom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaBlackShopRandom.Merge(m, src)
}
func (m *LuaBlackShopRandom) XXX_Size() int {
	return m.Size()
}
func (m *LuaBlackShopRandom) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaBlackShopRandom.DiscardUnknown(m)
}

var xxx_messageInfo_LuaBlackShopRandom proto.InternalMessageInfo

func (m *LuaBlackShopRandom) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaBlackShopRandom) GetItemIdList() []*ShopRandomSectionList {
	if m != nil {
		return m.ItemIdList
	}
	return nil
}

// Excel:道具商店表.xls sheet:黑市商店
type LuaBlackShop struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	ItemID               *int32   `protobuf:"zigzag32,2,opt,name=itemID" json:"itemID,omitempty"`
	Num                  *int32   `protobuf:"zigzag32,3,opt,name=num" json:"num,omitempty"`
	CostType             *int32   `protobuf:"zigzag32,4,opt,name=costType" json:"costType,omitempty"`
	Price                *int32   `protobuf:"zigzag32,5,opt,name=price" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaBlackShop) Reset()         { *m = LuaBlackShop{} }
func (m *LuaBlackShop) String() string { return proto.CompactTextString(m) }
func (*LuaBlackShop) ProtoMessage()    {}
func (*LuaBlackShop) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{46}
}
func (m *LuaBlackShop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaBlackShop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaBlackShop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaBlackShop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaBlackShop.Merge(m, src)
}
func (m *LuaBlackShop) XXX_Size() int {
	return m.Size()
}
func (m *LuaBlackShop) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaBlackShop.DiscardUnknown(m)
}

var xxx_messageInfo_LuaBlackShop proto.InternalMessageInfo

func (m *LuaBlackShop) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaBlackShop) GetItemID() int32 {
	if m != nil && m.ItemID != nil {
		return *m.ItemID
	}
	return 0
}

func (m *LuaBlackShop) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

func (m *LuaBlackShop) GetCostType() int32 {
	if m != nil && m.CostType != nil {
		return *m.CostType
	}
	return 0
}

func (m *LuaBlackShop) GetPrice() int32 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

// Excel:c场景失败表.xls sheet:切场景失败传送表
type LuaSceneFail struct {
	Id                   *int32    `protobuf:"zigzag32,1,opt,name=Id" json:"Id,omitempty"`
	SrcSceneId           *int32    `protobuf:"zigzag32,2,opt,name=srcSceneId" json:"srcSceneId,omitempty"`
	TrySceneId           *int32    `protobuf:"zigzag32,3,opt,name=trySceneId" json:"trySceneId,omitempty"`
	ReturnSceneId        *int32    `protobuf:"zigzag32,4,opt,name=returnSceneId" json:"returnSceneId,omitempty"`
	ReturnBornPosList    []*LuaPos `protobuf:"bytes,5,rep,name=returnBornPosList" json:"returnBornPosList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *LuaSceneFail) Reset()         { *m = LuaSceneFail{} }
func (m *LuaSceneFail) String() string { return proto.CompactTextString(m) }
func (*LuaSceneFail) ProtoMessage()    {}
func (*LuaSceneFail) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{47}
}
func (m *LuaSceneFail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaSceneFail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaSceneFail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaSceneFail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaSceneFail.Merge(m, src)
}
func (m *LuaSceneFail) XXX_Size() int {
	return m.Size()
}
func (m *LuaSceneFail) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaSceneFail.DiscardUnknown(m)
}

var xxx_messageInfo_LuaSceneFail proto.InternalMessageInfo

func (m *LuaSceneFail) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaSceneFail) GetSrcSceneId() int32 {
	if m != nil && m.SrcSceneId != nil {
		return *m.SrcSceneId
	}
	return 0
}

func (m *LuaSceneFail) GetTrySceneId() int32 {
	if m != nil && m.TrySceneId != nil {
		return *m.TrySceneId
	}
	return 0
}

func (m *LuaSceneFail) GetReturnSceneId() int32 {
	if m != nil && m.ReturnSceneId != nil {
		return *m.ReturnSceneId
	}
	return 0
}

func (m *LuaSceneFail) GetReturnBornPosList() []*LuaPos {
	if m != nil {
		return m.ReturnBornPosList
	}
	return nil
}

// Excel:z澡堂大战表.xls sheet:大战阶段表
type LuaBathFightStep struct {
	Step                 *int32              `protobuf:"zigzag32,1,opt,name=step" json:"step,omitempty"`
	CdTime               *int32              `protobuf:"zigzag32,2,opt,name=cdTime" json:"cdTime,omitempty"`
	NextStepCount        *BathInteractTool   `protobuf:"bytes,3,opt,name=nextStepCount" json:"nextStepCount,omitempty"`
	NewInteractToolList  []*BathInteractTool `protobuf:"bytes,4,rep,name=newInteractToolList" json:"newInteractToolList,omitempty"`
	IsWatersplash        *int32              `protobuf:"zigzag32,5,opt,name=isWatersplash" json:"isWatersplash,omitempty"`
	BroadcastTimeStep    *int32              `protobuf:"zigzag32,6,opt,name=broadcastTimeStep" json:"broadcastTimeStep,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *LuaBathFightStep) Reset()         { *m = LuaBathFightStep{} }
func (m *LuaBathFightStep) String() string { return proto.CompactTextString(m) }
func (*LuaBathFightStep) ProtoMessage()    {}
func (*LuaBathFightStep) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{48}
}
func (m *LuaBathFightStep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaBathFightStep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaBathFightStep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaBathFightStep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaBathFightStep.Merge(m, src)
}
func (m *LuaBathFightStep) XXX_Size() int {
	return m.Size()
}
func (m *LuaBathFightStep) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaBathFightStep.DiscardUnknown(m)
}

var xxx_messageInfo_LuaBathFightStep proto.InternalMessageInfo

func (m *LuaBathFightStep) GetStep() int32 {
	if m != nil && m.Step != nil {
		return *m.Step
	}
	return 0
}

func (m *LuaBathFightStep) GetCdTime() int32 {
	if m != nil && m.CdTime != nil {
		return *m.CdTime
	}
	return 0
}

func (m *LuaBathFightStep) GetNextStepCount() *BathInteractTool {
	if m != nil {
		return m.NextStepCount
	}
	return nil
}

func (m *LuaBathFightStep) GetNewInteractToolList() []*BathInteractTool {
	if m != nil {
		return m.NewInteractToolList
	}
	return nil
}

func (m *LuaBathFightStep) GetIsWatersplash() int32 {
	if m != nil && m.IsWatersplash != nil {
		return *m.IsWatersplash
	}
	return 0
}

func (m *LuaBathFightStep) GetBroadcastTimeStep() int32 {
	if m != nil && m.BroadcastTimeStep != nil {
		return *m.BroadcastTimeStep
	}
	return 0
}

// Excel:z澡堂大战表.xls sheet:澡堂交互道具类型
type LuaBathToolType struct {
	Type                 *int32   `protobuf:"zigzag32,1,opt,name=type" json:"type,omitempty"`
	UseCount             *int32   `protobuf:"zigzag32,2,opt,name=useCount" json:"useCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaBathToolType) Reset()         { *m = LuaBathToolType{} }
func (m *LuaBathToolType) String() string { return proto.CompactTextString(m) }
func (*LuaBathToolType) ProtoMessage()    {}
func (*LuaBathToolType) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{49}
}
func (m *LuaBathToolType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaBathToolType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaBathToolType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaBathToolType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaBathToolType.Merge(m, src)
}
func (m *LuaBathToolType) XXX_Size() int {
	return m.Size()
}
func (m *LuaBathToolType) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaBathToolType.DiscardUnknown(m)
}

var xxx_messageInfo_LuaBathToolType proto.InternalMessageInfo

func (m *LuaBathToolType) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaBathToolType) GetUseCount() int32 {
	if m != nil && m.UseCount != nil {
		return *m.UseCount
	}
	return 0
}

// Excel:竞技场表.xls sheet:木桩敌人模板表
type LuaArenaTemplate struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	Atk                  *int32   `protobuf:"zigzag32,2,opt,name=atk" json:"atk,omitempty"`
	Def                  *int32   `protobuf:"zigzag32,3,opt,name=def" json:"def,omitempty"`
	Hp                   *int32   `protobuf:"zigzag32,4,opt,name=hp" json:"hp,omitempty"`
	Crit                 *int32   `protobuf:"zigzag32,5,opt,name=crit" json:"crit,omitempty"`
	Block                *int32   `protobuf:"zigzag32,6,opt,name=block" json:"block,omitempty"`
	Speed                *int32   `protobuf:"zigzag32,7,opt,name=speed" json:"speed,omitempty"`
	Act                  *int32   `protobuf:"zigzag32,8,opt,name=act" json:"act,omitempty"`
	SuitID               *int32   `protobuf:"zigzag32,9,opt,name=suitID" json:"suitID,omitempty"`
	FaceID               *int32   `protobuf:"zigzag32,10,opt,name=faceID" json:"faceID,omitempty"`
	WeaponID             *int32   `protobuf:"zigzag32,11,opt,name=weaponID" json:"weaponID,omitempty"`
	HatID                *int32   `protobuf:"zigzag32,12,opt,name=hatID" json:"hatID,omitempty"`
	WingID               *int32   `protobuf:"zigzag32,13,opt,name=wingID" json:"wingID,omitempty"`
	SkillList            []int32  `protobuf:"zigzag32,14,rep,name=skillList" json:"skillList,omitempty"`
	SkillLevelList       []int32  `protobuf:"zigzag32,15,rep,name=skillLevelList" json:"skillLevelList,omitempty"`
	SkillPropLevelList   []int32  `protobuf:"zigzag32,16,rep,name=skillPropLevelList" json:"skillPropLevelList,omitempty"`
	SuitSkillID          *int32   `protobuf:"zigzag32,17,opt,name=suitSkillID" json:"suitSkillID,omitempty"`
	SuitSkillLevel       *int32   `protobuf:"zigzag32,18,opt,name=suitSkillLevel" json:"suitSkillLevel,omitempty"`
	SuitSkillPropLevel   *int32   `protobuf:"zigzag32,19,opt,name=suitSkillPropLevel" json:"suitSkillPropLevel,omitempty"`
	CardList             []int32  `protobuf:"zigzag32,20,rep,name=cardList" json:"cardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaArenaTemplate) Reset()         { *m = LuaArenaTemplate{} }
func (m *LuaArenaTemplate) String() string { return proto.CompactTextString(m) }
func (*LuaArenaTemplate) ProtoMessage()    {}
func (*LuaArenaTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{50}
}
func (m *LuaArenaTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaArenaTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaArenaTemplate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaArenaTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaArenaTemplate.Merge(m, src)
}
func (m *LuaArenaTemplate) XXX_Size() int {
	return m.Size()
}
func (m *LuaArenaTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaArenaTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_LuaArenaTemplate proto.InternalMessageInfo

func (m *LuaArenaTemplate) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaArenaTemplate) GetAtk() int32 {
	if m != nil && m.Atk != nil {
		return *m.Atk
	}
	return 0
}

func (m *LuaArenaTemplate) GetDef() int32 {
	if m != nil && m.Def != nil {
		return *m.Def
	}
	return 0
}

func (m *LuaArenaTemplate) GetHp() int32 {
	if m != nil && m.Hp != nil {
		return *m.Hp
	}
	return 0
}

func (m *LuaArenaTemplate) GetCrit() int32 {
	if m != nil && m.Crit != nil {
		return *m.Crit
	}
	return 0
}

func (m *LuaArenaTemplate) GetBlock() int32 {
	if m != nil && m.Block != nil {
		return *m.Block
	}
	return 0
}

func (m *LuaArenaTemplate) GetSpeed() int32 {
	if m != nil && m.Speed != nil {
		return *m.Speed
	}
	return 0
}

func (m *LuaArenaTemplate) GetAct() int32 {
	if m != nil && m.Act != nil {
		return *m.Act
	}
	return 0
}

func (m *LuaArenaTemplate) GetSuitID() int32 {
	if m != nil && m.SuitID != nil {
		return *m.SuitID
	}
	return 0
}

func (m *LuaArenaTemplate) GetFaceID() int32 {
	if m != nil && m.FaceID != nil {
		return *m.FaceID
	}
	return 0
}

func (m *LuaArenaTemplate) GetWeaponID() int32 {
	if m != nil && m.WeaponID != nil {
		return *m.WeaponID
	}
	return 0
}

func (m *LuaArenaTemplate) GetHatID() int32 {
	if m != nil && m.HatID != nil {
		return *m.HatID
	}
	return 0
}

func (m *LuaArenaTemplate) GetWingID() int32 {
	if m != nil && m.WingID != nil {
		return *m.WingID
	}
	return 0
}

func (m *LuaArenaTemplate) GetSkillList() []int32 {
	if m != nil {
		return m.SkillList
	}
	return nil
}

func (m *LuaArenaTemplate) GetSkillLevelList() []int32 {
	if m != nil {
		return m.SkillLevelList
	}
	return nil
}

func (m *LuaArenaTemplate) GetSkillPropLevelList() []int32 {
	if m != nil {
		return m.SkillPropLevelList
	}
	return nil
}

func (m *LuaArenaTemplate) GetSuitSkillID() int32 {
	if m != nil && m.SuitSkillID != nil {
		return *m.SuitSkillID
	}
	return 0
}

func (m *LuaArenaTemplate) GetSuitSkillLevel() int32 {
	if m != nil && m.SuitSkillLevel != nil {
		return *m.SuitSkillLevel
	}
	return 0
}

func (m *LuaArenaTemplate) GetSuitSkillPropLevel() int32 {
	if m != nil && m.SuitSkillPropLevel != nil {
		return *m.SuitSkillPropLevel
	}
	return 0
}

func (m *LuaArenaTemplate) GetCardList() []int32 {
	if m != nil {
		return m.CardList
	}
	return nil
}

// Excel:z澡堂大战表.xls sheet:结束条件表
type LuaBathFightEnd struct {
	Id                   *int32              `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	CdTime               *int32              `protobuf:"zigzag32,2,opt,name=cdTime" json:"cdTime,omitempty"`
	EndConditionList     []*BathInteractTool `protobuf:"bytes,3,rep,name=endConditionList" json:"endConditionList,omitempty"`
	RewardList           []int32             `protobuf:"zigzag32,4,rep,name=rewardList" json:"rewardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *LuaBathFightEnd) Reset()         { *m = LuaBathFightEnd{} }
func (m *LuaBathFightEnd) String() string { return proto.CompactTextString(m) }
func (*LuaBathFightEnd) ProtoMessage()    {}
func (*LuaBathFightEnd) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{51}
}
func (m *LuaBathFightEnd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaBathFightEnd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaBathFightEnd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaBathFightEnd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaBathFightEnd.Merge(m, src)
}
func (m *LuaBathFightEnd) XXX_Size() int {
	return m.Size()
}
func (m *LuaBathFightEnd) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaBathFightEnd.DiscardUnknown(m)
}

var xxx_messageInfo_LuaBathFightEnd proto.InternalMessageInfo

func (m *LuaBathFightEnd) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaBathFightEnd) GetCdTime() int32 {
	if m != nil && m.CdTime != nil {
		return *m.CdTime
	}
	return 0
}

func (m *LuaBathFightEnd) GetEndConditionList() []*BathInteractTool {
	if m != nil {
		return m.EndConditionList
	}
	return nil
}

func (m *LuaBathFightEnd) GetRewardList() []int32 {
	if m != nil {
		return m.RewardList
	}
	return nil
}

// Excel:z澡堂大战表.xls sheet:澡堂效果表
type LuaBathStatus struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	Type                 *int32   `protobuf:"zigzag32,2,opt,name=type" json:"type,omitempty"`
	TypeRatio            *int32   `protobuf:"zigzag32,3,opt,name=typeRatio" json:"typeRatio,omitempty"`
	Stamina              *int32   `protobuf:"zigzag32,4,opt,name=stamina" json:"stamina,omitempty"`
	Exp                  *int32   `protobuf:"zigzag32,5,opt,name=exp" json:"exp,omitempty"`
	Fullness             *int32   `protobuf:"zigzag32,6,opt,name=fullness" json:"fullness,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaBathStatus) Reset()         { *m = LuaBathStatus{} }
func (m *LuaBathStatus) String() string { return proto.CompactTextString(m) }
func (*LuaBathStatus) ProtoMessage()    {}
func (*LuaBathStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{52}
}
func (m *LuaBathStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaBathStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaBathStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaBathStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaBathStatus.Merge(m, src)
}
func (m *LuaBathStatus) XXX_Size() int {
	return m.Size()
}
func (m *LuaBathStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaBathStatus.DiscardUnknown(m)
}

var xxx_messageInfo_LuaBathStatus proto.InternalMessageInfo

func (m *LuaBathStatus) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaBathStatus) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaBathStatus) GetTypeRatio() int32 {
	if m != nil && m.TypeRatio != nil {
		return *m.TypeRatio
	}
	return 0
}

func (m *LuaBathStatus) GetStamina() int32 {
	if m != nil && m.Stamina != nil {
		return *m.Stamina
	}
	return 0
}

func (m *LuaBathStatus) GetExp() int32 {
	if m != nil && m.Exp != nil {
		return *m.Exp
	}
	return 0
}

func (m *LuaBathStatus) GetFullness() int32 {
	if m != nil && m.Fullness != nil {
		return *m.Fullness
	}
	return 0
}

// Excel:d氪星石兑换表.xls sheet:氪金石兑换
type LuaStoneExchange struct {
	ItemId               *int32      `protobuf:"zigzag32,1,opt,name=itemId" json:"itemId,omitempty"`
	NeedItem             *ItemConfig `protobuf:"bytes,2,opt,name=needItem" json:"needItem,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *LuaStoneExchange) Reset()         { *m = LuaStoneExchange{} }
func (m *LuaStoneExchange) String() string { return proto.CompactTextString(m) }
func (*LuaStoneExchange) ProtoMessage()    {}
func (*LuaStoneExchange) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{53}
}
func (m *LuaStoneExchange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaStoneExchange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaStoneExchange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaStoneExchange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaStoneExchange.Merge(m, src)
}
func (m *LuaStoneExchange) XXX_Size() int {
	return m.Size()
}
func (m *LuaStoneExchange) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaStoneExchange.DiscardUnknown(m)
}

var xxx_messageInfo_LuaStoneExchange proto.InternalMessageInfo

func (m *LuaStoneExchange) GetItemId() int32 {
	if m != nil && m.ItemId != nil {
		return *m.ItemId
	}
	return 0
}

func (m *LuaStoneExchange) GetNeedItem() *ItemConfig {
	if m != nil {
		return m.NeedItem
	}
	return nil
}

// Excel:小游戏表.xls sheet:小游戏排行表
type LuaMinigameRank struct {
	Id                   *int32              `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	DisplayInfoList      []*MinigameRankInfo `protobuf:"bytes,2,rep,name=display_info_list" json:"display_info_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *LuaMinigameRank) Reset()         { *m = LuaMinigameRank{} }
func (m *LuaMinigameRank) String() string { return proto.CompactTextString(m) }
func (*LuaMinigameRank) ProtoMessage()    {}
func (*LuaMinigameRank) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{54}
}
func (m *LuaMinigameRank) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaMinigameRank) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaMinigameRank.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaMinigameRank) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaMinigameRank.Merge(m, src)
}
func (m *LuaMinigameRank) XXX_Size() int {
	return m.Size()
}
func (m *LuaMinigameRank) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaMinigameRank.DiscardUnknown(m)
}

var xxx_messageInfo_LuaMinigameRank proto.InternalMessageInfo

func (m *LuaMinigameRank) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaMinigameRank) GetDisplayInfoList() []*MinigameRankInfo {
	if m != nil {
		return m.DisplayInfoList
	}
	return nil
}

// Excel:h好友等级属性表.xls sheet:角色等级表
type LuaFriendLevel struct {
	Lvl                  *int32   `protobuf:"zigzag32,1,opt,name=lvl" json:"lvl,omitempty"`
	Hp                   *int32   `protobuf:"zigzag32,2,opt,name=hp" json:"hp,omitempty"`
	Atk                  *int32   `protobuf:"zigzag32,3,opt,name=atk" json:"atk,omitempty"`
	Def                  *int32   `protobuf:"zigzag32,4,opt,name=def" json:"def,omitempty"`
	Crit                 *int32   `protobuf:"zigzag32,5,opt,name=crit" json:"crit,omitempty"`
	Block                *int32   `protobuf:"zigzag32,6,opt,name=block" json:"block,omitempty"`
	Speed                *int32   `protobuf:"zigzag32,7,opt,name=speed" json:"speed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaFriendLevel) Reset()         { *m = LuaFriendLevel{} }
func (m *LuaFriendLevel) String() string { return proto.CompactTextString(m) }
func (*LuaFriendLevel) ProtoMessage()    {}
func (*LuaFriendLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{55}
}
func (m *LuaFriendLevel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaFriendLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaFriendLevel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaFriendLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaFriendLevel.Merge(m, src)
}
func (m *LuaFriendLevel) XXX_Size() int {
	return m.Size()
}
func (m *LuaFriendLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaFriendLevel.DiscardUnknown(m)
}

var xxx_messageInfo_LuaFriendLevel proto.InternalMessageInfo

func (m *LuaFriendLevel) GetLvl() int32 {
	if m != nil && m.Lvl != nil {
		return *m.Lvl
	}
	return 0
}

func (m *LuaFriendLevel) GetHp() int32 {
	if m != nil && m.Hp != nil {
		return *m.Hp
	}
	return 0
}

func (m *LuaFriendLevel) GetAtk() int32 {
	if m != nil && m.Atk != nil {
		return *m.Atk
	}
	return 0
}

func (m *LuaFriendLevel) GetDef() int32 {
	if m != nil && m.Def != nil {
		return *m.Def
	}
	return 0
}

func (m *LuaFriendLevel) GetCrit() int32 {
	if m != nil && m.Crit != nil {
		return *m.Crit
	}
	return 0
}

func (m *LuaFriendLevel) GetBlock() int32 {
	if m != nil && m.Block != nil {
		return *m.Block
	}
	return 0
}

func (m *LuaFriendLevel) GetSpeed() int32 {
	if m != nil && m.Speed != nil {
		return *m.Speed
	}
	return 0
}

// Excel:小游戏表.xls sheet:小游戏等级奖励表
type LuaMinigameLevel struct {
	Level                *int32                 `protobuf:"zigzag32,1,opt,name=level" json:"level,omitempty"`
	RewardList           []*MinigameLevelReward `protobuf:"bytes,2,rep,name=reward_list" json:"reward_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *LuaMinigameLevel) Reset()         { *m = LuaMinigameLevel{} }
func (m *LuaMinigameLevel) String() string { return proto.CompactTextString(m) }
func (*LuaMinigameLevel) ProtoMessage()    {}
func (*LuaMinigameLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{56}
}
func (m *LuaMinigameLevel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaMinigameLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaMinigameLevel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaMinigameLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaMinigameLevel.Merge(m, src)
}
func (m *LuaMinigameLevel) XXX_Size() int {
	return m.Size()
}
func (m *LuaMinigameLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaMinigameLevel.DiscardUnknown(m)
}

var xxx_messageInfo_LuaMinigameLevel proto.InternalMessageInfo

func (m *LuaMinigameLevel) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaMinigameLevel) GetRewardList() []*MinigameLevelReward {
	if m != nil {
		return m.RewardList
	}
	return nil
}

// Excel:二次元配置表.xls sheet:二次元关卡表
type LuaGuadraticDup struct {
	Id                   *int32        `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	Time                 *int32        `protobuf:"zigzag32,2,opt,name=time" json:"time,omitempty"`
	MapSize              *LuaSize      `protobuf:"bytes,3,opt,name=mapSize" json:"mapSize,omitempty"`
	BossEnterList        []*BossEnter  `protobuf:"bytes,4,rep,name=bossEnterList" json:"bossEnterList,omitempty"`
	BossEnterRect        []*LuaPosRect `protobuf:"bytes,5,rep,name=bossEnterRect" json:"bossEnterRect,omitempty"`
	MapList              [][]byte      `protobuf:"bytes,6,rep,name=mapList" json:"mapList,omitempty"`
	DataFile             []byte        `protobuf:"bytes,7,opt,name=dataFile" json:"dataFile,omitempty"`
	BornPosList          []*LuaPos     `protobuf:"bytes,8,rep,name=bornPosList" json:"bornPosList,omitempty"`
	Music                []byte        `protobuf:"bytes,9,opt,name=music" json:"music,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaGuadraticDup) Reset()         { *m = LuaGuadraticDup{} }
func (m *LuaGuadraticDup) String() string { return proto.CompactTextString(m) }
func (*LuaGuadraticDup) ProtoMessage()    {}
func (*LuaGuadraticDup) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{57}
}
func (m *LuaGuadraticDup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaGuadraticDup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaGuadraticDup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaGuadraticDup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaGuadraticDup.Merge(m, src)
}
func (m *LuaGuadraticDup) XXX_Size() int {
	return m.Size()
}
func (m *LuaGuadraticDup) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaGuadraticDup.DiscardUnknown(m)
}

var xxx_messageInfo_LuaGuadraticDup proto.InternalMessageInfo

func (m *LuaGuadraticDup) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaGuadraticDup) GetTime() int32 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *LuaGuadraticDup) GetMapSize() *LuaSize {
	if m != nil {
		return m.MapSize
	}
	return nil
}

func (m *LuaGuadraticDup) GetBossEnterList() []*BossEnter {
	if m != nil {
		return m.BossEnterList
	}
	return nil
}

func (m *LuaGuadraticDup) GetBossEnterRect() []*LuaPosRect {
	if m != nil {
		return m.BossEnterRect
	}
	return nil
}

func (m *LuaGuadraticDup) GetMapList() [][]byte {
	if m != nil {
		return m.MapList
	}
	return nil
}

func (m *LuaGuadraticDup) GetDataFile() []byte {
	if m != nil {
		return m.DataFile
	}
	return nil
}

func (m *LuaGuadraticDup) GetBornPosList() []*LuaPos {
	if m != nil {
		return m.BornPosList
	}
	return nil
}

func (m *LuaGuadraticDup) GetMusic() []byte {
	if m != nil {
		return m.Music
	}
	return nil
}

// Excel:小游戏表.xls sheet:小游戏分数奖励表
type LuaMinigameScore struct {
	Score                *int32                 `protobuf:"zigzag32,1,opt,name=score" json:"score,omitempty"`
	RewardList           []*MinigameScoreReward `protobuf:"bytes,2,rep,name=reward_list" json:"reward_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *LuaMinigameScore) Reset()         { *m = LuaMinigameScore{} }
func (m *LuaMinigameScore) String() string { return proto.CompactTextString(m) }
func (*LuaMinigameScore) ProtoMessage()    {}
func (*LuaMinigameScore) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{58}
}
func (m *LuaMinigameScore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaMinigameScore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaMinigameScore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaMinigameScore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaMinigameScore.Merge(m, src)
}
func (m *LuaMinigameScore) XXX_Size() int {
	return m.Size()
}
func (m *LuaMinigameScore) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaMinigameScore.DiscardUnknown(m)
}

var xxx_messageInfo_LuaMinigameScore proto.InternalMessageInfo

func (m *LuaMinigameScore) GetScore() int32 {
	if m != nil && m.Score != nil {
		return *m.Score
	}
	return 0
}

func (m *LuaMinigameScore) GetRewardList() []*MinigameScoreReward {
	if m != nil {
		return m.RewardList
	}
	return nil
}

// Excel:道具商店表.xls sheet:竞技场商店等级随机表
type LuaArenaShopRandom struct {
	Level                *int32                   `protobuf:"zigzag32,1,opt,name=level" json:"level,omitempty"`
	ItemIdList           []*ShopRandomSectionList `protobuf:"bytes,2,rep,name=itemIdList" json:"itemIdList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *LuaArenaShopRandom) Reset()         { *m = LuaArenaShopRandom{} }
func (m *LuaArenaShopRandom) String() string { return proto.CompactTextString(m) }
func (*LuaArenaShopRandom) ProtoMessage()    {}
func (*LuaArenaShopRandom) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{59}
}
func (m *LuaArenaShopRandom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaArenaShopRandom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaArenaShopRandom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaArenaShopRandom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaArenaShopRandom.Merge(m, src)
}
func (m *LuaArenaShopRandom) XXX_Size() int {
	return m.Size()
}
func (m *LuaArenaShopRandom) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaArenaShopRandom.DiscardUnknown(m)
}

var xxx_messageInfo_LuaArenaShopRandom proto.InternalMessageInfo

func (m *LuaArenaShopRandom) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaArenaShopRandom) GetItemIdList() []*ShopRandomSectionList {
	if m != nil {
		return m.ItemIdList
	}
	return nil
}

// Excel:人物等级属性表.xls sheet:角色等级表
type LuaRoleLevel struct {
	Lvl                  *int32   `protobuf:"zigzag32,1,opt,name=lvl" json:"lvl,omitempty"`
	Exp                  *int32   `protobuf:"zigzag32,2,opt,name=exp" json:"exp,omitempty"`
	SkillPoint           *int32   `protobuf:"zigzag32,3,opt,name=skillPoint" json:"skillPoint,omitempty"`
	Stamina              *int32   `protobuf:"zigzag32,4,opt,name=stamina" json:"stamina,omitempty"`
	Hp                   *int32   `protobuf:"zigzag32,5,opt,name=hp" json:"hp,omitempty"`
	Atk                  *int32   `protobuf:"zigzag32,6,opt,name=atk" json:"atk,omitempty"`
	Def                  *int32   `protobuf:"zigzag32,7,opt,name=def" json:"def,omitempty"`
	Crit                 *int32   `protobuf:"zigzag32,8,opt,name=crit" json:"crit,omitempty"`
	Block                *int32   `protobuf:"zigzag32,9,opt,name=block" json:"block,omitempty"`
	Speed                *int32   `protobuf:"zigzag32,10,opt,name=speed" json:"speed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaRoleLevel) Reset()         { *m = LuaRoleLevel{} }
func (m *LuaRoleLevel) String() string { return proto.CompactTextString(m) }
func (*LuaRoleLevel) ProtoMessage()    {}
func (*LuaRoleLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{60}
}
func (m *LuaRoleLevel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaRoleLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaRoleLevel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaRoleLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaRoleLevel.Merge(m, src)
}
func (m *LuaRoleLevel) XXX_Size() int {
	return m.Size()
}
func (m *LuaRoleLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaRoleLevel.DiscardUnknown(m)
}

var xxx_messageInfo_LuaRoleLevel proto.InternalMessageInfo

func (m *LuaRoleLevel) GetLvl() int32 {
	if m != nil && m.Lvl != nil {
		return *m.Lvl
	}
	return 0
}

func (m *LuaRoleLevel) GetExp() int32 {
	if m != nil && m.Exp != nil {
		return *m.Exp
	}
	return 0
}

func (m *LuaRoleLevel) GetSkillPoint() int32 {
	if m != nil && m.SkillPoint != nil {
		return *m.SkillPoint
	}
	return 0
}

func (m *LuaRoleLevel) GetStamina() int32 {
	if m != nil && m.Stamina != nil {
		return *m.Stamina
	}
	return 0
}

func (m *LuaRoleLevel) GetHp() int32 {
	if m != nil && m.Hp != nil {
		return *m.Hp
	}
	return 0
}

func (m *LuaRoleLevel) GetAtk() int32 {
	if m != nil && m.Atk != nil {
		return *m.Atk
	}
	return 0
}

func (m *LuaRoleLevel) GetDef() int32 {
	if m != nil && m.Def != nil {
		return *m.Def
	}
	return 0
}

func (m *LuaRoleLevel) GetCrit() int32 {
	if m != nil && m.Crit != nil {
		return *m.Crit
	}
	return 0
}

func (m *LuaRoleLevel) GetBlock() int32 {
	if m != nil && m.Block != nil {
		return *m.Block
	}
	return 0
}

func (m *LuaRoleLevel) GetSpeed() int32 {
	if m != nil && m.Speed != nil {
		return *m.Speed
	}
	return 0
}

// Excel:道具商店表.xls sheet:竞技场商店
type LuaArenaShop struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	ItemID               *int32   `protobuf:"zigzag32,2,opt,name=itemID" json:"itemID,omitempty"`
	Num                  *int32   `protobuf:"zigzag32,3,opt,name=num" json:"num,omitempty"`
	CostType             *int32   `protobuf:"zigzag32,4,opt,name=costType" json:"costType,omitempty"`
	Price                *int32   `protobuf:"zigzag32,5,opt,name=price" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaArenaShop) Reset()         { *m = LuaArenaShop{} }
func (m *LuaArenaShop) String() string { return proto.CompactTextString(m) }
func (*LuaArenaShop) ProtoMessage()    {}
func (*LuaArenaShop) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{61}
}
func (m *LuaArenaShop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaArenaShop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaArenaShop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaArenaShop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaArenaShop.Merge(m, src)
}
func (m *LuaArenaShop) XXX_Size() int {
	return m.Size()
}
func (m *LuaArenaShop) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaArenaShop.DiscardUnknown(m)
}

var xxx_messageInfo_LuaArenaShop proto.InternalMessageInfo

func (m *LuaArenaShop) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaArenaShop) GetItemID() int32 {
	if m != nil && m.ItemID != nil {
		return *m.ItemID
	}
	return 0
}

func (m *LuaArenaShop) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

func (m *LuaArenaShop) GetCostType() int32 {
	if m != nil && m.CostType != nil {
		return *m.CostType
	}
	return 0
}

func (m *LuaArenaShop) GetPrice() int32 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

// Excel:avatar表情.xls sheet:avatar_config
type LuaAvatarConfig struct {
	ShopID               *int32   `protobuf:"zigzag32,1,opt,name=shopID" json:"shopID,omitempty"`
	Interval             *int32   `protobuf:"zigzag32,2,opt,name=interval" json:"interval,omitempty"`
	Cost                 *int32   `protobuf:"zigzag32,3,opt,name=cost" json:"cost,omitempty"`
	Limit                *int32   `protobuf:"zigzag32,4,opt,name=limit" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaAvatarConfig) Reset()         { *m = LuaAvatarConfig{} }
func (m *LuaAvatarConfig) String() string { return proto.CompactTextString(m) }
func (*LuaAvatarConfig) ProtoMessage()    {}
func (*LuaAvatarConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{62}
}
func (m *LuaAvatarConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaAvatarConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaAvatarConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaAvatarConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaAvatarConfig.Merge(m, src)
}
func (m *LuaAvatarConfig) XXX_Size() int {
	return m.Size()
}
func (m *LuaAvatarConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaAvatarConfig.DiscardUnknown(m)
}

var xxx_messageInfo_LuaAvatarConfig proto.InternalMessageInfo

func (m *LuaAvatarConfig) GetShopID() int32 {
	if m != nil && m.ShopID != nil {
		return *m.ShopID
	}
	return 0
}

func (m *LuaAvatarConfig) GetInterval() int32 {
	if m != nil && m.Interval != nil {
		return *m.Interval
	}
	return 0
}

func (m *LuaAvatarConfig) GetCost() int32 {
	if m != nil && m.Cost != nil {
		return *m.Cost
	}
	return 0
}

func (m *LuaAvatarConfig) GetLimit() int32 {
	if m != nil && m.Limit != nil {
		return *m.Limit
	}
	return 0
}

// Excel:pet宠物.xls sheet:宠物等级
type LuaPetLevel struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	Level                *int32   `protobuf:"zigzag32,2,opt,name=level" json:"level,omitempty"`
	Exp                  *int32   `protobuf:"zigzag32,3,opt,name=exp" json:"exp,omitempty"`
	CritProb             *int32   `protobuf:"zigzag32,4,opt,name=critProb" json:"critProb,omitempty"`
	Atk                  *int32   `protobuf:"zigzag32,5,opt,name=atk" json:"atk,omitempty"`
	Def                  *int32   `protobuf:"zigzag32,6,opt,name=def" json:"def,omitempty"`
	Hp                   *int32   `protobuf:"zigzag32,7,opt,name=hp" json:"hp,omitempty"`
	Crit                 *int32   `protobuf:"zigzag32,8,opt,name=crit" json:"crit,omitempty"`
	Block                *int32   `protobuf:"zigzag32,9,opt,name=block" json:"block,omitempty"`
	Speed                *int32   `protobuf:"zigzag32,10,opt,name=speed" json:"speed,omitempty"`
	Act                  *int32   `protobuf:"zigzag32,11,opt,name=act" json:"act,omitempty"`
	AtkLimit             *int32   `protobuf:"zigzag32,12,opt,name=atkLimit" json:"atkLimit,omitempty"`
	DefLimit             *int32   `protobuf:"zigzag32,13,opt,name=defLimit" json:"defLimit,omitempty"`
	HpLimit              *int32   `protobuf:"zigzag32,14,opt,name=hpLimit" json:"hpLimit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaPetLevel) Reset()         { *m = LuaPetLevel{} }
func (m *LuaPetLevel) String() string { return proto.CompactTextString(m) }
func (*LuaPetLevel) ProtoMessage()    {}
func (*LuaPetLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{63}
}
func (m *LuaPetLevel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaPetLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaPetLevel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaPetLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaPetLevel.Merge(m, src)
}
func (m *LuaPetLevel) XXX_Size() int {
	return m.Size()
}
func (m *LuaPetLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaPetLevel.DiscardUnknown(m)
}

var xxx_messageInfo_LuaPetLevel proto.InternalMessageInfo

func (m *LuaPetLevel) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaPetLevel) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaPetLevel) GetExp() int32 {
	if m != nil && m.Exp != nil {
		return *m.Exp
	}
	return 0
}

func (m *LuaPetLevel) GetCritProb() int32 {
	if m != nil && m.CritProb != nil {
		return *m.CritProb
	}
	return 0
}

func (m *LuaPetLevel) GetAtk() int32 {
	if m != nil && m.Atk != nil {
		return *m.Atk
	}
	return 0
}

func (m *LuaPetLevel) GetDef() int32 {
	if m != nil && m.Def != nil {
		return *m.Def
	}
	return 0
}

func (m *LuaPetLevel) GetHp() int32 {
	if m != nil && m.Hp != nil {
		return *m.Hp
	}
	return 0
}

func (m *LuaPetLevel) GetCrit() int32 {
	if m != nil && m.Crit != nil {
		return *m.Crit
	}
	return 0
}

func (m *LuaPetLevel) GetBlock() int32 {
	if m != nil && m.Block != nil {
		return *m.Block
	}
	return 0
}

func (m *LuaPetLevel) GetSpeed() int32 {
	if m != nil && m.Speed != nil {
		return *m.Speed
	}
	return 0
}

func (m *LuaPetLevel) GetAct() int32 {
	if m != nil && m.Act != nil {
		return *m.Act
	}
	return 0
}

func (m *LuaPetLevel) GetAtkLimit() int32 {
	if m != nil && m.AtkLimit != nil {
		return *m.AtkLimit
	}
	return 0
}

func (m *LuaPetLevel) GetDefLimit() int32 {
	if m != nil && m.DefLimit != nil {
		return *m.DefLimit
	}
	return 0
}

func (m *LuaPetLevel) GetHpLimit() int32 {
	if m != nil && m.HpLimit != nil {
		return *m.HpLimit
	}
	return 0
}

// Excel:function功能表.xls sheet:功能开放
type LuaFunctionOpen struct {
	Id                   *int32                  `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	Index                *int32                  `protobuf:"zigzag32,2,opt,name=index" json:"index,omitempty"`
	NameID               []byte                  `protobuf:"bytes,3,opt,name=nameID" json:"nameID,omitempty"`
	Level                *int32                  `protobuf:"zigzag32,4,opt,name=level" json:"level,omitempty"`
	Vip                  *int32                  `protobuf:"zigzag32,5,opt,name=vip" json:"vip,omitempty"`
	TaskList             []int32                 `protobuf:"zigzag32,6,rep,name=taskList" json:"taskList,omitempty"`
	RiskList             []*FunctionopenRiskInfo `protobuf:"bytes,7,rep,name=riskList" json:"riskList,omitempty"`
	Icon                 []byte                  `protobuf:"bytes,8,opt,name=icon" json:"icon,omitempty"`
	TipPicList           [][]byte                `protobuf:"bytes,9,rep,name=tipPicList" json:"tipPicList,omitempty"`
	TipTextID            []byte                  `protobuf:"bytes,10,opt,name=tipTextID" json:"tipTextID,omitempty"`
	TipTextList          [][]byte                `protobuf:"bytes,11,rep,name=tipTextList" json:"tipTextList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *LuaFunctionOpen) Reset()         { *m = LuaFunctionOpen{} }
func (m *LuaFunctionOpen) String() string { return proto.CompactTextString(m) }
func (*LuaFunctionOpen) ProtoMessage()    {}
func (*LuaFunctionOpen) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{64}
}
func (m *LuaFunctionOpen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaFunctionOpen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaFunctionOpen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaFunctionOpen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaFunctionOpen.Merge(m, src)
}
func (m *LuaFunctionOpen) XXX_Size() int {
	return m.Size()
}
func (m *LuaFunctionOpen) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaFunctionOpen.DiscardUnknown(m)
}

var xxx_messageInfo_LuaFunctionOpen proto.InternalMessageInfo

func (m *LuaFunctionOpen) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaFunctionOpen) GetIndex() int32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *LuaFunctionOpen) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaFunctionOpen) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaFunctionOpen) GetVip() int32 {
	if m != nil && m.Vip != nil {
		return *m.Vip
	}
	return 0
}

func (m *LuaFunctionOpen) GetTaskList() []int32 {
	if m != nil {
		return m.TaskList
	}
	return nil
}

func (m *LuaFunctionOpen) GetRiskList() []*FunctionopenRiskInfo {
	if m != nil {
		return m.RiskList
	}
	return nil
}

func (m *LuaFunctionOpen) GetIcon() []byte {
	if m != nil {
		return m.Icon
	}
	return nil
}

func (m *LuaFunctionOpen) GetTipPicList() [][]byte {
	if m != nil {
		return m.TipPicList
	}
	return nil
}

func (m *LuaFunctionOpen) GetTipTextID() []byte {
	if m != nil {
		return m.TipTextID
	}
	return nil
}

func (m *LuaFunctionOpen) GetTipTextList() [][]byte {
	if m != nil {
		return m.TipTextList
	}
	return nil
}

// Excel:task任务表.xls sheet:任务类型定义
type LuaMainTaskModule struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	ModuleType           *int32   `protobuf:"zigzag32,2,opt,name=moduleType" json:"moduleType,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaMainTaskModule) Reset()         { *m = LuaMainTaskModule{} }
func (m *LuaMainTaskModule) String() string { return proto.CompactTextString(m) }
func (*LuaMainTaskModule) ProtoMessage()    {}
func (*LuaMainTaskModule) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{65}
}
func (m *LuaMainTaskModule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaMainTaskModule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaMainTaskModule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaMainTaskModule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaMainTaskModule.Merge(m, src)
}
func (m *LuaMainTaskModule) XXX_Size() int {
	return m.Size()
}
func (m *LuaMainTaskModule) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaMainTaskModule.DiscardUnknown(m)
}

var xxx_messageInfo_LuaMainTaskModule proto.InternalMessageInfo

func (m *LuaMainTaskModule) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaMainTaskModule) GetModuleType() int32 {
	if m != nil && m.ModuleType != nil {
		return *m.ModuleType
	}
	return 0
}

// Excel:家园表.xls sheet:仓库表
type LuaHouseStorage struct {
	Id                   *int32      `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	MaxCount             *int32      `protobuf:"zigzag32,2,opt,name=maxCount" json:"maxCount,omitempty"`
	CostItem             *ItemConfig `protobuf:"bytes,3,opt,name=costItem" json:"costItem,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *LuaHouseStorage) Reset()         { *m = LuaHouseStorage{} }
func (m *LuaHouseStorage) String() string { return proto.CompactTextString(m) }
func (*LuaHouseStorage) ProtoMessage()    {}
func (*LuaHouseStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{66}
}
func (m *LuaHouseStorage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaHouseStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaHouseStorage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaHouseStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaHouseStorage.Merge(m, src)
}
func (m *LuaHouseStorage) XXX_Size() int {
	return m.Size()
}
func (m *LuaHouseStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaHouseStorage.DiscardUnknown(m)
}

var xxx_messageInfo_LuaHouseStorage proto.InternalMessageInfo

func (m *LuaHouseStorage) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaHouseStorage) GetMaxCount() int32 {
	if m != nil && m.MaxCount != nil {
		return *m.MaxCount
	}
	return 0
}

func (m *LuaHouseStorage) GetCostItem() *ItemConfig {
	if m != nil {
		return m.CostItem
	}
	return nil
}

// Excel:购买消耗表.xls sheet:购买比特币表
type LuaBuyBitcoin struct {
	Id                   *int32      `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	BuyItem              *ItemConfig `protobuf:"bytes,2,opt,name=buyItem" json:"buyItem,omitempty"`
	CostIem              *ItemConfig `protobuf:"bytes,3,opt,name=costIem" json:"costIem,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *LuaBuyBitcoin) Reset()         { *m = LuaBuyBitcoin{} }
func (m *LuaBuyBitcoin) String() string { return proto.CompactTextString(m) }
func (*LuaBuyBitcoin) ProtoMessage()    {}
func (*LuaBuyBitcoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{67}
}
func (m *LuaBuyBitcoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaBuyBitcoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaBuyBitcoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaBuyBitcoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaBuyBitcoin.Merge(m, src)
}
func (m *LuaBuyBitcoin) XXX_Size() int {
	return m.Size()
}
func (m *LuaBuyBitcoin) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaBuyBitcoin.DiscardUnknown(m)
}

var xxx_messageInfo_LuaBuyBitcoin proto.InternalMessageInfo

func (m *LuaBuyBitcoin) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaBuyBitcoin) GetBuyItem() *ItemConfig {
	if m != nil {
		return m.BuyItem
	}
	return nil
}

func (m *LuaBuyBitcoin) GetCostIem() *ItemConfig {
	if m != nil {
		return m.CostIem
	}
	return nil
}

// Excel:石中剑配置表.xls sheet:石中剑武器包
type LuaSword struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	MinLevel             *int32   `protobuf:"zigzag32,2,opt,name=minLevel" json:"minLevel,omitempty"`
	MaxLevel             *int32   `protobuf:"zigzag32,3,opt,name=maxLevel" json:"maxLevel,omitempty"`
	BaseBagID            *int32   `protobuf:"zigzag32,4,opt,name=baseBagID" json:"baseBagID,omitempty"`
	GodBagID             *int32   `protobuf:"zigzag32,5,opt,name=godBagID" json:"godBagID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaSword) Reset()         { *m = LuaSword{} }
func (m *LuaSword) String() string { return proto.CompactTextString(m) }
func (*LuaSword) ProtoMessage()    {}
func (*LuaSword) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{68}
}
func (m *LuaSword) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaSword) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaSword.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaSword) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaSword.Merge(m, src)
}
func (m *LuaSword) XXX_Size() int {
	return m.Size()
}
func (m *LuaSword) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaSword.DiscardUnknown(m)
}

var xxx_messageInfo_LuaSword proto.InternalMessageInfo

func (m *LuaSword) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaSword) GetMinLevel() int32 {
	if m != nil && m.MinLevel != nil {
		return *m.MinLevel
	}
	return 0
}

func (m *LuaSword) GetMaxLevel() int32 {
	if m != nil && m.MaxLevel != nil {
		return *m.MaxLevel
	}
	return 0
}

func (m *LuaSword) GetBaseBagID() int32 {
	if m != nil && m.BaseBagID != nil {
		return *m.BaseBagID
	}
	return 0
}

func (m *LuaSword) GetGodBagID() int32 {
	if m != nil && m.GodBagID != nil {
		return *m.GodBagID
	}
	return 0
}

// Excel:竞技场表.xls sheet:历史最高排名奖励表
type LuaArenaHistoryRank struct {
	Rank                 *int32        `protobuf:"zigzag32,1,opt,name=rank" json:"rank,omitempty"`
	RewardList           []*ItemConfig `protobuf:"bytes,2,rep,name=rewardList" json:"rewardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaArenaHistoryRank) Reset()         { *m = LuaArenaHistoryRank{} }
func (m *LuaArenaHistoryRank) String() string { return proto.CompactTextString(m) }
func (*LuaArenaHistoryRank) ProtoMessage()    {}
func (*LuaArenaHistoryRank) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{69}
}
func (m *LuaArenaHistoryRank) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaArenaHistoryRank) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaArenaHistoryRank.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaArenaHistoryRank) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaArenaHistoryRank.Merge(m, src)
}
func (m *LuaArenaHistoryRank) XXX_Size() int {
	return m.Size()
}
func (m *LuaArenaHistoryRank) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaArenaHistoryRank.DiscardUnknown(m)
}

var xxx_messageInfo_LuaArenaHistoryRank proto.InternalMessageInfo

func (m *LuaArenaHistoryRank) GetRank() int32 {
	if m != nil && m.Rank != nil {
		return *m.Rank
	}
	return 0
}

func (m *LuaArenaHistoryRank) GetRewardList() []*ItemConfig {
	if m != nil {
		return m.RewardList
	}
	return nil
}

// Excel:出生数据.xls sheet:出生表
type LuaBorn struct {
	Id                   *int32        `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	SceneID              *int32        `protobuf:"zigzag32,2,opt,name=sceneID" json:"sceneID,omitempty"`
	Gold                 *int32        `protobuf:"zigzag32,3,opt,name=gold" json:"gold,omitempty"`
	Stamina              *int32        `protobuf:"zigzag32,4,opt,name=stamina" json:"stamina,omitempty"`
	Diamond              *int32        `protobuf:"zigzag32,5,opt,name=diamond" json:"diamond,omitempty"`
	Level                *int32        `protobuf:"zigzag32,6,opt,name=level" json:"level,omitempty"`
	SkillPoint           *int32        `protobuf:"zigzag32,7,opt,name=skillPoint" json:"skillPoint,omitempty"`
	Vip                  *int32        `protobuf:"zigzag32,8,opt,name=vip" json:"vip,omitempty"`
	ItemList             []*ItemConfig `protobuf:"bytes,9,rep,name=itemList" json:"itemList,omitempty"`
	FaceList             []*FaceConfig `protobuf:"bytes,10,rep,name=faceList" json:"faceList,omitempty"`
	SuitList             []*SuitConfig `protobuf:"bytes,11,rep,name=suitList" json:"suitList,omitempty"`
	CarList              []*ItemConfig `protobuf:"bytes,12,rep,name=carList" json:"carList,omitempty"`
	InteractList         []int32       `protobuf:"zigzag32,13,rep,name=interactList" json:"interactList,omitempty"`
	LearnSkillList       []int32       `protobuf:"zigzag32,14,rep,name=learnSkillList" json:"learnSkillList,omitempty"`
	DressSkillList       []int32       `protobuf:"zigzag32,15,rep,name=dressSkillList" json:"dressSkillList,omitempty"`
	PetIdList            []int32       `protobuf:"zigzag32,16,rep,name=petIdList" json:"petIdList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaBorn) Reset()         { *m = LuaBorn{} }
func (m *LuaBorn) String() string { return proto.CompactTextString(m) }
func (*LuaBorn) ProtoMessage()    {}
func (*LuaBorn) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{70}
}
func (m *LuaBorn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaBorn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaBorn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaBorn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaBorn.Merge(m, src)
}
func (m *LuaBorn) XXX_Size() int {
	return m.Size()
}
func (m *LuaBorn) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaBorn.DiscardUnknown(m)
}

var xxx_messageInfo_LuaBorn proto.InternalMessageInfo

func (m *LuaBorn) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaBorn) GetSceneID() int32 {
	if m != nil && m.SceneID != nil {
		return *m.SceneID
	}
	return 0
}

func (m *LuaBorn) GetGold() int32 {
	if m != nil && m.Gold != nil {
		return *m.Gold
	}
	return 0
}

func (m *LuaBorn) GetStamina() int32 {
	if m != nil && m.Stamina != nil {
		return *m.Stamina
	}
	return 0
}

func (m *LuaBorn) GetDiamond() int32 {
	if m != nil && m.Diamond != nil {
		return *m.Diamond
	}
	return 0
}

func (m *LuaBorn) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaBorn) GetSkillPoint() int32 {
	if m != nil && m.SkillPoint != nil {
		return *m.SkillPoint
	}
	return 0
}

func (m *LuaBorn) GetVip() int32 {
	if m != nil && m.Vip != nil {
		return *m.Vip
	}
	return 0
}

func (m *LuaBorn) GetItemList() []*ItemConfig {
	if m != nil {
		return m.ItemList
	}
	return nil
}

func (m *LuaBorn) GetFaceList() []*FaceConfig {
	if m != nil {
		return m.FaceList
	}
	return nil
}

func (m *LuaBorn) GetSuitList() []*SuitConfig {
	if m != nil {
		return m.SuitList
	}
	return nil
}

func (m *LuaBorn) GetCarList() []*ItemConfig {
	if m != nil {
		return m.CarList
	}
	return nil
}

func (m *LuaBorn) GetInteractList() []int32 {
	if m != nil {
		return m.InteractList
	}
	return nil
}

func (m *LuaBorn) GetLearnSkillList() []int32 {
	if m != nil {
		return m.LearnSkillList
	}
	return nil
}

func (m *LuaBorn) GetDressSkillList() []int32 {
	if m != nil {
		return m.DressSkillList
	}
	return nil
}

func (m *LuaBorn) GetPetIdList() []int32 {
	if m != nil {
		return m.PetIdList
	}
	return nil
}

// Excel:sign签到.xls sheet:补签花费
type LuaSignCost struct {
	Count                *int32   `protobuf:"zigzag32,1,opt,name=count" json:"count,omitempty"`
	Cost                 *int32   `protobuf:"zigzag32,2,opt,name=cost" json:"cost,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaSignCost) Reset()         { *m = LuaSignCost{} }
func (m *LuaSignCost) String() string { return proto.CompactTextString(m) }
func (*LuaSignCost) ProtoMessage()    {}
func (*LuaSignCost) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{71}
}
func (m *LuaSignCost) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaSignCost) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaSignCost.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaSignCost) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaSignCost.Merge(m, src)
}
func (m *LuaSignCost) XXX_Size() int {
	return m.Size()
}
func (m *LuaSignCost) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaSignCost.DiscardUnknown(m)
}

var xxx_messageInfo_LuaSignCost proto.InternalMessageInfo

func (m *LuaSignCost) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *LuaSignCost) GetCost() int32 {
	if m != nil && m.Cost != nil {
		return *m.Cost
	}
	return 0
}

// Excel:小游戏表.xls sheet:小游戏表
type LuaMinigame struct {
	Id                   *int32      `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	SceneID              *int32      `protobuf:"zigzag32,2,opt,name=sceneID" json:"sceneID,omitempty"`
	NameID               []byte      `protobuf:"bytes,3,opt,name=nameID" json:"nameID,omitempty"`
	DesID                []byte      `protobuf:"bytes,4,opt,name=desID" json:"desID,omitempty"`
	Icon                 *int32      `protobuf:"zigzag32,5,opt,name=icon" json:"icon,omitempty"`
	Border               *int32      `protobuf:"zigzag32,6,opt,name=border" json:"border,omitempty"`
	Hide                 *int32      `protobuf:"zigzag32,7,opt,name=hide" json:"hide,omitempty"`
	CostCurrency         *ItemConfig `protobuf:"bytes,8,opt,name=costCurrency" json:"costCurrency,omitempty"`
	Music                []byte      `protobuf:"bytes,9,opt,name=music" json:"music,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *LuaMinigame) Reset()         { *m = LuaMinigame{} }
func (m *LuaMinigame) String() string { return proto.CompactTextString(m) }
func (*LuaMinigame) ProtoMessage()    {}
func (*LuaMinigame) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{72}
}
func (m *LuaMinigame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaMinigame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaMinigame.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaMinigame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaMinigame.Merge(m, src)
}
func (m *LuaMinigame) XXX_Size() int {
	return m.Size()
}
func (m *LuaMinigame) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaMinigame.DiscardUnknown(m)
}

var xxx_messageInfo_LuaMinigame proto.InternalMessageInfo

func (m *LuaMinigame) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaMinigame) GetSceneID() int32 {
	if m != nil && m.SceneID != nil {
		return *m.SceneID
	}
	return 0
}

func (m *LuaMinigame) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaMinigame) GetDesID() []byte {
	if m != nil {
		return m.DesID
	}
	return nil
}

func (m *LuaMinigame) GetIcon() int32 {
	if m != nil && m.Icon != nil {
		return *m.Icon
	}
	return 0
}

func (m *LuaMinigame) GetBorder() int32 {
	if m != nil && m.Border != nil {
		return *m.Border
	}
	return 0
}

func (m *LuaMinigame) GetHide() int32 {
	if m != nil && m.Hide != nil {
		return *m.Hide
	}
	return 0
}

func (m *LuaMinigame) GetCostCurrency() *ItemConfig {
	if m != nil {
		return m.CostCurrency
	}
	return nil
}

func (m *LuaMinigame) GetMusic() []byte {
	if m != nil {
		return m.Music
	}
	return nil
}

// Excel:二次元配置表.xls sheet:二次元奖励表
type LuaGuadraticReward struct {
	ID                   *int32            `protobuf:"zigzag32,1,opt,name=ID" json:"ID,omitempty"`
	SingleDayRewardList  []*ItemListConfig `protobuf:"bytes,2,rep,name=singleDayRewardList" json:"singleDayRewardList,omitempty"`
	DoubleDayRewardList  []*ItemListConfig `protobuf:"bytes,3,rep,name=doubleDayRewardList" json:"doubleDayRewardList,omitempty"`
	SingleDayPercent     []int32           `protobuf:"zigzag32,4,rep,name=singleDayPercent" json:"singleDayPercent,omitempty"`
	DoubleDayPercent     []int32           `protobuf:"zigzag32,5,rep,name=doubleDayPercent" json:"doubleDayPercent,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *LuaGuadraticReward) Reset()         { *m = LuaGuadraticReward{} }
func (m *LuaGuadraticReward) String() string { return proto.CompactTextString(m) }
func (*LuaGuadraticReward) ProtoMessage()    {}
func (*LuaGuadraticReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{73}
}
func (m *LuaGuadraticReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaGuadraticReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaGuadraticReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaGuadraticReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaGuadraticReward.Merge(m, src)
}
func (m *LuaGuadraticReward) XXX_Size() int {
	return m.Size()
}
func (m *LuaGuadraticReward) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaGuadraticReward.DiscardUnknown(m)
}

var xxx_messageInfo_LuaGuadraticReward proto.InternalMessageInfo

func (m *LuaGuadraticReward) GetID() int32 {
	if m != nil && m.ID != nil {
		return *m.ID
	}
	return 0
}

func (m *LuaGuadraticReward) GetSingleDayRewardList() []*ItemListConfig {
	if m != nil {
		return m.SingleDayRewardList
	}
	return nil
}

func (m *LuaGuadraticReward) GetDoubleDayRewardList() []*ItemListConfig {
	if m != nil {
		return m.DoubleDayRewardList
	}
	return nil
}

func (m *LuaGuadraticReward) GetSingleDayPercent() []int32 {
	if m != nil {
		return m.SingleDayPercent
	}
	return nil
}

func (m *LuaGuadraticReward) GetDoubleDayPercent() []int32 {
	if m != nil {
		return m.DoubleDayPercent
	}
	return nil
}

// Excel:购买消耗表.xls sheet:精英副本重置次数消耗表
type LuaRiskFightReset struct {
	Id                   *int32      `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	CostIem              *ItemConfig `protobuf:"bytes,2,opt,name=costIem" json:"costIem,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *LuaRiskFightReset) Reset()         { *m = LuaRiskFightReset{} }
func (m *LuaRiskFightReset) String() string { return proto.CompactTextString(m) }
func (*LuaRiskFightReset) ProtoMessage()    {}
func (*LuaRiskFightReset) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{74}
}
func (m *LuaRiskFightReset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaRiskFightReset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaRiskFightReset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaRiskFightReset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaRiskFightReset.Merge(m, src)
}
func (m *LuaRiskFightReset) XXX_Size() int {
	return m.Size()
}
func (m *LuaRiskFightReset) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaRiskFightReset.DiscardUnknown(m)
}

var xxx_messageInfo_LuaRiskFightReset proto.InternalMessageInfo

func (m *LuaRiskFightReset) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaRiskFightReset) GetCostIem() *ItemConfig {
	if m != nil {
		return m.CostIem
	}
	return nil
}

// Excel:c彩蛋表.xls sheet:彩蛋表
type LuaEasterEgg struct {
	Id                   *int32        `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	SceneID              *int32        `protobuf:"zigzag32,2,opt,name=sceneID" json:"sceneID,omitempty"`
	NpcID                *int32        `protobuf:"zigzag32,3,opt,name=npcID" json:"npcID,omitempty"`
	NeedTouchCount       *int32        `protobuf:"zigzag32,4,opt,name=needTouchCount" json:"needTouchCount,omitempty"`
	AffectCount          *int32        `protobuf:"zigzag32,5,opt,name=affectCount" json:"affectCount,omitempty"`
	Probability          *int32        `protobuf:"zigzag32,6,opt,name=probability" json:"probability,omitempty"`
	RewardList           []*ItemConfig `protobuf:"bytes,7,rep,name=rewardList" json:"rewardList,omitempty"`
	CdTime               *int32        `protobuf:"zigzag32,8,opt,name=cdTime" json:"cdTime,omitempty"`
	DayGetCount          *int32        `protobuf:"zigzag32,9,opt,name=dayGetCount" json:"dayGetCount,omitempty"`
	FirstRewardList      []*ItemConfig `protobuf:"bytes,10,rep,name=firstRewardList" json:"firstRewardList,omitempty"`
	TouchAnimName        []byte        `protobuf:"bytes,11,opt,name=touchAnimName" json:"touchAnimName,omitempty"`
	TouchSound           []byte        `protobuf:"bytes,12,opt,name=touchSound" json:"touchSound,omitempty"`
	SuccessAnimName      []byte        `protobuf:"bytes,13,opt,name=successAnimName" json:"successAnimName,omitempty"`
	SuccessSound         []byte        `protobuf:"bytes,14,opt,name=successSound" json:"successSound,omitempty"`
	GlobalType           *int32        `protobuf:"zigzag32,15,opt,name=globalType" json:"globalType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaEasterEgg) Reset()         { *m = LuaEasterEgg{} }
func (m *LuaEasterEgg) String() string { return proto.CompactTextString(m) }
func (*LuaEasterEgg) ProtoMessage()    {}
func (*LuaEasterEgg) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{75}
}
func (m *LuaEasterEgg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaEasterEgg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaEasterEgg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaEasterEgg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaEasterEgg.Merge(m, src)
}
func (m *LuaEasterEgg) XXX_Size() int {
	return m.Size()
}
func (m *LuaEasterEgg) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaEasterEgg.DiscardUnknown(m)
}

var xxx_messageInfo_LuaEasterEgg proto.InternalMessageInfo

func (m *LuaEasterEgg) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaEasterEgg) GetSceneID() int32 {
	if m != nil && m.SceneID != nil {
		return *m.SceneID
	}
	return 0
}

func (m *LuaEasterEgg) GetNpcID() int32 {
	if m != nil && m.NpcID != nil {
		return *m.NpcID
	}
	return 0
}

func (m *LuaEasterEgg) GetNeedTouchCount() int32 {
	if m != nil && m.NeedTouchCount != nil {
		return *m.NeedTouchCount
	}
	return 0
}

func (m *LuaEasterEgg) GetAffectCount() int32 {
	if m != nil && m.AffectCount != nil {
		return *m.AffectCount
	}
	return 0
}

func (m *LuaEasterEgg) GetProbability() int32 {
	if m != nil && m.Probability != nil {
		return *m.Probability
	}
	return 0
}

func (m *LuaEasterEgg) GetRewardList() []*ItemConfig {
	if m != nil {
		return m.RewardList
	}
	return nil
}

func (m *LuaEasterEgg) GetCdTime() int32 {
	if m != nil && m.CdTime != nil {
		return *m.CdTime
	}
	return 0
}

func (m *LuaEasterEgg) GetDayGetCount() int32 {
	if m != nil && m.DayGetCount != nil {
		return *m.DayGetCount
	}
	return 0
}

func (m *LuaEasterEgg) GetFirstRewardList() []*ItemConfig {
	if m != nil {
		return m.FirstRewardList
	}
	return nil
}

func (m *LuaEasterEgg) GetTouchAnimName() []byte {
	if m != nil {
		return m.TouchAnimName
	}
	return nil
}

func (m *LuaEasterEgg) GetTouchSound() []byte {
	if m != nil {
		return m.TouchSound
	}
	return nil
}

func (m *LuaEasterEgg) GetSuccessAnimName() []byte {
	if m != nil {
		return m.SuccessAnimName
	}
	return nil
}

func (m *LuaEasterEgg) GetSuccessSound() []byte {
	if m != nil {
		return m.SuccessSound
	}
	return nil
}

func (m *LuaEasterEgg) GetGlobalType() int32 {
	if m != nil && m.GlobalType != nil {
		return *m.GlobalType
	}
	return 0
}

// Excel:equip装备.xls sheet:装备制造
type LuaEquipMake struct {
	Id                   *int32        `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	OpenLevel            *int32        `protobuf:"zigzag32,2,opt,name=openLevel" json:"openLevel,omitempty"`
	Level                *int32        `protobuf:"zigzag32,3,opt,name=level" json:"level,omitempty"`
	Quality              *int32        `protobuf:"zigzag32,4,opt,name=quality" json:"quality,omitempty"`
	Site                 *int32        `protobuf:"zigzag32,5,opt,name=site" json:"site,omitempty"`
	CaseOneItemList      []*ItemConfig `protobuf:"bytes,6,rep,name=caseOneItemList" json:"caseOneItemList,omitempty"`
	CaseTwoItemList      []*ItemConfig `protobuf:"bytes,7,rep,name=caseTwoItemList" json:"caseTwoItemList,omitempty"`
	EquipIdOne           *int32        `protobuf:"zigzag32,8,opt,name=equipIdOne" json:"equipIdOne,omitempty"`
	EquipIdTwo           *int32        `protobuf:"zigzag32,9,opt,name=equipIdTwo" json:"equipIdTwo,omitempty"`
	Prop                 *int32        `protobuf:"zigzag32,10,opt,name=prop" json:"prop,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaEquipMake) Reset()         { *m = LuaEquipMake{} }
func (m *LuaEquipMake) String() string { return proto.CompactTextString(m) }
func (*LuaEquipMake) ProtoMessage()    {}
func (*LuaEquipMake) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{76}
}
func (m *LuaEquipMake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaEquipMake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaEquipMake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaEquipMake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaEquipMake.Merge(m, src)
}
func (m *LuaEquipMake) XXX_Size() int {
	return m.Size()
}
func (m *LuaEquipMake) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaEquipMake.DiscardUnknown(m)
}

var xxx_messageInfo_LuaEquipMake proto.InternalMessageInfo

func (m *LuaEquipMake) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaEquipMake) GetOpenLevel() int32 {
	if m != nil && m.OpenLevel != nil {
		return *m.OpenLevel
	}
	return 0
}

func (m *LuaEquipMake) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaEquipMake) GetQuality() int32 {
	if m != nil && m.Quality != nil {
		return *m.Quality
	}
	return 0
}

func (m *LuaEquipMake) GetSite() int32 {
	if m != nil && m.Site != nil {
		return *m.Site
	}
	return 0
}

func (m *LuaEquipMake) GetCaseOneItemList() []*ItemConfig {
	if m != nil {
		return m.CaseOneItemList
	}
	return nil
}

func (m *LuaEquipMake) GetCaseTwoItemList() []*ItemConfig {
	if m != nil {
		return m.CaseTwoItemList
	}
	return nil
}

func (m *LuaEquipMake) GetEquipIdOne() int32 {
	if m != nil && m.EquipIdOne != nil {
		return *m.EquipIdOne
	}
	return 0
}

func (m *LuaEquipMake) GetEquipIdTwo() int32 {
	if m != nil && m.EquipIdTwo != nil {
		return *m.EquipIdTwo
	}
	return 0
}

func (m *LuaEquipMake) GetProp() int32 {
	if m != nil && m.Prop != nil {
		return *m.Prop
	}
	return 0
}

// Excel:系统技能表.xls sheet:系统技能表
type LuaRoleSkill struct {
	Id                   *int32            `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte            `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	DesID                []byte            `protobuf:"bytes,3,opt,name=desID" json:"desID,omitempty"`
	SkillLevelList       []int32           `protobuf:"zigzag32,4,rep,name=skillLevelList" json:"skillLevelList,omitempty"`
	SpecialLevelList     []int32           `protobuf:"zigzag32,5,rep,name=specialLevelList" json:"specialLevelList,omitempty"`
	Type                 *int32            `protobuf:"zigzag32,6,opt,name=type" json:"type,omitempty"`
	Icon                 []byte            `protobuf:"bytes,7,opt,name=icon" json:"icon,omitempty"`
	OpenLevel            *int32            `protobuf:"zigzag32,8,opt,name=openLevel" json:"openLevel,omitempty"`
	LearnItemList        []*ItemConfig     `protobuf:"bytes,9,rep,name=learnItemList" json:"learnItemList,omitempty"`
	RateList             []int32           `protobuf:"zigzag32,10,rep,name=rateList" json:"rateList,omitempty"`
	ProfiList            []int32           `protobuf:"zigzag32,11,rep,name=profiList" json:"profiList,omitempty"`
	UpItemList           []*ItemListConfig `protobuf:"bytes,12,rep,name=upItemList" json:"upItemList,omitempty"`
	ShowType             *int32            `protobuf:"zigzag32,13,opt,name=showType" json:"showType,omitempty"`
	Quality              *int32            `protobuf:"zigzag32,14,opt,name=quality" json:"quality,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *LuaRoleSkill) Reset()         { *m = LuaRoleSkill{} }
func (m *LuaRoleSkill) String() string { return proto.CompactTextString(m) }
func (*LuaRoleSkill) ProtoMessage()    {}
func (*LuaRoleSkill) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{77}
}
func (m *LuaRoleSkill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaRoleSkill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaRoleSkill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaRoleSkill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaRoleSkill.Merge(m, src)
}
func (m *LuaRoleSkill) XXX_Size() int {
	return m.Size()
}
func (m *LuaRoleSkill) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaRoleSkill.DiscardUnknown(m)
}

var xxx_messageInfo_LuaRoleSkill proto.InternalMessageInfo

func (m *LuaRoleSkill) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaRoleSkill) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaRoleSkill) GetDesID() []byte {
	if m != nil {
		return m.DesID
	}
	return nil
}

func (m *LuaRoleSkill) GetSkillLevelList() []int32 {
	if m != nil {
		return m.SkillLevelList
	}
	return nil
}

func (m *LuaRoleSkill) GetSpecialLevelList() []int32 {
	if m != nil {
		return m.SpecialLevelList
	}
	return nil
}

func (m *LuaRoleSkill) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaRoleSkill) GetIcon() []byte {
	if m != nil {
		return m.Icon
	}
	return nil
}

func (m *LuaRoleSkill) GetOpenLevel() int32 {
	if m != nil && m.OpenLevel != nil {
		return *m.OpenLevel
	}
	return 0
}

func (m *LuaRoleSkill) GetLearnItemList() []*ItemConfig {
	if m != nil {
		return m.LearnItemList
	}
	return nil
}

func (m *LuaRoleSkill) GetRateList() []int32 {
	if m != nil {
		return m.RateList
	}
	return nil
}

func (m *LuaRoleSkill) GetProfiList() []int32 {
	if m != nil {
		return m.ProfiList
	}
	return nil
}

func (m *LuaRoleSkill) GetUpItemList() []*ItemListConfig {
	if m != nil {
		return m.UpItemList
	}
	return nil
}

func (m *LuaRoleSkill) GetShowType() int32 {
	if m != nil && m.ShowType != nil {
		return *m.ShowType
	}
	return 0
}

func (m *LuaRoleSkill) GetQuality() int32 {
	if m != nil && m.Quality != nil {
		return *m.Quality
	}
	return 0
}

// Excel:日常任务表.xls sheet:任务成长奖励表
type LuaDailyActivityGrowReward struct {
	Id                   *int32        `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	BaseReward           *ItemConfig   `protobuf:"bytes,2,opt,name=baseReward" json:"baseReward,omitempty"`
	RewardList           []*ItemConfig `protobuf:"bytes,3,rep,name=rewardList" json:"rewardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaDailyActivityGrowReward) Reset()         { *m = LuaDailyActivityGrowReward{} }
func (m *LuaDailyActivityGrowReward) String() string { return proto.CompactTextString(m) }
func (*LuaDailyActivityGrowReward) ProtoMessage()    {}
func (*LuaDailyActivityGrowReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{78}
}
func (m *LuaDailyActivityGrowReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaDailyActivityGrowReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaDailyActivityGrowReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaDailyActivityGrowReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaDailyActivityGrowReward.Merge(m, src)
}
func (m *LuaDailyActivityGrowReward) XXX_Size() int {
	return m.Size()
}
func (m *LuaDailyActivityGrowReward) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaDailyActivityGrowReward.DiscardUnknown(m)
}

var xxx_messageInfo_LuaDailyActivityGrowReward proto.InternalMessageInfo

func (m *LuaDailyActivityGrowReward) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaDailyActivityGrowReward) GetBaseReward() *ItemConfig {
	if m != nil {
		return m.BaseReward
	}
	return nil
}

func (m *LuaDailyActivityGrowReward) GetRewardList() []*ItemConfig {
	if m != nil {
		return m.RewardList
	}
	return nil
}

// Excel:equip装备.xls sheet:装备修复
type LuaEquipFix struct {
	Quality              *int32      `protobuf:"zigzag32,1,opt,name=quality" json:"quality,omitempty"`
	FixNeedItemId        *int32      `protobuf:"zigzag32,2,opt,name=fixNeedItemId" json:"fixNeedItemId,omitempty"`
	EveryNeedNum         *int32      `protobuf:"zigzag32,3,opt,name=everyNeedNum" json:"everyNeedNum,omitempty"`
	EveryNeedTime        *int32      `protobuf:"zigzag32,4,opt,name=everyNeedTime" json:"everyNeedTime,omitempty"`
	FastFixCost          *ItemConfig `protobuf:"bytes,5,opt,name=fastFixCost" json:"fastFixCost,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *LuaEquipFix) Reset()         { *m = LuaEquipFix{} }
func (m *LuaEquipFix) String() string { return proto.CompactTextString(m) }
func (*LuaEquipFix) ProtoMessage()    {}
func (*LuaEquipFix) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{79}
}
func (m *LuaEquipFix) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaEquipFix) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaEquipFix.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaEquipFix) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaEquipFix.Merge(m, src)
}
func (m *LuaEquipFix) XXX_Size() int {
	return m.Size()
}
func (m *LuaEquipFix) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaEquipFix.DiscardUnknown(m)
}

var xxx_messageInfo_LuaEquipFix proto.InternalMessageInfo

func (m *LuaEquipFix) GetQuality() int32 {
	if m != nil && m.Quality != nil {
		return *m.Quality
	}
	return 0
}

func (m *LuaEquipFix) GetFixNeedItemId() int32 {
	if m != nil && m.FixNeedItemId != nil {
		return *m.FixNeedItemId
	}
	return 0
}

func (m *LuaEquipFix) GetEveryNeedNum() int32 {
	if m != nil && m.EveryNeedNum != nil {
		return *m.EveryNeedNum
	}
	return 0
}

func (m *LuaEquipFix) GetEveryNeedTime() int32 {
	if m != nil && m.EveryNeedTime != nil {
		return *m.EveryNeedTime
	}
	return 0
}

func (m *LuaEquipFix) GetFastFixCost() *ItemConfig {
	if m != nil {
		return m.FastFixCost
	}
	return nil
}

// Excel:n扭蛋机.xls sheet:奖励包等级表
type LuaNiudanPackage struct {
	Id                   *int32         `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	LevelSection         *RandomSection `protobuf:"bytes,2,opt,name=level_section" json:"level_section,omitempty"`
	PackageList          []*ItemConfig  `protobuf:"bytes,3,rep,name=package_list" json:"package_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *LuaNiudanPackage) Reset()         { *m = LuaNiudanPackage{} }
func (m *LuaNiudanPackage) String() string { return proto.CompactTextString(m) }
func (*LuaNiudanPackage) ProtoMessage()    {}
func (*LuaNiudanPackage) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{80}
}
func (m *LuaNiudanPackage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaNiudanPackage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaNiudanPackage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaNiudanPackage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaNiudanPackage.Merge(m, src)
}
func (m *LuaNiudanPackage) XXX_Size() int {
	return m.Size()
}
func (m *LuaNiudanPackage) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaNiudanPackage.DiscardUnknown(m)
}

var xxx_messageInfo_LuaNiudanPackage proto.InternalMessageInfo

func (m *LuaNiudanPackage) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaNiudanPackage) GetLevelSection() *RandomSection {
	if m != nil {
		return m.LevelSection
	}
	return nil
}

func (m *LuaNiudanPackage) GetPackageList() []*ItemConfig {
	if m != nil {
		return m.PackageList
	}
	return nil
}

// Excel:场景表.xls sheet:传送门表
type LuaTransport struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte   `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	Pos                  *LuaPos  `protobuf:"bytes,3,opt,name=pos" json:"pos,omitempty"`
	ResType              *int32   `protobuf:"zigzag32,4,opt,name=resType" json:"resType,omitempty"`
	Res                  []byte   `protobuf:"bytes,5,opt,name=res" json:"res,omitempty"`
	IsFlipX              *int32   `protobuf:"zigzag32,6,opt,name=isFlipX" json:"isFlipX,omitempty"`
	IsFlipY              *int32   `protobuf:"zigzag32,7,opt,name=isFlipY" json:"isFlipY,omitempty"`
	Rotate               *int32   `protobuf:"zigzag32,8,opt,name=rotate" json:"rotate,omitempty"`
	TargetList           []int32  `protobuf:"zigzag32,9,rep,name=targetList" json:"targetList,omitempty"`
	UnlockRes            []byte   `protobuf:"bytes,10,opt,name=unlockRes" json:"unlockRes,omitempty"`
	UnlockPos            []int32  `protobuf:"zigzag32,11,rep,name=unlockPos" json:"unlockPos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaTransport) Reset()         { *m = LuaTransport{} }
func (m *LuaTransport) String() string { return proto.CompactTextString(m) }
func (*LuaTransport) ProtoMessage()    {}
func (*LuaTransport) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{81}
}
func (m *LuaTransport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaTransport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaTransport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaTransport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaTransport.Merge(m, src)
}
func (m *LuaTransport) XXX_Size() int {
	return m.Size()
}
func (m *LuaTransport) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaTransport.DiscardUnknown(m)
}

var xxx_messageInfo_LuaTransport proto.InternalMessageInfo

func (m *LuaTransport) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaTransport) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaTransport) GetPos() *LuaPos {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *LuaTransport) GetResType() int32 {
	if m != nil && m.ResType != nil {
		return *m.ResType
	}
	return 0
}

func (m *LuaTransport) GetRes() []byte {
	if m != nil {
		return m.Res
	}
	return nil
}

func (m *LuaTransport) GetIsFlipX() int32 {
	if m != nil && m.IsFlipX != nil {
		return *m.IsFlipX
	}
	return 0
}

func (m *LuaTransport) GetIsFlipY() int32 {
	if m != nil && m.IsFlipY != nil {
		return *m.IsFlipY
	}
	return 0
}

func (m *LuaTransport) GetRotate() int32 {
	if m != nil && m.Rotate != nil {
		return *m.Rotate
	}
	return 0
}

func (m *LuaTransport) GetTargetList() []int32 {
	if m != nil {
		return m.TargetList
	}
	return nil
}

func (m *LuaTransport) GetUnlockRes() []byte {
	if m != nil {
		return m.UnlockRes
	}
	return nil
}

func (m *LuaTransport) GetUnlockPos() []int32 {
	if m != nil {
		return m.UnlockPos
	}
	return nil
}

// Excel:二次元配置表.xls sheet:BOSS技能表
type LuaGuadraticBossSkill struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	AtkDistance          *int32   `protobuf:"zigzag32,2,opt,name=atkDistance" json:"atkDistance,omitempty"`
	Hurt                 *int32   `protobuf:"zigzag32,3,opt,name=hurt" json:"hurt,omitempty"`
	HurtRect             *LuaRect `protobuf:"bytes,4,opt,name=hurtRect" json:"hurtRect,omitempty"`
	AtkSound             []byte   `protobuf:"bytes,5,opt,name=atkSound" json:"atkSound,omitempty"`
	PreTime              *float32 `protobuf:"fixed32,6,opt,name=preTime" json:"preTime,omitempty"`
	AnimName             []byte   `protobuf:"bytes,7,opt,name=animName" json:"animName,omitempty"`
	EffectRes            []byte   `protobuf:"bytes,8,opt,name=effectRes" json:"effectRes,omitempty"`
	SelfEffectRes        []byte   `protobuf:"bytes,9,opt,name=selfEffectRes" json:"selfEffectRes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaGuadraticBossSkill) Reset()         { *m = LuaGuadraticBossSkill{} }
func (m *LuaGuadraticBossSkill) String() string { return proto.CompactTextString(m) }
func (*LuaGuadraticBossSkill) ProtoMessage()    {}
func (*LuaGuadraticBossSkill) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{82}
}
func (m *LuaGuadraticBossSkill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaGuadraticBossSkill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaGuadraticBossSkill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaGuadraticBossSkill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaGuadraticBossSkill.Merge(m, src)
}
func (m *LuaGuadraticBossSkill) XXX_Size() int {
	return m.Size()
}
func (m *LuaGuadraticBossSkill) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaGuadraticBossSkill.DiscardUnknown(m)
}

var xxx_messageInfo_LuaGuadraticBossSkill proto.InternalMessageInfo

func (m *LuaGuadraticBossSkill) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaGuadraticBossSkill) GetAtkDistance() int32 {
	if m != nil && m.AtkDistance != nil {
		return *m.AtkDistance
	}
	return 0
}

func (m *LuaGuadraticBossSkill) GetHurt() int32 {
	if m != nil && m.Hurt != nil {
		return *m.Hurt
	}
	return 0
}

func (m *LuaGuadraticBossSkill) GetHurtRect() *LuaRect {
	if m != nil {
		return m.HurtRect
	}
	return nil
}

func (m *LuaGuadraticBossSkill) GetAtkSound() []byte {
	if m != nil {
		return m.AtkSound
	}
	return nil
}

func (m *LuaGuadraticBossSkill) GetPreTime() float32 {
	if m != nil && m.PreTime != nil {
		return *m.PreTime
	}
	return 0
}

func (m *LuaGuadraticBossSkill) GetAnimName() []byte {
	if m != nil {
		return m.AnimName
	}
	return nil
}

func (m *LuaGuadraticBossSkill) GetEffectRes() []byte {
	if m != nil {
		return m.EffectRes
	}
	return nil
}

func (m *LuaGuadraticBossSkill) GetSelfEffectRes() []byte {
	if m != nil {
		return m.SelfEffectRes
	}
	return nil
}

// Excel:技能坑位解锁.xls sheet:技能坑位解锁
type LuaSkillHole struct {
	Id                   *int32        `protobuf:"zigzag32,1,opt,name=Id" json:"Id,omitempty"`
	UnlockItemList       []*ItemConfig `protobuf:"bytes,2,rep,name=unlockItemList" json:"unlockItemList,omitempty"`
	UnlockVipLevel       *int32        `protobuf:"zigzag32,3,opt,name=unlockVipLevel" json:"unlockVipLevel,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaSkillHole) Reset()         { *m = LuaSkillHole{} }
func (m *LuaSkillHole) String() string { return proto.CompactTextString(m) }
func (*LuaSkillHole) ProtoMessage()    {}
func (*LuaSkillHole) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{83}
}
func (m *LuaSkillHole) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaSkillHole) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaSkillHole.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaSkillHole) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaSkillHole.Merge(m, src)
}
func (m *LuaSkillHole) XXX_Size() int {
	return m.Size()
}
func (m *LuaSkillHole) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaSkillHole.DiscardUnknown(m)
}

var xxx_messageInfo_LuaSkillHole proto.InternalMessageInfo

func (m *LuaSkillHole) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaSkillHole) GetUnlockItemList() []*ItemConfig {
	if m != nil {
		return m.UnlockItemList
	}
	return nil
}

func (m *LuaSkillHole) GetUnlockVipLevel() int32 {
	if m != nil && m.UnlockVipLevel != nil {
		return *m.UnlockVipLevel
	}
	return 0
}

// Excel:f副本表.xls sheet:随机宝箱表
type LuaRandomBox struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	MinLevel             *int32   `protobuf:"zigzag32,2,opt,name=minLevel" json:"minLevel,omitempty"`
	MaxLevel             *int32   `protobuf:"zigzag32,3,opt,name=maxLevel" json:"maxLevel,omitempty"`
	RewardID             *int32   `protobuf:"zigzag32,4,opt,name=rewardID" json:"rewardID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaRandomBox) Reset()         { *m = LuaRandomBox{} }
func (m *LuaRandomBox) String() string { return proto.CompactTextString(m) }
func (*LuaRandomBox) ProtoMessage()    {}
func (*LuaRandomBox) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{84}
}
func (m *LuaRandomBox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaRandomBox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaRandomBox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaRandomBox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaRandomBox.Merge(m, src)
}
func (m *LuaRandomBox) XXX_Size() int {
	return m.Size()
}
func (m *LuaRandomBox) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaRandomBox.DiscardUnknown(m)
}

var xxx_messageInfo_LuaRandomBox proto.InternalMessageInfo

func (m *LuaRandomBox) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaRandomBox) GetMinLevel() int32 {
	if m != nil && m.MinLevel != nil {
		return *m.MinLevel
	}
	return 0
}

func (m *LuaRandomBox) GetMaxLevel() int32 {
	if m != nil && m.MaxLevel != nil {
		return *m.MaxLevel
	}
	return 0
}

func (m *LuaRandomBox) GetRewardID() int32 {
	if m != nil && m.RewardID != nil {
		return *m.RewardID
	}
	return 0
}

// Excel:道具商店表.xls sheet:通用商店表
type LuaCommonShop struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte   `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	TalkID               []byte   `protobuf:"bytes,3,opt,name=talkID" json:"talkID,omitempty"`
	ResType              *int32   `protobuf:"zigzag32,4,opt,name=resType" json:"resType,omitempty"`
	Icon                 []byte   `protobuf:"bytes,5,opt,name=icon" json:"icon,omitempty"`
	Scale                *float32 `protobuf:"fixed32,6,opt,name=scale" json:"scale,omitempty"`
	Pos                  *LuaPos  `protobuf:"bytes,7,opt,name=pos" json:"pos,omitempty"`
	Type                 *int32   `protobuf:"zigzag32,8,opt,name=type" json:"type,omitempty"`
	Period               *int32   `protobuf:"zigzag32,9,opt,name=period" json:"period,omitempty"`
	WeekdayList          []int32  `protobuf:"zigzag32,10,rep,name=weekdayList" json:"weekdayList,omitempty"`
	FixTimeList          []int32  `protobuf:"zigzag32,11,rep,name=fixTimeList" json:"fixTimeList,omitempty"`
	LimitTimeList        []int32  `protobuf:"zigzag32,12,rep,name=limitTimeList" json:"limitTimeList,omitempty"`
	PriceList            []int32  `protobuf:"zigzag32,13,rep,name=priceList" json:"priceList,omitempty"`
	UpdateDesID          []byte   `protobuf:"bytes,14,opt,name=updateDesID" json:"updateDesID,omitempty"`
	CellNum              *int32   `protobuf:"zigzag32,15,opt,name=cellNum" json:"cellNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaCommonShop) Reset()         { *m = LuaCommonShop{} }
func (m *LuaCommonShop) String() string { return proto.CompactTextString(m) }
func (*LuaCommonShop) ProtoMessage()    {}
func (*LuaCommonShop) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{85}
}
func (m *LuaCommonShop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaCommonShop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaCommonShop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaCommonShop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaCommonShop.Merge(m, src)
}
func (m *LuaCommonShop) XXX_Size() int {
	return m.Size()
}
func (m *LuaCommonShop) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaCommonShop.DiscardUnknown(m)
}

var xxx_messageInfo_LuaCommonShop proto.InternalMessageInfo

func (m *LuaCommonShop) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaCommonShop) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaCommonShop) GetTalkID() []byte {
	if m != nil {
		return m.TalkID
	}
	return nil
}

func (m *LuaCommonShop) GetResType() int32 {
	if m != nil && m.ResType != nil {
		return *m.ResType
	}
	return 0
}

func (m *LuaCommonShop) GetIcon() []byte {
	if m != nil {
		return m.Icon
	}
	return nil
}

func (m *LuaCommonShop) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return 0
}

func (m *LuaCommonShop) GetPos() *LuaPos {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *LuaCommonShop) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaCommonShop) GetPeriod() int32 {
	if m != nil && m.Period != nil {
		return *m.Period
	}
	return 0
}

func (m *LuaCommonShop) GetWeekdayList() []int32 {
	if m != nil {
		return m.WeekdayList
	}
	return nil
}

func (m *LuaCommonShop) GetFixTimeList() []int32 {
	if m != nil {
		return m.FixTimeList
	}
	return nil
}

func (m *LuaCommonShop) GetLimitTimeList() []int32 {
	if m != nil {
		return m.LimitTimeList
	}
	return nil
}

func (m *LuaCommonShop) GetPriceList() []int32 {
	if m != nil {
		return m.PriceList
	}
	return nil
}

func (m *LuaCommonShop) GetUpdateDesID() []byte {
	if m != nil {
		return m.UpdateDesID
	}
	return nil
}

func (m *LuaCommonShop) GetCellNum() int32 {
	if m != nil && m.CellNum != nil {
		return *m.CellNum
	}
	return 0
}

// Excel:q抢车位.xls sheet:停车道具表
type LuaParkItem struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	ItemID               *int32   `protobuf:"zigzag32,2,opt,name=itemID" json:"itemID,omitempty"`
	EffectType           *int32   `protobuf:"zigzag32,3,opt,name=effectType" json:"effectType,omitempty"`
	ValueList            []int32  `protobuf:"zigzag32,4,rep,name=valueList" json:"valueList,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaParkItem) Reset()         { *m = LuaParkItem{} }
func (m *LuaParkItem) String() string { return proto.CompactTextString(m) }
func (*LuaParkItem) ProtoMessage()    {}
func (*LuaParkItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{86}
}
func (m *LuaParkItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaParkItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaParkItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaParkItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaParkItem.Merge(m, src)
}
func (m *LuaParkItem) XXX_Size() int {
	return m.Size()
}
func (m *LuaParkItem) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaParkItem.DiscardUnknown(m)
}

var xxx_messageInfo_LuaParkItem proto.InternalMessageInfo

func (m *LuaParkItem) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaParkItem) GetItemID() int32 {
	if m != nil && m.ItemID != nil {
		return *m.ItemID
	}
	return 0
}

func (m *LuaParkItem) GetEffectType() int32 {
	if m != nil && m.EffectType != nil {
		return *m.EffectType
	}
	return 0
}

func (m *LuaParkItem) GetValueList() []int32 {
	if m != nil {
		return m.ValueList
	}
	return nil
}

// Excel:日常任务表.xls sheet:子任务
type LuaDailySubtask struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	DesID                []byte   `protobuf:"bytes,2,opt,name=desID" json:"desID,omitempty"`
	ConditionType        *int32   `protobuf:"zigzag32,3,opt,name=conditionType" json:"conditionType,omitempty"`
	ConditionValue       *int32   `protobuf:"zigzag32,4,opt,name=conditionValue" json:"conditionValue,omitempty"`
	Reward               []int32  `protobuf:"zigzag32,5,rep,name=reward" json:"reward,omitempty"`
	Activity             *int32   `protobuf:"zigzag32,6,opt,name=activity" json:"activity,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaDailySubtask) Reset()         { *m = LuaDailySubtask{} }
func (m *LuaDailySubtask) String() string { return proto.CompactTextString(m) }
func (*LuaDailySubtask) ProtoMessage()    {}
func (*LuaDailySubtask) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{87}
}
func (m *LuaDailySubtask) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaDailySubtask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaDailySubtask.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaDailySubtask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaDailySubtask.Merge(m, src)
}
func (m *LuaDailySubtask) XXX_Size() int {
	return m.Size()
}
func (m *LuaDailySubtask) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaDailySubtask.DiscardUnknown(m)
}

var xxx_messageInfo_LuaDailySubtask proto.InternalMessageInfo

func (m *LuaDailySubtask) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaDailySubtask) GetDesID() []byte {
	if m != nil {
		return m.DesID
	}
	return nil
}

func (m *LuaDailySubtask) GetConditionType() int32 {
	if m != nil && m.ConditionType != nil {
		return *m.ConditionType
	}
	return 0
}

func (m *LuaDailySubtask) GetConditionValue() int32 {
	if m != nil && m.ConditionValue != nil {
		return *m.ConditionValue
	}
	return 0
}

func (m *LuaDailySubtask) GetReward() []int32 {
	if m != nil {
		return m.Reward
	}
	return nil
}

func (m *LuaDailySubtask) GetActivity() int32 {
	if m != nil && m.Activity != nil {
		return *m.Activity
	}
	return 0
}

// Excel:交互动作表.xls sheet:交互动作表
type LuaInteraction struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	Type                 *int32   `protobuf:"zigzag32,2,opt,name=type" json:"type,omitempty"`
	NameID               []byte   `protobuf:"bytes,3,opt,name=nameID" json:"nameID,omitempty"`
	NameAct              []byte   `protobuf:"bytes,4,opt,name=nameAct" json:"nameAct,omitempty"`
	UnlockDesID          []byte   `protobuf:"bytes,5,opt,name=unlockDesID" json:"unlockDesID,omitempty"`
	IconID               *int32   `protobuf:"zigzag32,6,opt,name=iconID" json:"iconID,omitempty"`
	InitiatorCSB         []byte   `protobuf:"bytes,7,opt,name=initiatorCSB" json:"initiatorCSB,omitempty"`
	InitiatorAction      []byte   `protobuf:"bytes,8,opt,name=initiatorAction" json:"initiatorAction,omitempty"`
	InitiatorAction2     []byte   `protobuf:"bytes,9,opt,name=initiatorAction2" json:"initiatorAction2,omitempty"`
	InitiatorEffect      []byte   `protobuf:"bytes,10,opt,name=initiatorEffect" json:"initiatorEffect,omitempty"`
	InitiatorEffectFail  []byte   `protobuf:"bytes,11,opt,name=initiatorEffectFail" json:"initiatorEffectFail,omitempty"`
	LoopType             *int32   `protobuf:"zigzag32,12,opt,name=loopType" json:"loopType,omitempty"`
	ConsumerType         *int32   `protobuf:"zigzag32,13,opt,name=consumerType" json:"consumerType,omitempty"`
	ConsumerTime         *float32 `protobuf:"fixed32,14,opt,name=consumerTime" json:"consumerTime,omitempty"`
	ConsumerEffect       []byte   `protobuf:"bytes,15,opt,name=consumerEffect" json:"consumerEffect,omitempty"`
	ConsumerCSB          []byte   `protobuf:"bytes,16,opt,name=consumerCSB" json:"consumerCSB,omitempty"`
	ConsumerAction       []byte   `protobuf:"bytes,17,opt,name=consumerAction" json:"consumerAction,omitempty"`
	DeltaPos             []int32  `protobuf:"zigzag32,18,rep,name=deltaPos" json:"deltaPos,omitempty"`
	EffectType           *int32   `protobuf:"zigzag32,19,opt,name=effectType" json:"effectType,omitempty"`
	Radius               *int32   `protobuf:"zigzag32,20,opt,name=radius" json:"radius,omitempty"`
	Size_                []int32  `protobuf:"zigzag32,21,rep,name=size" json:"size,omitempty"`
	CdTime               *int32   `protobuf:"zigzag32,22,opt,name=cdTime" json:"cdTime,omitempty"`
	EffectSelfList       []int32  `protobuf:"zigzag32,23,rep,name=effectSelfList" json:"effectSelfList,omitempty"`
	EffectOtherList      []int32  `protobuf:"zigzag32,24,rep,name=effectOtherList" json:"effectOtherList,omitempty"`
	InteractToolType     *int32   `protobuf:"zigzag32,25,opt,name=interactToolType" json:"interactToolType,omitempty"`
	InitiatorMusic       []byte   `protobuf:"bytes,26,opt,name=initiatorMusic" json:"initiatorMusic,omitempty"`
	IsMusicLoop          *int32   `protobuf:"zigzag32,27,opt,name=isMusicLoop" json:"isMusicLoop,omitempty"`
	ConsumerMusic        []byte   `protobuf:"bytes,28,opt,name=consumerMusic" json:"consumerMusic,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaInteraction) Reset()         { *m = LuaInteraction{} }
func (m *LuaInteraction) String() string { return proto.CompactTextString(m) }
func (*LuaInteraction) ProtoMessage()    {}
func (*LuaInteraction) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{88}
}
func (m *LuaInteraction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaInteraction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaInteraction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaInteraction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaInteraction.Merge(m, src)
}
func (m *LuaInteraction) XXX_Size() int {
	return m.Size()
}
func (m *LuaInteraction) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaInteraction.DiscardUnknown(m)
}

var xxx_messageInfo_LuaInteraction proto.InternalMessageInfo

func (m *LuaInteraction) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaInteraction) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaInteraction) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaInteraction) GetNameAct() []byte {
	if m != nil {
		return m.NameAct
	}
	return nil
}

func (m *LuaInteraction) GetUnlockDesID() []byte {
	if m != nil {
		return m.UnlockDesID
	}
	return nil
}

func (m *LuaInteraction) GetIconID() int32 {
	if m != nil && m.IconID != nil {
		return *m.IconID
	}
	return 0
}

func (m *LuaInteraction) GetInitiatorCSB() []byte {
	if m != nil {
		return m.InitiatorCSB
	}
	return nil
}

func (m *LuaInteraction) GetInitiatorAction() []byte {
	if m != nil {
		return m.InitiatorAction
	}
	return nil
}

func (m *LuaInteraction) GetInitiatorAction2() []byte {
	if m != nil {
		return m.InitiatorAction2
	}
	return nil
}

func (m *LuaInteraction) GetInitiatorEffect() []byte {
	if m != nil {
		return m.InitiatorEffect
	}
	return nil
}

func (m *LuaInteraction) GetInitiatorEffectFail() []byte {
	if m != nil {
		return m.InitiatorEffectFail
	}
	return nil
}

func (m *LuaInteraction) GetLoopType() int32 {
	if m != nil && m.LoopType != nil {
		return *m.LoopType
	}
	return 0
}

func (m *LuaInteraction) GetConsumerType() int32 {
	if m != nil && m.ConsumerType != nil {
		return *m.ConsumerType
	}
	return 0
}

func (m *LuaInteraction) GetConsumerTime() float32 {
	if m != nil && m.ConsumerTime != nil {
		return *m.ConsumerTime
	}
	return 0
}

func (m *LuaInteraction) GetConsumerEffect() []byte {
	if m != nil {
		return m.ConsumerEffect
	}
	return nil
}

func (m *LuaInteraction) GetConsumerCSB() []byte {
	if m != nil {
		return m.ConsumerCSB
	}
	return nil
}

func (m *LuaInteraction) GetConsumerAction() []byte {
	if m != nil {
		return m.ConsumerAction
	}
	return nil
}

func (m *LuaInteraction) GetDeltaPos() []int32 {
	if m != nil {
		return m.DeltaPos
	}
	return nil
}

func (m *LuaInteraction) GetEffectType() int32 {
	if m != nil && m.EffectType != nil {
		return *m.EffectType
	}
	return 0
}

func (m *LuaInteraction) GetRadius() int32 {
	if m != nil && m.Radius != nil {
		return *m.Radius
	}
	return 0
}

func (m *LuaInteraction) GetSize_() []int32 {
	if m != nil {
		return m.Size_
	}
	return nil
}

func (m *LuaInteraction) GetCdTime() int32 {
	if m != nil && m.CdTime != nil {
		return *m.CdTime
	}
	return 0
}

func (m *LuaInteraction) GetEffectSelfList() []int32 {
	if m != nil {
		return m.EffectSelfList
	}
	return nil
}

func (m *LuaInteraction) GetEffectOtherList() []int32 {
	if m != nil {
		return m.EffectOtherList
	}
	return nil
}

func (m *LuaInteraction) GetInteractToolType() int32 {
	if m != nil && m.InteractToolType != nil {
		return *m.InteractToolType
	}
	return 0
}

func (m *LuaInteraction) GetInitiatorMusic() []byte {
	if m != nil {
		return m.InitiatorMusic
	}
	return nil
}

func (m *LuaInteraction) GetIsMusicLoop() int32 {
	if m != nil && m.IsMusicLoop != nil {
		return *m.IsMusicLoop
	}
	return 0
}

func (m *LuaInteraction) GetConsumerMusic() []byte {
	if m != nil {
		return m.ConsumerMusic
	}
	return nil
}

// Excel:奖励表.xls sheet:礼包表
type LuaGiftBag struct {
	Id                   *int32                  `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte                  `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	RandomCount          *int32                  `protobuf:"zigzag32,3,opt,name=randomCount" json:"randomCount,omitempty"`
	RewardList           []*LuaPackageItemWeight `protobuf:"bytes,4,rep,name=rewardList" json:"rewardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *LuaGiftBag) Reset()         { *m = LuaGiftBag{} }
func (m *LuaGiftBag) String() string { return proto.CompactTextString(m) }
func (*LuaGiftBag) ProtoMessage()    {}
func (*LuaGiftBag) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{89}
}
func (m *LuaGiftBag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaGiftBag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaGiftBag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaGiftBag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaGiftBag.Merge(m, src)
}
func (m *LuaGiftBag) XXX_Size() int {
	return m.Size()
}
func (m *LuaGiftBag) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaGiftBag.DiscardUnknown(m)
}

var xxx_messageInfo_LuaGiftBag proto.InternalMessageInfo

func (m *LuaGiftBag) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaGiftBag) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaGiftBag) GetRandomCount() int32 {
	if m != nil && m.RandomCount != nil {
		return *m.RandomCount
	}
	return 0
}

func (m *LuaGiftBag) GetRewardList() []*LuaPackageItemWeight {
	if m != nil {
		return m.RewardList
	}
	return nil
}

// Excel:道具商店表.xls sheet:小游戏商店等级随机表
type LuaMinigameShopRandom struct {
	Level                *int32                   `protobuf:"zigzag32,1,opt,name=level" json:"level,omitempty"`
	ItemIdList           []*ShopRandomSectionList `protobuf:"bytes,2,rep,name=itemIdList" json:"itemIdList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *LuaMinigameShopRandom) Reset()         { *m = LuaMinigameShopRandom{} }
func (m *LuaMinigameShopRandom) String() string { return proto.CompactTextString(m) }
func (*LuaMinigameShopRandom) ProtoMessage()    {}
func (*LuaMinigameShopRandom) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{90}
}
func (m *LuaMinigameShopRandom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaMinigameShopRandom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaMinigameShopRandom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaMinigameShopRandom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaMinigameShopRandom.Merge(m, src)
}
func (m *LuaMinigameShopRandom) XXX_Size() int {
	return m.Size()
}
func (m *LuaMinigameShopRandom) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaMinigameShopRandom.DiscardUnknown(m)
}

var xxx_messageInfo_LuaMinigameShopRandom proto.InternalMessageInfo

func (m *LuaMinigameShopRandom) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaMinigameShopRandom) GetItemIdList() []*ShopRandomSectionList {
	if m != nil {
		return m.ItemIdList
	}
	return nil
}

// Excel:石中剑配置表.xls sheet:山神选项
type LuaSwordResult struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	RateList             []int32  `protobuf:"zigzag32,2,rep,name=rateList" json:"rateList,omitempty"`
	EventList            []int32  `protobuf:"zigzag32,3,rep,name=eventList" json:"eventList,omitempty"`
	ResultList           []int32  `protobuf:"zigzag32,4,rep,name=resultList" json:"resultList,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaSwordResult) Reset()         { *m = LuaSwordResult{} }
func (m *LuaSwordResult) String() string { return proto.CompactTextString(m) }
func (*LuaSwordResult) ProtoMessage()    {}
func (*LuaSwordResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{91}
}
func (m *LuaSwordResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaSwordResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaSwordResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaSwordResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaSwordResult.Merge(m, src)
}
func (m *LuaSwordResult) XXX_Size() int {
	return m.Size()
}
func (m *LuaSwordResult) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaSwordResult.DiscardUnknown(m)
}

var xxx_messageInfo_LuaSwordResult proto.InternalMessageInfo

func (m *LuaSwordResult) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaSwordResult) GetRateList() []int32 {
	if m != nil {
		return m.RateList
	}
	return nil
}

func (m *LuaSwordResult) GetEventList() []int32 {
	if m != nil {
		return m.EventList
	}
	return nil
}

func (m *LuaSwordResult) GetResultList() []int32 {
	if m != nil {
		return m.ResultList
	}
	return nil
}

// Excel:场景表.xls sheet:NPC交互表
type LuaNpcInteract struct {
	NpcID                *int32   `protobuf:"zigzag32,1,opt,name=npcID" json:"npcID,omitempty"`
	IsRepeat             *int32   `protobuf:"zigzag32,2,opt,name=isRepeat" json:"isRepeat,omitempty"`
	CdTime               *int32   `protobuf:"zigzag32,3,opt,name=cdTime" json:"cdTime,omitempty"`
	ActionTime           *float32 `protobuf:"fixed32,4,opt,name=actionTime" json:"actionTime,omitempty"`
	Pos                  *LuaPos  `protobuf:"bytes,5,opt,name=pos" json:"pos,omitempty"`
	Sound                []byte   `protobuf:"bytes,6,opt,name=sound" json:"sound,omitempty"`
	IsMusic              *int32   `protobuf:"zigzag32,7,opt,name=isMusic" json:"isMusic,omitempty"`
	IsAudioEffectAll     *int32   `protobuf:"zigzag32,8,opt,name=isAudioEffectAll" json:"isAudioEffectAll,omitempty"`
	MutexIDList          []int32  `protobuf:"zigzag32,9,rep,name=mutexIDList" json:"mutexIDList,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaNpcInteract) Reset()         { *m = LuaNpcInteract{} }
func (m *LuaNpcInteract) String() string { return proto.CompactTextString(m) }
func (*LuaNpcInteract) ProtoMessage()    {}
func (*LuaNpcInteract) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{92}
}
func (m *LuaNpcInteract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaNpcInteract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaNpcInteract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaNpcInteract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaNpcInteract.Merge(m, src)
}
func (m *LuaNpcInteract) XXX_Size() int {
	return m.Size()
}
func (m *LuaNpcInteract) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaNpcInteract.DiscardUnknown(m)
}

var xxx_messageInfo_LuaNpcInteract proto.InternalMessageInfo

func (m *LuaNpcInteract) GetNpcID() int32 {
	if m != nil && m.NpcID != nil {
		return *m.NpcID
	}
	return 0
}

func (m *LuaNpcInteract) GetIsRepeat() int32 {
	if m != nil && m.IsRepeat != nil {
		return *m.IsRepeat
	}
	return 0
}

func (m *LuaNpcInteract) GetCdTime() int32 {
	if m != nil && m.CdTime != nil {
		return *m.CdTime
	}
	return 0
}

func (m *LuaNpcInteract) GetActionTime() float32 {
	if m != nil && m.ActionTime != nil {
		return *m.ActionTime
	}
	return 0
}

func (m *LuaNpcInteract) GetPos() *LuaPos {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *LuaNpcInteract) GetSound() []byte {
	if m != nil {
		return m.Sound
	}
	return nil
}

func (m *LuaNpcInteract) GetIsMusic() int32 {
	if m != nil && m.IsMusic != nil {
		return *m.IsMusic
	}
	return 0
}

func (m *LuaNpcInteract) GetIsAudioEffectAll() int32 {
	if m != nil && m.IsAudioEffectAll != nil {
		return *m.IsAudioEffectAll
	}
	return 0
}

func (m *LuaNpcInteract) GetMutexIDList() []int32 {
	if m != nil {
		return m.MutexIDList
	}
	return nil
}

// Excel:avatar表情.xls sheet:face_level
type LuaFaceLvl struct {
	Level                *int32   `protobuf:"zigzag32,1,opt,name=level" json:"level,omitempty"`
	Count                *int32   `protobuf:"zigzag32,2,opt,name=count" json:"count,omitempty"`
	DesID                []byte   `protobuf:"bytes,3,opt,name=desID" json:"desID,omitempty"`
	LockLvl              *int32   `protobuf:"zigzag32,4,opt,name=lockLvl" json:"lockLvl,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaFaceLvl) Reset()         { *m = LuaFaceLvl{} }
func (m *LuaFaceLvl) String() string { return proto.CompactTextString(m) }
func (*LuaFaceLvl) ProtoMessage()    {}
func (*LuaFaceLvl) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{93}
}
func (m *LuaFaceLvl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaFaceLvl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaFaceLvl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaFaceLvl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaFaceLvl.Merge(m, src)
}
func (m *LuaFaceLvl) XXX_Size() int {
	return m.Size()
}
func (m *LuaFaceLvl) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaFaceLvl.DiscardUnknown(m)
}

var xxx_messageInfo_LuaFaceLvl proto.InternalMessageInfo

func (m *LuaFaceLvl) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaFaceLvl) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *LuaFaceLvl) GetDesID() []byte {
	if m != nil {
		return m.DesID
	}
	return nil
}

func (m *LuaFaceLvl) GetLockLvl() int32 {
	if m != nil && m.LockLvl != nil {
		return *m.LockLvl
	}
	return 0
}

// Excel:equip装备.xls sheet:装备背包扩充
type LuaEquipBag struct {
	Id                   *int32        `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	UpLimit              *int32        `protobuf:"zigzag32,2,opt,name=upLimit" json:"upLimit,omitempty"`
	Cost                 []*ItemConfig `protobuf:"bytes,3,rep,name=cost" json:"cost,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaEquipBag) Reset()         { *m = LuaEquipBag{} }
func (m *LuaEquipBag) String() string { return proto.CompactTextString(m) }
func (*LuaEquipBag) ProtoMessage()    {}
func (*LuaEquipBag) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{94}
}
func (m *LuaEquipBag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaEquipBag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaEquipBag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaEquipBag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaEquipBag.Merge(m, src)
}
func (m *LuaEquipBag) XXX_Size() int {
	return m.Size()
}
func (m *LuaEquipBag) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaEquipBag.DiscardUnknown(m)
}

var xxx_messageInfo_LuaEquipBag proto.InternalMessageInfo

func (m *LuaEquipBag) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaEquipBag) GetUpLimit() int32 {
	if m != nil && m.UpLimit != nil {
		return *m.UpLimit
	}
	return 0
}

func (m *LuaEquipBag) GetCost() []*ItemConfig {
	if m != nil {
		return m.Cost
	}
	return nil
}

// Excel:task任务表.xls sheet:任务
type LuaMainTask struct {
	Id                   *int32         `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte         `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	PreTalkID            *int32         `protobuf:"zigzag32,3,opt,name=preTalkID" json:"preTalkID,omitempty"`
	NexTalkID            *int32         `protobuf:"zigzag32,4,opt,name=nexTalkID" json:"nexTalkID,omitempty"`
	CompleteTalkID       *int32         `protobuf:"zigzag32,5,opt,name=completeTalkID" json:"completeTalkID,omitempty"`
	DesID                []byte         `protobuf:"bytes,6,opt,name=desID" json:"desID,omitempty"`
	Type                 *int32         `protobuf:"zigzag32,7,opt,name=type" json:"type,omitempty"`
	CompleteIf           []int32        `protobuf:"zigzag32,8,rep,name=completeIf" json:"completeIf,omitempty"`
	IsHasPreTask         *int32         `protobuf:"zigzag32,9,opt,name=isHasPreTask" json:"isHasPreTask,omitempty"`
	NexIDList            []int32        `protobuf:"zigzag32,10,rep,name=nexIDList" json:"nexIDList,omitempty"`
	FuncID               *int32         `protobuf:"zigzag32,11,opt,name=funcID" json:"funcID,omitempty"`
	RiskID               []int32        `protobuf:"zigzag32,12,rep,name=riskID" json:"riskID,omitempty"`
	FriendCount          *int32         `protobuf:"zigzag32,13,opt,name=friendCount" json:"friendCount,omitempty"`
	KillCount            *int32         `protobuf:"zigzag32,14,opt,name=killCount" json:"killCount,omitempty"`
	Level                *int32         `protobuf:"zigzag32,15,opt,name=level" json:"level,omitempty"`
	InteractTime         *int32         `protobuf:"zigzag32,16,opt,name=interactTime" json:"interactTime,omitempty"`
	InteractNpcList      []*InteractNpc `protobuf:"bytes,17,rep,name=interactNpcList" json:"interactNpcList,omitempty"`
	ArenaOkTime          *int32         `protobuf:"zigzag32,18,opt,name=arenaOkTime" json:"arenaOkTime,omitempty"`
	BathWashTime         *int32         `protobuf:"zigzag32,19,opt,name=bathWashTime" json:"bathWashTime,omitempty"`
	OnlineTotalTime      *int32         `protobuf:"zigzag32,20,opt,name=onlineTotalTime" json:"onlineTotalTime,omitempty"`
	NpcID                *int32         `protobuf:"zigzag32,21,opt,name=npcID" json:"npcID,omitempty"`
	AcceptRewardList     []*ItemConfig  `protobuf:"bytes,22,rep,name=acceptRewardList" json:"acceptRewardList,omitempty"`
	RewardList           []*ItemConfig  `protobuf:"bytes,23,rep,name=rewardList" json:"rewardList,omitempty"`
	CanGiveUp            *int32         `protobuf:"zigzag32,24,opt,name=canGiveUp" json:"canGiveUp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *LuaMainTask) Reset()         { *m = LuaMainTask{} }
func (m *LuaMainTask) String() string { return proto.CompactTextString(m) }
func (*LuaMainTask) ProtoMessage()    {}
func (*LuaMainTask) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{95}
}
func (m *LuaMainTask) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaMainTask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaMainTask.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaMainTask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaMainTask.Merge(m, src)
}
func (m *LuaMainTask) XXX_Size() int {
	return m.Size()
}
func (m *LuaMainTask) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaMainTask.DiscardUnknown(m)
}

var xxx_messageInfo_LuaMainTask proto.InternalMessageInfo

func (m *LuaMainTask) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaMainTask) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaMainTask) GetPreTalkID() int32 {
	if m != nil && m.PreTalkID != nil {
		return *m.PreTalkID
	}
	return 0
}

func (m *LuaMainTask) GetNexTalkID() int32 {
	if m != nil && m.NexTalkID != nil {
		return *m.NexTalkID
	}
	return 0
}

func (m *LuaMainTask) GetCompleteTalkID() int32 {
	if m != nil && m.CompleteTalkID != nil {
		return *m.CompleteTalkID
	}
	return 0
}

func (m *LuaMainTask) GetDesID() []byte {
	if m != nil {
		return m.DesID
	}
	return nil
}

func (m *LuaMainTask) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaMainTask) GetCompleteIf() []int32 {
	if m != nil {
		return m.CompleteIf
	}
	return nil
}

func (m *LuaMainTask) GetIsHasPreTask() int32 {
	if m != nil && m.IsHasPreTask != nil {
		return *m.IsHasPreTask
	}
	return 0
}

func (m *LuaMainTask) GetNexIDList() []int32 {
	if m != nil {
		return m.NexIDList
	}
	return nil
}

func (m *LuaMainTask) GetFuncID() int32 {
	if m != nil && m.FuncID != nil {
		return *m.FuncID
	}
	return 0
}

func (m *LuaMainTask) GetRiskID() []int32 {
	if m != nil {
		return m.RiskID
	}
	return nil
}

func (m *LuaMainTask) GetFriendCount() int32 {
	if m != nil && m.FriendCount != nil {
		return *m.FriendCount
	}
	return 0
}

func (m *LuaMainTask) GetKillCount() int32 {
	if m != nil && m.KillCount != nil {
		return *m.KillCount
	}
	return 0
}

func (m *LuaMainTask) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaMainTask) GetInteractTime() int32 {
	if m != nil && m.InteractTime != nil {
		return *m.InteractTime
	}
	return 0
}

func (m *LuaMainTask) GetInteractNpcList() []*InteractNpc {
	if m != nil {
		return m.InteractNpcList
	}
	return nil
}

func (m *LuaMainTask) GetArenaOkTime() int32 {
	if m != nil && m.ArenaOkTime != nil {
		return *m.ArenaOkTime
	}
	return 0
}

func (m *LuaMainTask) GetBathWashTime() int32 {
	if m != nil && m.BathWashTime != nil {
		return *m.BathWashTime
	}
	return 0
}

func (m *LuaMainTask) GetOnlineTotalTime() int32 {
	if m != nil && m.OnlineTotalTime != nil {
		return *m.OnlineTotalTime
	}
	return 0
}

func (m *LuaMainTask) GetNpcID() int32 {
	if m != nil && m.NpcID != nil {
		return *m.NpcID
	}
	return 0
}

func (m *LuaMainTask) GetAcceptRewardList() []*ItemConfig {
	if m != nil {
		return m.AcceptRewardList
	}
	return nil
}

func (m *LuaMainTask) GetRewardList() []*ItemConfig {
	if m != nil {
		return m.RewardList
	}
	return nil
}

func (m *LuaMainTask) GetCanGiveUp() int32 {
	if m != nil && m.CanGiveUp != nil {
		return *m.CanGiveUp
	}
	return 0
}

// Excel:d点金手表.xls sheet:Sheet1
type LuaExchangeGold struct {
	Time                 *int32              `protobuf:"zigzag32,1,opt,name=time" json:"time,omitempty"`
	CountDiamond         *int32              `protobuf:"zigzag32,2,opt,name=countDiamond" json:"countDiamond,omitempty"`
	GetGold              []*ExchangeGoldItem `protobuf:"bytes,3,rep,name=getGold" json:"getGold,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *LuaExchangeGold) Reset()         { *m = LuaExchangeGold{} }
func (m *LuaExchangeGold) String() string { return proto.CompactTextString(m) }
func (*LuaExchangeGold) ProtoMessage()    {}
func (*LuaExchangeGold) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{96}
}
func (m *LuaExchangeGold) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaExchangeGold) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaExchangeGold.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaExchangeGold) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaExchangeGold.Merge(m, src)
}
func (m *LuaExchangeGold) XXX_Size() int {
	return m.Size()
}
func (m *LuaExchangeGold) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaExchangeGold.DiscardUnknown(m)
}

var xxx_messageInfo_LuaExchangeGold proto.InternalMessageInfo

func (m *LuaExchangeGold) GetTime() int32 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *LuaExchangeGold) GetCountDiamond() int32 {
	if m != nil && m.CountDiamond != nil {
		return *m.CountDiamond
	}
	return 0
}

func (m *LuaExchangeGold) GetGetGold() []*ExchangeGoldItem {
	if m != nil {
		return m.GetGold
	}
	return nil
}

// Excel:avatar表情.xls sheet:suit
type LuaSuit struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte   `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	DesID                []byte   `protobuf:"bytes,3,opt,name=desID" json:"desID,omitempty"`
	IsSpecial            *int32   `protobuf:"zigzag32,4,opt,name=isSpecial" json:"isSpecial,omitempty"`
	ResID                *int32   `protobuf:"zigzag32,5,opt,name=resID" json:"resID,omitempty"`
	Atk                  *int32   `protobuf:"zigzag32,6,opt,name=atk" json:"atk,omitempty"`
	Hp                   *int32   `protobuf:"zigzag32,7,opt,name=hp" json:"hp,omitempty"`
	Def                  *int32   `protobuf:"zigzag32,8,opt,name=def" json:"def,omitempty"`
	Crit                 *int32   `protobuf:"zigzag32,9,opt,name=crit" json:"crit,omitempty"`
	Block                *int32   `protobuf:"zigzag32,10,opt,name=block" json:"block,omitempty"`
	Speed                *int32   `protobuf:"zigzag32,11,opt,name=speed" json:"speed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaSuit) Reset()         { *m = LuaSuit{} }
func (m *LuaSuit) String() string { return proto.CompactTextString(m) }
func (*LuaSuit) ProtoMessage()    {}
func (*LuaSuit) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{97}
}
func (m *LuaSuit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaSuit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaSuit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaSuit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaSuit.Merge(m, src)
}
func (m *LuaSuit) XXX_Size() int {
	return m.Size()
}
func (m *LuaSuit) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaSuit.DiscardUnknown(m)
}

var xxx_messageInfo_LuaSuit proto.InternalMessageInfo

func (m *LuaSuit) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaSuit) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaSuit) GetDesID() []byte {
	if m != nil {
		return m.DesID
	}
	return nil
}

func (m *LuaSuit) GetIsSpecial() int32 {
	if m != nil && m.IsSpecial != nil {
		return *m.IsSpecial
	}
	return 0
}

func (m *LuaSuit) GetResID() int32 {
	if m != nil && m.ResID != nil {
		return *m.ResID
	}
	return 0
}

func (m *LuaSuit) GetAtk() int32 {
	if m != nil && m.Atk != nil {
		return *m.Atk
	}
	return 0
}

func (m *LuaSuit) GetHp() int32 {
	if m != nil && m.Hp != nil {
		return *m.Hp
	}
	return 0
}

func (m *LuaSuit) GetDef() int32 {
	if m != nil && m.Def != nil {
		return *m.Def
	}
	return 0
}

func (m *LuaSuit) GetCrit() int32 {
	if m != nil && m.Crit != nil {
		return *m.Crit
	}
	return 0
}

func (m *LuaSuit) GetBlock() int32 {
	if m != nil && m.Block != nil {
		return *m.Block
	}
	return 0
}

func (m *LuaSuit) GetSpeed() int32 {
	if m != nil && m.Speed != nil {
		return *m.Speed
	}
	return 0
}

// Excel:全局配置表.xls sheet:全局配置表
type LuaGlobalConfig struct {
	Id                             *int32               `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	SceneMoveSpeed                 *int32               `protobuf:"zigzag32,2,opt,name=sceneMoveSpeed" json:"sceneMoveSpeed,omitempty"`
	ActArea                        *int32               `protobuf:"zigzag32,3,opt,name=actArea" json:"actArea,omitempty"`
	SwordInterval                  *int32               `protobuf:"zigzag32,4,opt,name=swordInterval" json:"swordInterval,omitempty"`
	LevelUpStamina                 *int32               `protobuf:"zigzag32,5,opt,name=levelUpStamina" json:"levelUpStamina,omitempty"`
	BuyGetStamina                  *int32               `protobuf:"zigzag32,6,opt,name=buyGetStamina" json:"buyGetStamina,omitempty"`
	StaminaInterval                *int32               `protobuf:"zigzag32,7,opt,name=staminaInterval" json:"staminaInterval,omitempty"`
	SwordGodProb                   *int32               `protobuf:"zigzag32,8,opt,name=swordGodProb" json:"swordGodProb,omitempty"`
	SignDivisor                    *int32               `protobuf:"zigzag32,9,opt,name=signDivisor" json:"signDivisor,omitempty"`
	SignPakageID                   *int32               `protobuf:"zigzag32,10,opt,name=signPakageID" json:"signPakageID,omitempty"`
	SignShowList                   []*ItemConfig        `protobuf:"bytes,11,rep,name=signShowList" json:"signShowList,omitempty"`
	SwordCount                     *int32               `protobuf:"zigzag32,12,opt,name=swordCount" json:"swordCount,omitempty"`
	ArenaCount                     *int32               `protobuf:"zigzag32,13,opt,name=arenaCount" json:"arenaCount,omitempty"`
	ArenaCD                        *int32               `protobuf:"zigzag32,14,opt,name=arenaCD" json:"arenaCD,omitempty"`
	ArenaClearCDCost               *ItemConfig          `protobuf:"bytes,15,opt,name=arenaClearCDCost" json:"arenaClearCDCost,omitempty"`
	FastTransItemID                *int32               `protobuf:"zigzag32,16,opt,name=fastTransItemID" json:"fastTransItemID,omitempty"`
	ArenaDayRewardList             []int32              `protobuf:"zigzag32,17,rep,name=arenaDayRewardList" json:"arenaDayRewardList,omitempty"`
	EquipStrengthItemId            *int32               `protobuf:"zigzag32,18,opt,name=equipStrengthItemId" json:"equipStrengthItemId,omitempty"`
	EquipResolveReturnPercent      *int32               `protobuf:"zigzag32,19,opt,name=equipResolveReturnPercent" json:"equipResolveReturnPercent,omitempty"`
	EquipDeclineParameter          *EquipLastingDecline `protobuf:"bytes,20,opt,name=equipDeclineParameter" json:"equipDeclineParameter,omitempty"`
	FriendAssistCdTime             *int32               `protobuf:"zigzag32,21,opt,name=friendAssistCdTime" json:"friendAssistCdTime,omitempty"`
	RechargeExchangeScale          *int32               `protobuf:"zigzag32,22,opt,name=rechargeExchangeScale" json:"rechargeExchangeScale,omitempty"`
	BathFullnessUpperlimit         *int32               `protobuf:"zigzag32,23,opt,name=bathFullnessUpperlimit" json:"bathFullnessUpperlimit,omitempty"`
	InitCarport                    *int32               `protobuf:"zigzag32,24,opt,name=initCarport" json:"initCarport,omitempty"`
	InitRepairCarCount             *int32               `protobuf:"zigzag32,25,opt,name=initRepairCarCount" json:"initRepairCarCount,omitempty"`
	ParkStopCDTime                 *int32               `protobuf:"zigzag32,26,opt,name=parkStopCDTime" json:"parkStopCDTime,omitempty"`
	ParkProtectCDTime              *int32               `protobuf:"zigzag32,27,opt,name=parkProtectCDTime" json:"parkProtectCDTime,omitempty"`
	ParkBreakProtectCDTime         *int32               `protobuf:"zigzag32,28,opt,name=parkBreakProtectCDTime" json:"parkBreakProtectCDTime,omitempty"`
	ParkRepairUnitTime             *int32               `protobuf:"zigzag32,29,opt,name=parkRepairUnitTime" json:"parkRepairUnitTime,omitempty"`
	DiamondReduceRepairCarTime     *int32               `protobuf:"zigzag32,30,opt,name=diamondReduceRepairCarTime" json:"diamondReduceRepairCarTime,omitempty"`
	FastRepairUseItemID            *int32               `protobuf:"zigzag32,31,opt,name=fastRepairUseItemID" json:"fastRepairUseItemID,omitempty"`
	ItemReduceRepairCarTime        *int32               `protobuf:"zigzag32,32,opt,name=itemReduceRepairCarTime" json:"itemReduceRepairCarTime,omitempty"`
	LastCarProtectTime             *int32               `protobuf:"zigzag32,33,opt,name=lastCarProtectTime" json:"lastCarProtectTime,omitempty"`
	ParkSayYesLimitTime            *int32               `protobuf:"zigzag32,34,opt,name=parkSayYesLimitTime" json:"parkSayYesLimitTime,omitempty"`
	ParkBenefitUnitTime            *int32               `protobuf:"zigzag32,35,opt,name=parkBenefitUnitTime" json:"parkBenefitUnitTime,omitempty"`
	CarportProtectTime             *int32               `protobuf:"zigzag32,36,opt,name=carportProtectTime" json:"carportProtectTime,omitempty"`
	FullParkBenefitRate            *float32             `protobuf:"fixed32,37,opt,name=fullParkBenefitRate" json:"fullParkBenefitRate,omitempty"`
	FullParkRewardID               *int32               `protobuf:"zigzag32,38,opt,name=fullParkRewardID" json:"fullParkRewardID,omitempty"`
	ParkBreakGetBenefitRate        *float32             `protobuf:"fixed32,39,opt,name=parkBreakGetBenefitRate" json:"parkBreakGetBenefitRate,omitempty"`
	ParkActCount                   *int32               `protobuf:"zigzag32,40,opt,name=parkActCount" json:"parkActCount,omitempty"`
	ParkActRefreshTime             *int32               `protobuf:"zigzag32,41,opt,name=parkActRefreshTime" json:"parkActRefreshTime,omitempty"`
	ParkGetExpUnitTime             *int32               `protobuf:"zigzag32,42,opt,name=parkGetExpUnitTime" json:"parkGetExpUnitTime,omitempty"`
	ParkSayYesGetExp               *int32               `protobuf:"zigzag32,43,opt,name=parkSayYesGetExp" json:"parkSayYesGetExp,omitempty"`
	ParkBreakGetExp                *int32               `protobuf:"zigzag32,44,opt,name=parkBreakGetExp" json:"parkBreakGetExp,omitempty"`
	ParkGetRewardProb              *int32               `protobuf:"zigzag32,45,opt,name=parkGetRewardProb" json:"parkGetRewardProb,omitempty"`
	ParkSayYesGetRewardProb        *int32               `protobuf:"zigzag32,46,opt,name=parkSayYesGetRewardProb" json:"parkSayYesGetRewardProb,omitempty"`
	ParkBreakGetRewardProb         *int32               `protobuf:"zigzag32,47,opt,name=parkBreakGetRewardProb" json:"parkBreakGetRewardProb,omitempty"`
	SystemParkRefreshTime          *int32               `protobuf:"zigzag32,48,opt,name=systemParkRefreshTime" json:"systemParkRefreshTime,omitempty"`
	SystemParkMaxCount             *int32               `protobuf:"zigzag32,49,opt,name=systemParkMaxCount" json:"systemParkMaxCount,omitempty"`
	SystemParkByLeftCount          *int32               `protobuf:"zigzag32,50,opt,name=systemParkByLeftCount" json:"systemParkByLeftCount,omitempty"`
	SystemParkRandomCaridList      []int32              `protobuf:"zigzag32,51,rep,name=systemParkRandomCaridList" json:"systemParkRandomCaridList,omitempty"`
	ParkStayTimeAfterFullTime      *int32               `protobuf:"zigzag32,52,opt,name=parkStayTimeAfterFullTime" json:"parkStayTimeAfterFullTime,omitempty"`
	ParkShopRefreshCarCount        *int32               `protobuf:"zigzag32,53,opt,name=parkShopRefreshCarCount" json:"parkShopRefreshCarCount,omitempty"`
	ParkDetailMaxCount             *int32               `protobuf:"zigzag32,54,opt,name=parkDetailMaxCount" json:"parkDetailMaxCount,omitempty"`
	ParkSayYesProb                 *int32               `protobuf:"zigzag32,55,opt,name=parkSayYesProb" json:"parkSayYesProb,omitempty"`
	CarPartID                      *int32               `protobuf:"zigzag32,56,opt,name=carPartID" json:"carPartID,omitempty"`
	InteractNpcList                []int32              `protobuf:"zigzag32,57,rep,name=interactNpcList" json:"interactNpcList,omitempty"`
	HangupRestrictList             []int32              `protobuf:"zigzag32,58,rep,name=hangupRestrictList" json:"hangupRestrictList,omitempty"`
	BathRecoveryUpperLimit         *int32               `protobuf:"zigzag32,59,opt,name=bathRecoveryUpperLimit" json:"bathRecoveryUpperLimit,omitempty"`
	BathRecoveryInterval           *int32               `protobuf:"zigzag32,60,opt,name=bathRecoveryInterval" json:"bathRecoveryInterval,omitempty"`
	BathOnceTimeList               []*BathOnceStimina   `protobuf:"bytes,61,rep,name=bathOnceTimeList" json:"bathOnceTimeList,omitempty"`
	AddSwordItemList               []int32              `protobuf:"zigzag32,62,rep,name=addSwordItemList" json:"addSwordItemList,omitempty"`
	ChargeSkillBookItemID          *int32               `protobuf:"zigzag32,63,opt,name=chargeSkillBookItemID" json:"chargeSkillBookItemID,omitempty"`
	PetTalentRebuildCostList       []*ItemConfig        `protobuf:"bytes,64,rep,name=petTalentRebuildCostList" json:"petTalentRebuildCostList,omitempty"`
	CostInterval                   *EquipEnduranceCost  `protobuf:"bytes,65,opt,name=costInterval" json:"costInterval,omitempty"`
	PetRefreshTimeList             []int32              `protobuf:"zigzag32,66,rep,name=petRefreshTimeList" json:"petRefreshTimeList,omitempty"`
	UploadHeadImageCostList        []*ItemConfig        `protobuf:"bytes,67,rep,name=uploadHeadImageCostList" json:"uploadHeadImageCostList,omitempty"`
	ForeverUploadHeadImageCostList []*ItemConfig        `protobuf:"bytes,68,rep,name=foreverUploadHeadImageCostList" json:"foreverUploadHeadImageCostList,omitempty"`
	HorseSpeed                     *int32               `protobuf:"zigzag32,69,opt,name=horseSpeed" json:"horseSpeed,omitempty"`
	HorseInterval                  *float32             `protobuf:"fixed32,70,opt,name=horseInterval" json:"horseInterval,omitempty"`
	CaliburnCountLimit             *int32               `protobuf:"zigzag32,71,opt,name=caliburnCountLimit" json:"caliburnCountLimit,omitempty"`
	CannonPosList                  []*LuaPos            `protobuf:"bytes,72,rep,name=cannonPosList" json:"cannonPosList,omitempty"`
	FightFriendTime                *int32               `protobuf:"zigzag32,73,opt,name=fightFriendTime" json:"fightFriendTime,omitempty"`
	GreenHatLimit                  *int32               `protobuf:"zigzag32,74,opt,name=greenHatLimit" json:"greenHatLimit,omitempty"`
	GreenHatGap                    *int32               `protobuf:"zigzag32,75,opt,name=greenHatGap" json:"greenHatGap,omitempty"`
	GuadraticMaxRole               *int32               `protobuf:"zigzag32,76,opt,name=guadraticMaxRole" json:"guadraticMaxRole,omitempty"`
	GuadraticMaxCount              *int32               `protobuf:"zigzag32,77,opt,name=guadraticMaxCount" json:"guadraticMaxCount,omitempty"`
	GuadraticCost                  *ItemConfig          `protobuf:"bytes,78,opt,name=guadraticCost" json:"guadraticCost,omitempty"`
	GuadraticOpenTimeList          []*TimeRange         `protobuf:"bytes,79,rep,name=guadraticOpenTimeList" json:"guadraticOpenTimeList,omitempty"`
	GuadraticStartCDTime           *int32               `protobuf:"zigzag32,80,opt,name=guadraticStartCDTime" json:"guadraticStartCDTime,omitempty"`
	GuadraticQuitCD                *int32               `protobuf:"zigzag32,81,opt,name=guadraticQuitCD" json:"guadraticQuitCD,omitempty"`
	GuadraticEndHurtCD             *int32               `protobuf:"zigzag32,82,opt,name=guadraticEndHurtCD" json:"guadraticEndHurtCD,omitempty"`
	GuadraticEndHurt               *int32               `protobuf:"zigzag32,83,opt,name=guadraticEndHurt" json:"guadraticEndHurt,omitempty"`
	GuadraticAtkCD                 *int32               `protobuf:"zigzag32,84,opt,name=guadraticAtkCD" json:"guadraticAtkCD,omitempty"`
	GuadraticUnderAtkCD            *int32               `protobuf:"zigzag32,85,opt,name=guadraticUnderAtkCD" json:"guadraticUnderAtkCD,omitempty"`
	GuadraticHP                    *int32               `protobuf:"zigzag32,86,opt,name=guadraticHP" json:"guadraticHP,omitempty"`
	GuadraticHurt                  *int32               `protobuf:"zigzag32,87,opt,name=guadraticHurt" json:"guadraticHurt,omitempty"`
	LevelRankNum                   *int32               `protobuf:"zigzag32,88,opt,name=levelRankNum" json:"levelRankNum,omitempty"`
	KillRankNum                    *int32               `protobuf:"zigzag32,89,opt,name=killRankNum" json:"killRankNum,omitempty"`
	DiamondRankNum                 *int32               `protobuf:"zigzag32,90,opt,name=diamondRankNum" json:"diamondRankNum,omitempty"`
	MinigameRankNum                *int32               `protobuf:"zigzag32,91,opt,name=minigameRankNum" json:"minigameRankNum,omitempty"`
	FaceDupReturnItem              *ItemConfig          `protobuf:"bytes,92,opt,name=faceDupReturnItem" json:"faceDupReturnItem,omitempty"`
	SellBagGridMaxNum              *int32               `protobuf:"zigzag32,93,opt,name=sellBagGridMaxNum" json:"sellBagGridMaxNum,omitempty"`
	FirstSaveMoneryRewardList      []*ItemConfig        `protobuf:"bytes,94,rep,name=firstSaveMoneryRewardList" json:"firstSaveMoneryRewardList,omitempty"`
	WeixinRewardList               []*ItemConfig        `protobuf:"bytes,95,rep,name=weixinRewardList" json:"weixinRewardList,omitempty"`
	RechargeLimit                  *int64               `protobuf:"zigzag64,96,opt,name=rechargeLimit" json:"rechargeLimit,omitempty"`
	PetEggReturnItemList           []*ItemConfig        `protobuf:"bytes,97,rep,name=petEggReturnItemList" json:"petEggReturnItemList,omitempty"`
	FriendNumLimit                 *int32               `protobuf:"zigzag32,98,opt,name=friendNumLimit" json:"friendNumLimit,omitempty"`
	PianoTime                      *int32               `protobuf:"zigzag32,99,opt,name=pianoTime" json:"pianoTime,omitempty"`
	UnlockBattleSpeedLevel         *int32               `protobuf:"zigzag32,100,opt,name=unlockBattleSpeedLevel" json:"unlockBattleSpeedLevel,omitempty"`
	PvpAtkRate                     *float32             `protobuf:"fixed32,101,opt,name=pvpAtkRate" json:"pvpAtkRate,omitempty"`
	PvpDefRate                     *float32             `protobuf:"fixed32,102,opt,name=pvpDefRate" json:"pvpDefRate,omitempty"`
	DiamondFaceNum                 *int32               `protobuf:"zigzag32,103,opt,name=diamondFaceNum" json:"diamondFaceNum,omitempty"`
	GoldFaceNum                    *int32               `protobuf:"zigzag32,104,opt,name=goldFaceNum" json:"goldFaceNum,omitempty"`
	InitRoleAttr                   []int32              `protobuf:"zigzag32,105,rep,name=initRoleAttr" json:"initRoleAttr,omitempty"`
	PerLevelAttr                   []int32              `protobuf:"zigzag32,106,rep,name=perLevelAttr" json:"perLevelAttr,omitempty"`
	FightParameter                 []int32              `protobuf:"zigzag32,107,rep,name=fightParameter" json:"fightParameter,omitempty"`
	DailyGameItemList              []*ItemConfig        `protobuf:"bytes,108,rep,name=dailyGameItemList" json:"dailyGameItemList,omitempty"`
	XXX_NoUnkeyedLiteral           struct{}             `json:"-"`
	XXX_unrecognized               []byte               `json:"-"`
	XXX_sizecache                  int32                `json:"-"`
}

func (m *LuaGlobalConfig) Reset()         { *m = LuaGlobalConfig{} }
func (m *LuaGlobalConfig) String() string { return proto.CompactTextString(m) }
func (*LuaGlobalConfig) ProtoMessage()    {}
func (*LuaGlobalConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{98}
}
func (m *LuaGlobalConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaGlobalConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaGlobalConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaGlobalConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaGlobalConfig.Merge(m, src)
}
func (m *LuaGlobalConfig) XXX_Size() int {
	return m.Size()
}
func (m *LuaGlobalConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaGlobalConfig.DiscardUnknown(m)
}

var xxx_messageInfo_LuaGlobalConfig proto.InternalMessageInfo

func (m *LuaGlobalConfig) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaGlobalConfig) GetSceneMoveSpeed() int32 {
	if m != nil && m.SceneMoveSpeed != nil {
		return *m.SceneMoveSpeed
	}
	return 0
}

func (m *LuaGlobalConfig) GetActArea() int32 {
	if m != nil && m.ActArea != nil {
		return *m.ActArea
	}
	return 0
}

func (m *LuaGlobalConfig) GetSwordInterval() int32 {
	if m != nil && m.SwordInterval != nil {
		return *m.SwordInterval
	}
	return 0
}

func (m *LuaGlobalConfig) GetLevelUpStamina() int32 {
	if m != nil && m.LevelUpStamina != nil {
		return *m.LevelUpStamina
	}
	return 0
}

func (m *LuaGlobalConfig) GetBuyGetStamina() int32 {
	if m != nil && m.BuyGetStamina != nil {
		return *m.BuyGetStamina
	}
	return 0
}

func (m *LuaGlobalConfig) GetStaminaInterval() int32 {
	if m != nil && m.StaminaInterval != nil {
		return *m.StaminaInterval
	}
	return 0
}

func (m *LuaGlobalConfig) GetSwordGodProb() int32 {
	if m != nil && m.SwordGodProb != nil {
		return *m.SwordGodProb
	}
	return 0
}

func (m *LuaGlobalConfig) GetSignDivisor() int32 {
	if m != nil && m.SignDivisor != nil {
		return *m.SignDivisor
	}
	return 0
}

func (m *LuaGlobalConfig) GetSignPakageID() int32 {
	if m != nil && m.SignPakageID != nil {
		return *m.SignPakageID
	}
	return 0
}

func (m *LuaGlobalConfig) GetSignShowList() []*ItemConfig {
	if m != nil {
		return m.SignShowList
	}
	return nil
}

func (m *LuaGlobalConfig) GetSwordCount() int32 {
	if m != nil && m.SwordCount != nil {
		return *m.SwordCount
	}
	return 0
}

func (m *LuaGlobalConfig) GetArenaCount() int32 {
	if m != nil && m.ArenaCount != nil {
		return *m.ArenaCount
	}
	return 0
}

func (m *LuaGlobalConfig) GetArenaCD() int32 {
	if m != nil && m.ArenaCD != nil {
		return *m.ArenaCD
	}
	return 0
}

func (m *LuaGlobalConfig) GetArenaClearCDCost() *ItemConfig {
	if m != nil {
		return m.ArenaClearCDCost
	}
	return nil
}

func (m *LuaGlobalConfig) GetFastTransItemID() int32 {
	if m != nil && m.FastTransItemID != nil {
		return *m.FastTransItemID
	}
	return 0
}

func (m *LuaGlobalConfig) GetArenaDayRewardList() []int32 {
	if m != nil {
		return m.ArenaDayRewardList
	}
	return nil
}

func (m *LuaGlobalConfig) GetEquipStrengthItemId() int32 {
	if m != nil && m.EquipStrengthItemId != nil {
		return *m.EquipStrengthItemId
	}
	return 0
}

func (m *LuaGlobalConfig) GetEquipResolveReturnPercent() int32 {
	if m != nil && m.EquipResolveReturnPercent != nil {
		return *m.EquipResolveReturnPercent
	}
	return 0
}

func (m *LuaGlobalConfig) GetEquipDeclineParameter() *EquipLastingDecline {
	if m != nil {
		return m.EquipDeclineParameter
	}
	return nil
}

func (m *LuaGlobalConfig) GetFriendAssistCdTime() int32 {
	if m != nil && m.FriendAssistCdTime != nil {
		return *m.FriendAssistCdTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetRechargeExchangeScale() int32 {
	if m != nil && m.RechargeExchangeScale != nil {
		return *m.RechargeExchangeScale
	}
	return 0
}

func (m *LuaGlobalConfig) GetBathFullnessUpperlimit() int32 {
	if m != nil && m.BathFullnessUpperlimit != nil {
		return *m.BathFullnessUpperlimit
	}
	return 0
}

func (m *LuaGlobalConfig) GetInitCarport() int32 {
	if m != nil && m.InitCarport != nil {
		return *m.InitCarport
	}
	return 0
}

func (m *LuaGlobalConfig) GetInitRepairCarCount() int32 {
	if m != nil && m.InitRepairCarCount != nil {
		return *m.InitRepairCarCount
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkStopCDTime() int32 {
	if m != nil && m.ParkStopCDTime != nil {
		return *m.ParkStopCDTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkProtectCDTime() int32 {
	if m != nil && m.ParkProtectCDTime != nil {
		return *m.ParkProtectCDTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkBreakProtectCDTime() int32 {
	if m != nil && m.ParkBreakProtectCDTime != nil {
		return *m.ParkBreakProtectCDTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkRepairUnitTime() int32 {
	if m != nil && m.ParkRepairUnitTime != nil {
		return *m.ParkRepairUnitTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetDiamondReduceRepairCarTime() int32 {
	if m != nil && m.DiamondReduceRepairCarTime != nil {
		return *m.DiamondReduceRepairCarTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetFastRepairUseItemID() int32 {
	if m != nil && m.FastRepairUseItemID != nil {
		return *m.FastRepairUseItemID
	}
	return 0
}

func (m *LuaGlobalConfig) GetItemReduceRepairCarTime() int32 {
	if m != nil && m.ItemReduceRepairCarTime != nil {
		return *m.ItemReduceRepairCarTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetLastCarProtectTime() int32 {
	if m != nil && m.LastCarProtectTime != nil {
		return *m.LastCarProtectTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkSayYesLimitTime() int32 {
	if m != nil && m.ParkSayYesLimitTime != nil {
		return *m.ParkSayYesLimitTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkBenefitUnitTime() int32 {
	if m != nil && m.ParkBenefitUnitTime != nil {
		return *m.ParkBenefitUnitTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetCarportProtectTime() int32 {
	if m != nil && m.CarportProtectTime != nil {
		return *m.CarportProtectTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetFullParkBenefitRate() float32 {
	if m != nil && m.FullParkBenefitRate != nil {
		return *m.FullParkBenefitRate
	}
	return 0
}

func (m *LuaGlobalConfig) GetFullParkRewardID() int32 {
	if m != nil && m.FullParkRewardID != nil {
		return *m.FullParkRewardID
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkBreakGetBenefitRate() float32 {
	if m != nil && m.ParkBreakGetBenefitRate != nil {
		return *m.ParkBreakGetBenefitRate
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkActCount() int32 {
	if m != nil && m.ParkActCount != nil {
		return *m.ParkActCount
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkActRefreshTime() int32 {
	if m != nil && m.ParkActRefreshTime != nil {
		return *m.ParkActRefreshTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkGetExpUnitTime() int32 {
	if m != nil && m.ParkGetExpUnitTime != nil {
		return *m.ParkGetExpUnitTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkSayYesGetExp() int32 {
	if m != nil && m.ParkSayYesGetExp != nil {
		return *m.ParkSayYesGetExp
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkBreakGetExp() int32 {
	if m != nil && m.ParkBreakGetExp != nil {
		return *m.ParkBreakGetExp
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkGetRewardProb() int32 {
	if m != nil && m.ParkGetRewardProb != nil {
		return *m.ParkGetRewardProb
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkSayYesGetRewardProb() int32 {
	if m != nil && m.ParkSayYesGetRewardProb != nil {
		return *m.ParkSayYesGetRewardProb
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkBreakGetRewardProb() int32 {
	if m != nil && m.ParkBreakGetRewardProb != nil {
		return *m.ParkBreakGetRewardProb
	}
	return 0
}

func (m *LuaGlobalConfig) GetSystemParkRefreshTime() int32 {
	if m != nil && m.SystemParkRefreshTime != nil {
		return *m.SystemParkRefreshTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetSystemParkMaxCount() int32 {
	if m != nil && m.SystemParkMaxCount != nil {
		return *m.SystemParkMaxCount
	}
	return 0
}

func (m *LuaGlobalConfig) GetSystemParkByLeftCount() int32 {
	if m != nil && m.SystemParkByLeftCount != nil {
		return *m.SystemParkByLeftCount
	}
	return 0
}

func (m *LuaGlobalConfig) GetSystemParkRandomCaridList() []int32 {
	if m != nil {
		return m.SystemParkRandomCaridList
	}
	return nil
}

func (m *LuaGlobalConfig) GetParkStayTimeAfterFullTime() int32 {
	if m != nil && m.ParkStayTimeAfterFullTime != nil {
		return *m.ParkStayTimeAfterFullTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkShopRefreshCarCount() int32 {
	if m != nil && m.ParkShopRefreshCarCount != nil {
		return *m.ParkShopRefreshCarCount
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkDetailMaxCount() int32 {
	if m != nil && m.ParkDetailMaxCount != nil {
		return *m.ParkDetailMaxCount
	}
	return 0
}

func (m *LuaGlobalConfig) GetParkSayYesProb() int32 {
	if m != nil && m.ParkSayYesProb != nil {
		return *m.ParkSayYesProb
	}
	return 0
}

func (m *LuaGlobalConfig) GetCarPartID() int32 {
	if m != nil && m.CarPartID != nil {
		return *m.CarPartID
	}
	return 0
}

func (m *LuaGlobalConfig) GetInteractNpcList() []int32 {
	if m != nil {
		return m.InteractNpcList
	}
	return nil
}

func (m *LuaGlobalConfig) GetHangupRestrictList() []int32 {
	if m != nil {
		return m.HangupRestrictList
	}
	return nil
}

func (m *LuaGlobalConfig) GetBathRecoveryUpperLimit() int32 {
	if m != nil && m.BathRecoveryUpperLimit != nil {
		return *m.BathRecoveryUpperLimit
	}
	return 0
}

func (m *LuaGlobalConfig) GetBathRecoveryInterval() int32 {
	if m != nil && m.BathRecoveryInterval != nil {
		return *m.BathRecoveryInterval
	}
	return 0
}

func (m *LuaGlobalConfig) GetBathOnceTimeList() []*BathOnceStimina {
	if m != nil {
		return m.BathOnceTimeList
	}
	return nil
}

func (m *LuaGlobalConfig) GetAddSwordItemList() []int32 {
	if m != nil {
		return m.AddSwordItemList
	}
	return nil
}

func (m *LuaGlobalConfig) GetChargeSkillBookItemID() int32 {
	if m != nil && m.ChargeSkillBookItemID != nil {
		return *m.ChargeSkillBookItemID
	}
	return 0
}

func (m *LuaGlobalConfig) GetPetTalentRebuildCostList() []*ItemConfig {
	if m != nil {
		return m.PetTalentRebuildCostList
	}
	return nil
}

func (m *LuaGlobalConfig) GetCostInterval() *EquipEnduranceCost {
	if m != nil {
		return m.CostInterval
	}
	return nil
}

func (m *LuaGlobalConfig) GetPetRefreshTimeList() []int32 {
	if m != nil {
		return m.PetRefreshTimeList
	}
	return nil
}

func (m *LuaGlobalConfig) GetUploadHeadImageCostList() []*ItemConfig {
	if m != nil {
		return m.UploadHeadImageCostList
	}
	return nil
}

func (m *LuaGlobalConfig) GetForeverUploadHeadImageCostList() []*ItemConfig {
	if m != nil {
		return m.ForeverUploadHeadImageCostList
	}
	return nil
}

func (m *LuaGlobalConfig) GetHorseSpeed() int32 {
	if m != nil && m.HorseSpeed != nil {
		return *m.HorseSpeed
	}
	return 0
}

func (m *LuaGlobalConfig) GetHorseInterval() float32 {
	if m != nil && m.HorseInterval != nil {
		return *m.HorseInterval
	}
	return 0
}

func (m *LuaGlobalConfig) GetCaliburnCountLimit() int32 {
	if m != nil && m.CaliburnCountLimit != nil {
		return *m.CaliburnCountLimit
	}
	return 0
}

func (m *LuaGlobalConfig) GetCannonPosList() []*LuaPos {
	if m != nil {
		return m.CannonPosList
	}
	return nil
}

func (m *LuaGlobalConfig) GetFightFriendTime() int32 {
	if m != nil && m.FightFriendTime != nil {
		return *m.FightFriendTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetGreenHatLimit() int32 {
	if m != nil && m.GreenHatLimit != nil {
		return *m.GreenHatLimit
	}
	return 0
}

func (m *LuaGlobalConfig) GetGreenHatGap() int32 {
	if m != nil && m.GreenHatGap != nil {
		return *m.GreenHatGap
	}
	return 0
}

func (m *LuaGlobalConfig) GetGuadraticMaxRole() int32 {
	if m != nil && m.GuadraticMaxRole != nil {
		return *m.GuadraticMaxRole
	}
	return 0
}

func (m *LuaGlobalConfig) GetGuadraticMaxCount() int32 {
	if m != nil && m.GuadraticMaxCount != nil {
		return *m.GuadraticMaxCount
	}
	return 0
}

func (m *LuaGlobalConfig) GetGuadraticCost() *ItemConfig {
	if m != nil {
		return m.GuadraticCost
	}
	return nil
}

func (m *LuaGlobalConfig) GetGuadraticOpenTimeList() []*TimeRange {
	if m != nil {
		return m.GuadraticOpenTimeList
	}
	return nil
}

func (m *LuaGlobalConfig) GetGuadraticStartCDTime() int32 {
	if m != nil && m.GuadraticStartCDTime != nil {
		return *m.GuadraticStartCDTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetGuadraticQuitCD() int32 {
	if m != nil && m.GuadraticQuitCD != nil {
		return *m.GuadraticQuitCD
	}
	return 0
}

func (m *LuaGlobalConfig) GetGuadraticEndHurtCD() int32 {
	if m != nil && m.GuadraticEndHurtCD != nil {
		return *m.GuadraticEndHurtCD
	}
	return 0
}

func (m *LuaGlobalConfig) GetGuadraticEndHurt() int32 {
	if m != nil && m.GuadraticEndHurt != nil {
		return *m.GuadraticEndHurt
	}
	return 0
}

func (m *LuaGlobalConfig) GetGuadraticAtkCD() int32 {
	if m != nil && m.GuadraticAtkCD != nil {
		return *m.GuadraticAtkCD
	}
	return 0
}

func (m *LuaGlobalConfig) GetGuadraticUnderAtkCD() int32 {
	if m != nil && m.GuadraticUnderAtkCD != nil {
		return *m.GuadraticUnderAtkCD
	}
	return 0
}

func (m *LuaGlobalConfig) GetGuadraticHP() int32 {
	if m != nil && m.GuadraticHP != nil {
		return *m.GuadraticHP
	}
	return 0
}

func (m *LuaGlobalConfig) GetGuadraticHurt() int32 {
	if m != nil && m.GuadraticHurt != nil {
		return *m.GuadraticHurt
	}
	return 0
}

func (m *LuaGlobalConfig) GetLevelRankNum() int32 {
	if m != nil && m.LevelRankNum != nil {
		return *m.LevelRankNum
	}
	return 0
}

func (m *LuaGlobalConfig) GetKillRankNum() int32 {
	if m != nil && m.KillRankNum != nil {
		return *m.KillRankNum
	}
	return 0
}

func (m *LuaGlobalConfig) GetDiamondRankNum() int32 {
	if m != nil && m.DiamondRankNum != nil {
		return *m.DiamondRankNum
	}
	return 0
}

func (m *LuaGlobalConfig) GetMinigameRankNum() int32 {
	if m != nil && m.MinigameRankNum != nil {
		return *m.MinigameRankNum
	}
	return 0
}

func (m *LuaGlobalConfig) GetFaceDupReturnItem() *ItemConfig {
	if m != nil {
		return m.FaceDupReturnItem
	}
	return nil
}

func (m *LuaGlobalConfig) GetSellBagGridMaxNum() int32 {
	if m != nil && m.SellBagGridMaxNum != nil {
		return *m.SellBagGridMaxNum
	}
	return 0
}

func (m *LuaGlobalConfig) GetFirstSaveMoneryRewardList() []*ItemConfig {
	if m != nil {
		return m.FirstSaveMoneryRewardList
	}
	return nil
}

func (m *LuaGlobalConfig) GetWeixinRewardList() []*ItemConfig {
	if m != nil {
		return m.WeixinRewardList
	}
	return nil
}

func (m *LuaGlobalConfig) GetRechargeLimit() int64 {
	if m != nil && m.RechargeLimit != nil {
		return *m.RechargeLimit
	}
	return 0
}

func (m *LuaGlobalConfig) GetPetEggReturnItemList() []*ItemConfig {
	if m != nil {
		return m.PetEggReturnItemList
	}
	return nil
}

func (m *LuaGlobalConfig) GetFriendNumLimit() int32 {
	if m != nil && m.FriendNumLimit != nil {
		return *m.FriendNumLimit
	}
	return 0
}

func (m *LuaGlobalConfig) GetPianoTime() int32 {
	if m != nil && m.PianoTime != nil {
		return *m.PianoTime
	}
	return 0
}

func (m *LuaGlobalConfig) GetUnlockBattleSpeedLevel() int32 {
	if m != nil && m.UnlockBattleSpeedLevel != nil {
		return *m.UnlockBattleSpeedLevel
	}
	return 0
}

func (m *LuaGlobalConfig) GetPvpAtkRate() float32 {
	if m != nil && m.PvpAtkRate != nil {
		return *m.PvpAtkRate
	}
	return 0
}

func (m *LuaGlobalConfig) GetPvpDefRate() float32 {
	if m != nil && m.PvpDefRate != nil {
		return *m.PvpDefRate
	}
	return 0
}

func (m *LuaGlobalConfig) GetDiamondFaceNum() int32 {
	if m != nil && m.DiamondFaceNum != nil {
		return *m.DiamondFaceNum
	}
	return 0
}

func (m *LuaGlobalConfig) GetGoldFaceNum() int32 {
	if m != nil && m.GoldFaceNum != nil {
		return *m.GoldFaceNum
	}
	return 0
}

func (m *LuaGlobalConfig) GetInitRoleAttr() []int32 {
	if m != nil {
		return m.InitRoleAttr
	}
	return nil
}

func (m *LuaGlobalConfig) GetPerLevelAttr() []int32 {
	if m != nil {
		return m.PerLevelAttr
	}
	return nil
}

func (m *LuaGlobalConfig) GetFightParameter() []int32 {
	if m != nil {
		return m.FightParameter
	}
	return nil
}

func (m *LuaGlobalConfig) GetDailyGameItemList() []*ItemConfig {
	if m != nil {
		return m.DailyGameItemList
	}
	return nil
}

// Excel:j交互系统表.xls sheet:交互系统动作
type LuaInteractSystem struct {
	Id                   *int32            `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	Type                 *int32            `protobuf:"zigzag32,2,opt,name=type" json:"type,omitempty"`
	ChildInteract        []int32           `protobuf:"zigzag32,3,rep,name=childInteract" json:"childInteract,omitempty"`
	NameID               []byte            `protobuf:"bytes,4,opt,name=nameID" json:"nameID,omitempty"`
	ActDesID             []byte            `protobuf:"bytes,5,opt,name=actDesID" json:"actDesID,omitempty"`
	UnlockCondition      []*InteractUnlock `protobuf:"bytes,6,rep,name=unlockCondition" json:"unlockCondition,omitempty"`
	EnergyPoint          *int32            `protobuf:"zigzag32,7,opt,name=energyPoint" json:"energyPoint,omitempty"`
	IconID               *int32            `protobuf:"zigzag32,8,opt,name=iconID" json:"iconID,omitempty"`
	InitiatorCSB         []byte            `protobuf:"bytes,9,opt,name=initiatorCSB" json:"initiatorCSB,omitempty"`
	InitiatorAction      []byte            `protobuf:"bytes,10,opt,name=initiatorAction" json:"initiatorAction,omitempty"`
	InitiatorSound       []byte            `protobuf:"bytes,11,opt,name=initiatorSound" json:"initiatorSound,omitempty"`
	InitiatorAction2     []byte            `protobuf:"bytes,12,opt,name=initiatorAction2" json:"initiatorAction2,omitempty"`
	InitiatorEffect      []byte            `protobuf:"bytes,13,opt,name=initiatorEffect" json:"initiatorEffect,omitempty"`
	InitiatorEffectFail  []byte            `protobuf:"bytes,14,opt,name=initiatorEffectFail" json:"initiatorEffectFail,omitempty"`
	LoopType             *int32            `protobuf:"zigzag32,15,opt,name=loopType" json:"loopType,omitempty"`
	InitiatorHideEffect  *int32            `protobuf:"zigzag32,16,opt,name=initiatorHideEffect" json:"initiatorHideEffect,omitempty"`
	ConsumerHideEffect   *int32            `protobuf:"zigzag32,17,opt,name=consumerHideEffect" json:"consumerHideEffect,omitempty"`
	ConsumerType         *int32            `protobuf:"zigzag32,18,opt,name=consumerType" json:"consumerType,omitempty"`
	ConsumerTime         *float32          `protobuf:"fixed32,19,opt,name=consumerTime" json:"consumerTime,omitempty"`
	ColorDuration        *float32          `protobuf:"fixed32,20,opt,name=colorDuration" json:"colorDuration,omitempty"`
	ColorRGB             *LuaRgba          `protobuf:"bytes,21,opt,name=colorRGB" json:"colorRGB,omitempty"`
	ConsumerEffect       []byte            `protobuf:"bytes,22,opt,name=consumerEffect" json:"consumerEffect,omitempty"`
	ConsumerCSB          []byte            `protobuf:"bytes,23,opt,name=consumerCSB" json:"consumerCSB,omitempty"`
	ConsumerAction       []byte            `protobuf:"bytes,24,opt,name=consumerAction" json:"consumerAction,omitempty"`
	ConsumerSound        []byte            `protobuf:"bytes,25,opt,name=consumerSound" json:"consumerSound,omitempty"`
	DeltaPos             []int32           `protobuf:"zigzag32,26,rep,name=deltaPos" json:"deltaPos,omitempty"`
	EffectType           *int32            `protobuf:"zigzag32,27,opt,name=effectType" json:"effectType,omitempty"`
	Radius               *int32            `protobuf:"zigzag32,28,opt,name=radius" json:"radius,omitempty"`
	Size_                []int32           `protobuf:"zigzag32,29,rep,name=size" json:"size,omitempty"`
	SortLevel            *int32            `protobuf:"zigzag32,30,opt,name=sortLevel" json:"sortLevel,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *LuaInteractSystem) Reset()         { *m = LuaInteractSystem{} }
func (m *LuaInteractSystem) String() string { return proto.CompactTextString(m) }
func (*LuaInteractSystem) ProtoMessage()    {}
func (*LuaInteractSystem) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{99}
}
func (m *LuaInteractSystem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaInteractSystem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaInteractSystem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaInteractSystem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaInteractSystem.Merge(m, src)
}
func (m *LuaInteractSystem) XXX_Size() int {
	return m.Size()
}
func (m *LuaInteractSystem) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaInteractSystem.DiscardUnknown(m)
}

var xxx_messageInfo_LuaInteractSystem proto.InternalMessageInfo

func (m *LuaInteractSystem) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaInteractSystem) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaInteractSystem) GetChildInteract() []int32 {
	if m != nil {
		return m.ChildInteract
	}
	return nil
}

func (m *LuaInteractSystem) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaInteractSystem) GetActDesID() []byte {
	if m != nil {
		return m.ActDesID
	}
	return nil
}

func (m *LuaInteractSystem) GetUnlockCondition() []*InteractUnlock {
	if m != nil {
		return m.UnlockCondition
	}
	return nil
}

func (m *LuaInteractSystem) GetEnergyPoint() int32 {
	if m != nil && m.EnergyPoint != nil {
		return *m.EnergyPoint
	}
	return 0
}

func (m *LuaInteractSystem) GetIconID() int32 {
	if m != nil && m.IconID != nil {
		return *m.IconID
	}
	return 0
}

func (m *LuaInteractSystem) GetInitiatorCSB() []byte {
	if m != nil {
		return m.InitiatorCSB
	}
	return nil
}

func (m *LuaInteractSystem) GetInitiatorAction() []byte {
	if m != nil {
		return m.InitiatorAction
	}
	return nil
}

func (m *LuaInteractSystem) GetInitiatorSound() []byte {
	if m != nil {
		return m.InitiatorSound
	}
	return nil
}

func (m *LuaInteractSystem) GetInitiatorAction2() []byte {
	if m != nil {
		return m.InitiatorAction2
	}
	return nil
}

func (m *LuaInteractSystem) GetInitiatorEffect() []byte {
	if m != nil {
		return m.InitiatorEffect
	}
	return nil
}

func (m *LuaInteractSystem) GetInitiatorEffectFail() []byte {
	if m != nil {
		return m.InitiatorEffectFail
	}
	return nil
}

func (m *LuaInteractSystem) GetLoopType() int32 {
	if m != nil && m.LoopType != nil {
		return *m.LoopType
	}
	return 0
}

func (m *LuaInteractSystem) GetInitiatorHideEffect() int32 {
	if m != nil && m.InitiatorHideEffect != nil {
		return *m.InitiatorHideEffect
	}
	return 0
}

func (m *LuaInteractSystem) GetConsumerHideEffect() int32 {
	if m != nil && m.ConsumerHideEffect != nil {
		return *m.ConsumerHideEffect
	}
	return 0
}

func (m *LuaInteractSystem) GetConsumerType() int32 {
	if m != nil && m.ConsumerType != nil {
		return *m.ConsumerType
	}
	return 0
}

func (m *LuaInteractSystem) GetConsumerTime() float32 {
	if m != nil && m.ConsumerTime != nil {
		return *m.ConsumerTime
	}
	return 0
}

func (m *LuaInteractSystem) GetColorDuration() float32 {
	if m != nil && m.ColorDuration != nil {
		return *m.ColorDuration
	}
	return 0
}

func (m *LuaInteractSystem) GetColorRGB() *LuaRgba {
	if m != nil {
		return m.ColorRGB
	}
	return nil
}

func (m *LuaInteractSystem) GetConsumerEffect() []byte {
	if m != nil {
		return m.ConsumerEffect
	}
	return nil
}

func (m *LuaInteractSystem) GetConsumerCSB() []byte {
	if m != nil {
		return m.ConsumerCSB
	}
	return nil
}

func (m *LuaInteractSystem) GetConsumerAction() []byte {
	if m != nil {
		return m.ConsumerAction
	}
	return nil
}

func (m *LuaInteractSystem) GetConsumerSound() []byte {
	if m != nil {
		return m.ConsumerSound
	}
	return nil
}

func (m *LuaInteractSystem) GetDeltaPos() []int32 {
	if m != nil {
		return m.DeltaPos
	}
	return nil
}

func (m *LuaInteractSystem) GetEffectType() int32 {
	if m != nil && m.EffectType != nil {
		return *m.EffectType
	}
	return 0
}

func (m *LuaInteractSystem) GetRadius() int32 {
	if m != nil && m.Radius != nil {
		return *m.Radius
	}
	return 0
}

func (m *LuaInteractSystem) GetSize_() []int32 {
	if m != nil {
		return m.Size_
	}
	return nil
}

func (m *LuaInteractSystem) GetSortLevel() int32 {
	if m != nil && m.SortLevel != nil {
		return *m.SortLevel
	}
	return 0
}

// Excel:q抢车位.xls sheet:老司机等级
type LuaParkDriver struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	Exp                  *int32   `protobuf:"zigzag32,2,opt,name=exp" json:"exp,omitempty"`
	BreakProbList        []int32  `protobuf:"zigzag32,3,rep,name=breakProbList" json:"breakProbList,omitempty"`
	BreakGetRewardItem   []int32  `protobuf:"zigzag32,4,rep,name=breakGetRewardItem" json:"breakGetRewardItem,omitempty"`
	SayYesProbList       []int32  `protobuf:"zigzag32,5,rep,name=sayYesProbList" json:"sayYesProbList,omitempty"`
	SayYesGetRewardItem  []int32  `protobuf:"zigzag32,6,rep,name=sayYesGetRewardItem" json:"sayYesGetRewardItem,omitempty"`
	SayYesExRewardItem   []int32  `protobuf:"zigzag32,7,rep,name=sayYesExRewardItem" json:"sayYesExRewardItem,omitempty"`
	RandomItemRange      []int32  `protobuf:"zigzag32,8,rep,name=randomItemRange" json:"randomItemRange,omitempty"`
	GetCarportCount      *int32   `protobuf:"zigzag32,9,opt,name=getCarportCount" json:"getCarportCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaParkDriver) Reset()         { *m = LuaParkDriver{} }
func (m *LuaParkDriver) String() string { return proto.CompactTextString(m) }
func (*LuaParkDriver) ProtoMessage()    {}
func (*LuaParkDriver) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{100}
}
func (m *LuaParkDriver) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaParkDriver) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaParkDriver.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaParkDriver) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaParkDriver.Merge(m, src)
}
func (m *LuaParkDriver) XXX_Size() int {
	return m.Size()
}
func (m *LuaParkDriver) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaParkDriver.DiscardUnknown(m)
}

var xxx_messageInfo_LuaParkDriver proto.InternalMessageInfo

func (m *LuaParkDriver) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaParkDriver) GetExp() int32 {
	if m != nil && m.Exp != nil {
		return *m.Exp
	}
	return 0
}

func (m *LuaParkDriver) GetBreakProbList() []int32 {
	if m != nil {
		return m.BreakProbList
	}
	return nil
}

func (m *LuaParkDriver) GetBreakGetRewardItem() []int32 {
	if m != nil {
		return m.BreakGetRewardItem
	}
	return nil
}

func (m *LuaParkDriver) GetSayYesProbList() []int32 {
	if m != nil {
		return m.SayYesProbList
	}
	return nil
}

func (m *LuaParkDriver) GetSayYesGetRewardItem() []int32 {
	if m != nil {
		return m.SayYesGetRewardItem
	}
	return nil
}

func (m *LuaParkDriver) GetSayYesExRewardItem() []int32 {
	if m != nil {
		return m.SayYesExRewardItem
	}
	return nil
}

func (m *LuaParkDriver) GetRandomItemRange() []int32 {
	if m != nil {
		return m.RandomItemRange
	}
	return nil
}

func (m *LuaParkDriver) GetGetCarportCount() int32 {
	if m != nil && m.GetCarportCount != nil {
		return *m.GetCarportCount
	}
	return 0
}

// Excel:家园表.xls sheet:商店表
type LuaHouseShop struct {
	Id                   *int32      `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	FurnitureID          *int32      `protobuf:"zigzag32,2,opt,name=furnitureID" json:"furnitureID,omitempty"`
	NeedHouseLevel       *int32      `protobuf:"zigzag32,3,opt,name=needHouseLevel" json:"needHouseLevel,omitempty"`
	NeedVipLevel         *int32      `protobuf:"zigzag32,4,opt,name=needVipLevel" json:"needVipLevel,omitempty"`
	CostItem             *ItemConfig `protobuf:"bytes,5,opt,name=costItem" json:"costItem,omitempty"`
	IsNew                *int32      `protobuf:"zigzag32,6,opt,name=isNew" json:"isNew,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *LuaHouseShop) Reset()         { *m = LuaHouseShop{} }
func (m *LuaHouseShop) String() string { return proto.CompactTextString(m) }
func (*LuaHouseShop) ProtoMessage()    {}
func (*LuaHouseShop) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{101}
}
func (m *LuaHouseShop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaHouseShop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaHouseShop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaHouseShop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaHouseShop.Merge(m, src)
}
func (m *LuaHouseShop) XXX_Size() int {
	return m.Size()
}
func (m *LuaHouseShop) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaHouseShop.DiscardUnknown(m)
}

var xxx_messageInfo_LuaHouseShop proto.InternalMessageInfo

func (m *LuaHouseShop) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaHouseShop) GetFurnitureID() int32 {
	if m != nil && m.FurnitureID != nil {
		return *m.FurnitureID
	}
	return 0
}

func (m *LuaHouseShop) GetNeedHouseLevel() int32 {
	if m != nil && m.NeedHouseLevel != nil {
		return *m.NeedHouseLevel
	}
	return 0
}

func (m *LuaHouseShop) GetNeedVipLevel() int32 {
	if m != nil && m.NeedVipLevel != nil {
		return *m.NeedVipLevel
	}
	return 0
}

func (m *LuaHouseShop) GetCostItem() *ItemConfig {
	if m != nil {
		return m.CostItem
	}
	return nil
}

func (m *LuaHouseShop) GetIsNew() int32 {
	if m != nil && m.IsNew != nil {
		return *m.IsNew
	}
	return 0
}

// Excel:小面板引导表.xls sheet:小面板引导表
type LuaFindwayGuid struct {
	Id                   *int32       `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	DescID               []byte       `protobuf:"bytes,2,opt,name=descID" json:"descID,omitempty"`
	SceneID              *int32       `protobuf:"zigzag32,3,opt,name=sceneID" json:"sceneID,omitempty"`
	NpcID                *int32       `protobuf:"zigzag32,4,opt,name=npcID" json:"npcID,omitempty"`
	SuggestLevel         *int32       `protobuf:"zigzag32,5,opt,name=suggestLevel" json:"suggestLevel,omitempty"`
	ReachLevel           *int32       `protobuf:"zigzag32,6,opt,name=reachLevel" json:"reachLevel,omitempty"`
	AccecpTaskID         *int32       `protobuf:"zigzag32,7,opt,name=accecpTaskID" json:"accecpTaskID,omitempty"`
	FinishTaskID         *int32       `protobuf:"zigzag32,8,opt,name=finishTaskID" json:"finishTaskID,omitempty"`
	FinishChapterRisk    *ChapterRisk `protobuf:"bytes,9,opt,name=finishChapterRisk" json:"finishChapterRisk,omitempty"`
	LockRisk             *int32       `protobuf:"zigzag32,10,opt,name=lockRisk" json:"lockRisk,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *LuaFindwayGuid) Reset()         { *m = LuaFindwayGuid{} }
func (m *LuaFindwayGuid) String() string { return proto.CompactTextString(m) }
func (*LuaFindwayGuid) ProtoMessage()    {}
func (*LuaFindwayGuid) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{102}
}
func (m *LuaFindwayGuid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaFindwayGuid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaFindwayGuid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaFindwayGuid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaFindwayGuid.Merge(m, src)
}
func (m *LuaFindwayGuid) XXX_Size() int {
	return m.Size()
}
func (m *LuaFindwayGuid) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaFindwayGuid.DiscardUnknown(m)
}

var xxx_messageInfo_LuaFindwayGuid proto.InternalMessageInfo

func (m *LuaFindwayGuid) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaFindwayGuid) GetDescID() []byte {
	if m != nil {
		return m.DescID
	}
	return nil
}

func (m *LuaFindwayGuid) GetSceneID() int32 {
	if m != nil && m.SceneID != nil {
		return *m.SceneID
	}
	return 0
}

func (m *LuaFindwayGuid) GetNpcID() int32 {
	if m != nil && m.NpcID != nil {
		return *m.NpcID
	}
	return 0
}

func (m *LuaFindwayGuid) GetSuggestLevel() int32 {
	if m != nil && m.SuggestLevel != nil {
		return *m.SuggestLevel
	}
	return 0
}

func (m *LuaFindwayGuid) GetReachLevel() int32 {
	if m != nil && m.ReachLevel != nil {
		return *m.ReachLevel
	}
	return 0
}

func (m *LuaFindwayGuid) GetAccecpTaskID() int32 {
	if m != nil && m.AccecpTaskID != nil {
		return *m.AccecpTaskID
	}
	return 0
}

func (m *LuaFindwayGuid) GetFinishTaskID() int32 {
	if m != nil && m.FinishTaskID != nil {
		return *m.FinishTaskID
	}
	return 0
}

func (m *LuaFindwayGuid) GetFinishChapterRisk() *ChapterRisk {
	if m != nil {
		return m.FinishChapterRisk
	}
	return nil
}

func (m *LuaFindwayGuid) GetLockRisk() int32 {
	if m != nil && m.LockRisk != nil {
		return *m.LockRisk
	}
	return 0
}

// Excel:q抢车位.xls sheet:车库扩充价格
type LuaParkGaragePort struct {
	Id                   *int32        `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	CostItemList         []*ItemConfig `protobuf:"bytes,2,rep,name=costItemList" json:"costItemList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaParkGaragePort) Reset()         { *m = LuaParkGaragePort{} }
func (m *LuaParkGaragePort) String() string { return proto.CompactTextString(m) }
func (*LuaParkGaragePort) ProtoMessage()    {}
func (*LuaParkGaragePort) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{103}
}
func (m *LuaParkGaragePort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaParkGaragePort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaParkGaragePort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaParkGaragePort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaParkGaragePort.Merge(m, src)
}
func (m *LuaParkGaragePort) XXX_Size() int {
	return m.Size()
}
func (m *LuaParkGaragePort) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaParkGaragePort.DiscardUnknown(m)
}

var xxx_messageInfo_LuaParkGaragePort proto.InternalMessageInfo

func (m *LuaParkGaragePort) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaParkGaragePort) GetCostItemList() []*ItemConfig {
	if m != nil {
		return m.CostItemList
	}
	return nil
}

// Excel:j交互系统表.xls sheet:交互图鉴奖励
type LuaInteractManual struct {
	Num                  *int32        `protobuf:"zigzag32,1,opt,name=num" json:"num,omitempty"`
	Energy               *int32        `protobuf:"zigzag32,2,opt,name=energy" json:"energy,omitempty"`
	RewardList           []*ItemConfig `protobuf:"bytes,3,rep,name=rewardList" json:"rewardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaInteractManual) Reset()         { *m = LuaInteractManual{} }
func (m *LuaInteractManual) String() string { return proto.CompactTextString(m) }
func (*LuaInteractManual) ProtoMessage()    {}
func (*LuaInteractManual) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{104}
}
func (m *LuaInteractManual) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaInteractManual) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaInteractManual.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaInteractManual) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaInteractManual.Merge(m, src)
}
func (m *LuaInteractManual) XXX_Size() int {
	return m.Size()
}
func (m *LuaInteractManual) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaInteractManual.DiscardUnknown(m)
}

var xxx_messageInfo_LuaInteractManual proto.InternalMessageInfo

func (m *LuaInteractManual) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

func (m *LuaInteractManual) GetEnergy() int32 {
	if m != nil && m.Energy != nil {
		return *m.Energy
	}
	return 0
}

func (m *LuaInteractManual) GetRewardList() []*ItemConfig {
	if m != nil {
		return m.RewardList
	}
	return nil
}

// Excel:avatar表情.xls sheet:face_discount
type LuaFaceDiscount struct {
	Index                *int32   `protobuf:"zigzag32,1,opt,name=index" json:"index,omitempty"`
	Id                   *int32   `protobuf:"zigzag32,2,opt,name=id" json:"id,omitempty"`
	Duration             []int32  `protobuf:"zigzag32,3,rep,name=duration" json:"duration,omitempty"`
	CostType             *int32   `protobuf:"zigzag32,4,opt,name=costType" json:"costType,omitempty"`
	Price                []int32  `protobuf:"zigzag32,5,rep,name=price" json:"price,omitempty"`
	Discount             *int32   `protobuf:"zigzag32,6,opt,name=discount" json:"discount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaFaceDiscount) Reset()         { *m = LuaFaceDiscount{} }
func (m *LuaFaceDiscount) String() string { return proto.CompactTextString(m) }
func (*LuaFaceDiscount) ProtoMessage()    {}
func (*LuaFaceDiscount) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{105}
}
func (m *LuaFaceDiscount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaFaceDiscount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaFaceDiscount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaFaceDiscount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaFaceDiscount.Merge(m, src)
}
func (m *LuaFaceDiscount) XXX_Size() int {
	return m.Size()
}
func (m *LuaFaceDiscount) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaFaceDiscount.DiscardUnknown(m)
}

var xxx_messageInfo_LuaFaceDiscount proto.InternalMessageInfo

func (m *LuaFaceDiscount) GetIndex() int32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *LuaFaceDiscount) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaFaceDiscount) GetDuration() []int32 {
	if m != nil {
		return m.Duration
	}
	return nil
}

func (m *LuaFaceDiscount) GetCostType() int32 {
	if m != nil && m.CostType != nil {
		return *m.CostType
	}
	return 0
}

func (m *LuaFaceDiscount) GetPrice() []int32 {
	if m != nil {
		return m.Price
	}
	return nil
}

func (m *LuaFaceDiscount) GetDiscount() int32 {
	if m != nil && m.Discount != nil {
		return *m.Discount
	}
	return 0
}

// Excel:q抢车位.xls sheet:事件表
type LuaParkEvent struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte   `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	DescID               []byte   `protobuf:"bytes,3,opt,name=descID" json:"descID,omitempty"`
	TotalTime            *int32   `protobuf:"zigzag32,4,opt,name=totalTime" json:"totalTime,omitempty"`
	CdTime               *int32   `protobuf:"zigzag32,5,opt,name=cdTime" json:"cdTime,omitempty"`
	CondList             []int32  `protobuf:"zigzag32,6,rep,name=condList" json:"condList,omitempty"`
	SelectCarEffectList  []int32  `protobuf:"zigzag32,7,rep,name=selectCarEffectList" json:"selectCarEffectList,omitempty"`
	ExCarEffectList      []int32  `protobuf:"zigzag32,8,rep,name=exCarEffectList" json:"exCarEffectList,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaParkEvent) Reset()         { *m = LuaParkEvent{} }
func (m *LuaParkEvent) String() string { return proto.CompactTextString(m) }
func (*LuaParkEvent) ProtoMessage()    {}
func (*LuaParkEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{106}
}
func (m *LuaParkEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaParkEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaParkEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaParkEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaParkEvent.Merge(m, src)
}
func (m *LuaParkEvent) XXX_Size() int {
	return m.Size()
}
func (m *LuaParkEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaParkEvent.DiscardUnknown(m)
}

var xxx_messageInfo_LuaParkEvent proto.InternalMessageInfo

func (m *LuaParkEvent) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaParkEvent) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaParkEvent) GetDescID() []byte {
	if m != nil {
		return m.DescID
	}
	return nil
}

func (m *LuaParkEvent) GetTotalTime() int32 {
	if m != nil && m.TotalTime != nil {
		return *m.TotalTime
	}
	return 0
}

func (m *LuaParkEvent) GetCdTime() int32 {
	if m != nil && m.CdTime != nil {
		return *m.CdTime
	}
	return 0
}

func (m *LuaParkEvent) GetCondList() []int32 {
	if m != nil {
		return m.CondList
	}
	return nil
}

func (m *LuaParkEvent) GetSelectCarEffectList() []int32 {
	if m != nil {
		return m.SelectCarEffectList
	}
	return nil
}

func (m *LuaParkEvent) GetExCarEffectList() []int32 {
	if m != nil {
		return m.ExCarEffectList
	}
	return nil
}

// Excel:场景表.xls sheet:NPC表
type LuaNpc struct {
	Id                   *int32    `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte    `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	Type                 *int32    `protobuf:"zigzag32,3,opt,name=type" json:"type,omitempty"`
	Head                 []byte    `protobuf:"bytes,4,opt,name=head" json:"head,omitempty"`
	ZOrder               *int32    `protobuf:"zigzag32,5,opt,name=zOrder" json:"zOrder,omitempty"`
	ResType              *int32    `protobuf:"zigzag32,6,opt,name=resType" json:"resType,omitempty"`
	Res                  []byte    `protobuf:"bytes,7,opt,name=res" json:"res,omitempty"`
	Scale                *float32  `protobuf:"fixed32,8,opt,name=scale" json:"scale,omitempty"`
	FlipX                *int32    `protobuf:"zigzag32,9,opt,name=flipX" json:"flipX,omitempty"`
	EffectList           [][]byte  `protobuf:"bytes,10,rep,name=effectList" json:"effectList,omitempty"`
	Pos                  []*LuaPos `protobuf:"bytes,11,rep,name=pos" json:"pos,omitempty"`
	TargetList           []int32   `protobuf:"zigzag32,12,rep,name=targetList" json:"targetList,omitempty"`
	TalkIDList           []int32   `protobuf:"zigzag32,13,rep,name=talkIDList" json:"talkIDList,omitempty"`
	ClickRect            []float32 `protobuf:"fixed32,14,rep,name=clickRect" json:"clickRect,omitempty"`
	TalkHeadPos          *LuaPos   `protobuf:"bytes,15,opt,name=talkHeadPos" json:"talkHeadPos,omitempty"`
	TalkHeadScale        *float32  `protobuf:"fixed32,16,opt,name=talkHeadScale" json:"talkHeadScale,omitempty"`
	MarkPos              *LuaPos   `protobuf:"bytes,17,opt,name=markPos" json:"markPos,omitempty"`
	NamePos              *LuaPos   `protobuf:"bytes,18,opt,name=namePos" json:"namePos,omitempty"`
	FindwayPos           *LuaPos   `protobuf:"bytes,19,opt,name=findwayPos" json:"findwayPos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *LuaNpc) Reset()         { *m = LuaNpc{} }
func (m *LuaNpc) String() string { return proto.CompactTextString(m) }
func (*LuaNpc) ProtoMessage()    {}
func (*LuaNpc) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{107}
}
func (m *LuaNpc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaNpc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaNpc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaNpc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaNpc.Merge(m, src)
}
func (m *LuaNpc) XXX_Size() int {
	return m.Size()
}
func (m *LuaNpc) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaNpc.DiscardUnknown(m)
}

var xxx_messageInfo_LuaNpc proto.InternalMessageInfo

func (m *LuaNpc) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaNpc) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaNpc) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaNpc) GetHead() []byte {
	if m != nil {
		return m.Head
	}
	return nil
}

func (m *LuaNpc) GetZOrder() int32 {
	if m != nil && m.ZOrder != nil {
		return *m.ZOrder
	}
	return 0
}

func (m *LuaNpc) GetResType() int32 {
	if m != nil && m.ResType != nil {
		return *m.ResType
	}
	return 0
}

func (m *LuaNpc) GetRes() []byte {
	if m != nil {
		return m.Res
	}
	return nil
}

func (m *LuaNpc) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return 0
}

func (m *LuaNpc) GetFlipX() int32 {
	if m != nil && m.FlipX != nil {
		return *m.FlipX
	}
	return 0
}

func (m *LuaNpc) GetEffectList() [][]byte {
	if m != nil {
		return m.EffectList
	}
	return nil
}

func (m *LuaNpc) GetPos() []*LuaPos {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *LuaNpc) GetTargetList() []int32 {
	if m != nil {
		return m.TargetList
	}
	return nil
}

func (m *LuaNpc) GetTalkIDList() []int32 {
	if m != nil {
		return m.TalkIDList
	}
	return nil
}

func (m *LuaNpc) GetClickRect() []float32 {
	if m != nil {
		return m.ClickRect
	}
	return nil
}

func (m *LuaNpc) GetTalkHeadPos() *LuaPos {
	if m != nil {
		return m.TalkHeadPos
	}
	return nil
}

func (m *LuaNpc) GetTalkHeadScale() float32 {
	if m != nil && m.TalkHeadScale != nil {
		return *m.TalkHeadScale
	}
	return 0
}

func (m *LuaNpc) GetMarkPos() *LuaPos {
	if m != nil {
		return m.MarkPos
	}
	return nil
}

func (m *LuaNpc) GetNamePos() *LuaPos {
	if m != nil {
		return m.NamePos
	}
	return nil
}

func (m *LuaNpc) GetFindwayPos() *LuaPos {
	if m != nil {
		return m.FindwayPos
	}
	return nil
}

// Excel:饰品属性增益表.xls sheet:饰品属性增益
type LuaWingExtraEffect struct {
	Level                *int32             `protobuf:"zigzag32,1,opt,name=level" json:"level,omitempty"`
	RandomNumList        []*RandomSection   `protobuf:"bytes,2,rep,name=randomNumList" json:"randomNumList,omitempty"`
	ExtraPerList         []*ExtraPerSection `protobuf:"bytes,3,rep,name=extraPerList" json:"extraPerList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *LuaWingExtraEffect) Reset()         { *m = LuaWingExtraEffect{} }
func (m *LuaWingExtraEffect) String() string { return proto.CompactTextString(m) }
func (*LuaWingExtraEffect) ProtoMessage()    {}
func (*LuaWingExtraEffect) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{108}
}
func (m *LuaWingExtraEffect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaWingExtraEffect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaWingExtraEffect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaWingExtraEffect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaWingExtraEffect.Merge(m, src)
}
func (m *LuaWingExtraEffect) XXX_Size() int {
	return m.Size()
}
func (m *LuaWingExtraEffect) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaWingExtraEffect.DiscardUnknown(m)
}

var xxx_messageInfo_LuaWingExtraEffect proto.InternalMessageInfo

func (m *LuaWingExtraEffect) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaWingExtraEffect) GetRandomNumList() []*RandomSection {
	if m != nil {
		return m.RandomNumList
	}
	return nil
}

func (m *LuaWingExtraEffect) GetExtraPerList() []*ExtraPerSection {
	if m != nil {
		return m.ExtraPerList
	}
	return nil
}

// Excel:家园表.xls sheet:扩展表
type LuaHouseExpand struct {
	Id                   *int32      `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	Size_                *LuaSize    `protobuf:"bytes,2,opt,name=size" json:"size,omitempty"`
	Icon                 *int32      `protobuf:"zigzag32,3,opt,name=icon" json:"icon,omitempty"`
	NeedHouseLevel       *int32      `protobuf:"zigzag32,4,opt,name=needHouseLevel" json:"needHouseLevel,omitempty"`
	NeedVipLevel         *int32      `protobuf:"zigzag32,5,opt,name=needVipLevel" json:"needVipLevel,omitempty"`
	CostItem             *ItemConfig `protobuf:"bytes,6,opt,name=costItem" json:"costItem,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *LuaHouseExpand) Reset()         { *m = LuaHouseExpand{} }
func (m *LuaHouseExpand) String() string { return proto.CompactTextString(m) }
func (*LuaHouseExpand) ProtoMessage()    {}
func (*LuaHouseExpand) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{109}
}
func (m *LuaHouseExpand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaHouseExpand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaHouseExpand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaHouseExpand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaHouseExpand.Merge(m, src)
}
func (m *LuaHouseExpand) XXX_Size() int {
	return m.Size()
}
func (m *LuaHouseExpand) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaHouseExpand.DiscardUnknown(m)
}

var xxx_messageInfo_LuaHouseExpand proto.InternalMessageInfo

func (m *LuaHouseExpand) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaHouseExpand) GetSize_() *LuaSize {
	if m != nil {
		return m.Size_
	}
	return nil
}

func (m *LuaHouseExpand) GetIcon() int32 {
	if m != nil && m.Icon != nil {
		return *m.Icon
	}
	return 0
}

func (m *LuaHouseExpand) GetNeedHouseLevel() int32 {
	if m != nil && m.NeedHouseLevel != nil {
		return *m.NeedHouseLevel
	}
	return 0
}

func (m *LuaHouseExpand) GetNeedVipLevel() int32 {
	if m != nil && m.NeedVipLevel != nil {
		return *m.NeedVipLevel
	}
	return 0
}

func (m *LuaHouseExpand) GetCostItem() *ItemConfig {
	if m != nil {
		return m.CostItem
	}
	return nil
}

// Excel:item道具表.xls sheet:道具表
type LuaItem struct {
	Id                   *int32        `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	Type                 *int32        `protobuf:"zigzag32,2,opt,name=type" json:"type,omitempty"`
	NameID               []byte        `protobuf:"bytes,3,opt,name=nameID" json:"nameID,omitempty"`
	DesID                []byte        `protobuf:"bytes,4,opt,name=desID" json:"desID,omitempty"`
	ResID                *int32        `protobuf:"zigzag32,5,opt,name=resID" json:"resID,omitempty"`
	UseLevel             *int32        `protobuf:"zigzag32,6,opt,name=useLevel" json:"useLevel,omitempty"`
	Quality              *int32        `protobuf:"zigzag32,7,opt,name=quality" json:"quality,omitempty"`
	RewardList           []int32       `protobuf:"zigzag32,8,rep,name=rewardList" json:"rewardList,omitempty"`
	Price                *int32        `protobuf:"zigzag32,9,opt,name=price" json:"price,omitempty"`
	TestWearList         []int32       `protobuf:"zigzag32,10,rep,name=testWearList" json:"testWearList,omitempty"`
	EffectList           []*ItemConfig `protobuf:"bytes,11,rep,name=effectList" json:"effectList,omitempty"`
	SpID                 *int32        `protobuf:"zigzag32,12,opt,name=spID" json:"spID,omitempty"`
	ItemSound            []byte        `protobuf:"bytes,13,opt,name=itemSound" json:"itemSound,omitempty"`
	FromID               []byte        `protobuf:"bytes,14,opt,name=fromID" json:"fromID,omitempty"`
	UseforID             []byte        `protobuf:"bytes,15,opt,name=useforID" json:"useforID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaItem) Reset()         { *m = LuaItem{} }
func (m *LuaItem) String() string { return proto.CompactTextString(m) }
func (*LuaItem) ProtoMessage()    {}
func (*LuaItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{110}
}
func (m *LuaItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaItem.Merge(m, src)
}
func (m *LuaItem) XXX_Size() int {
	return m.Size()
}
func (m *LuaItem) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaItem.DiscardUnknown(m)
}

var xxx_messageInfo_LuaItem proto.InternalMessageInfo

func (m *LuaItem) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaItem) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaItem) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaItem) GetDesID() []byte {
	if m != nil {
		return m.DesID
	}
	return nil
}

func (m *LuaItem) GetResID() int32 {
	if m != nil && m.ResID != nil {
		return *m.ResID
	}
	return 0
}

func (m *LuaItem) GetUseLevel() int32 {
	if m != nil && m.UseLevel != nil {
		return *m.UseLevel
	}
	return 0
}

func (m *LuaItem) GetQuality() int32 {
	if m != nil && m.Quality != nil {
		return *m.Quality
	}
	return 0
}

func (m *LuaItem) GetRewardList() []int32 {
	if m != nil {
		return m.RewardList
	}
	return nil
}

func (m *LuaItem) GetPrice() int32 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

func (m *LuaItem) GetTestWearList() []int32 {
	if m != nil {
		return m.TestWearList
	}
	return nil
}

func (m *LuaItem) GetEffectList() []*ItemConfig {
	if m != nil {
		return m.EffectList
	}
	return nil
}

func (m *LuaItem) GetSpID() int32 {
	if m != nil && m.SpID != nil {
		return *m.SpID
	}
	return 0
}

func (m *LuaItem) GetItemSound() []byte {
	if m != nil {
		return m.ItemSound
	}
	return nil
}

func (m *LuaItem) GetFromID() []byte {
	if m != nil {
		return m.FromID
	}
	return nil
}

func (m *LuaItem) GetUseforID() []byte {
	if m != nil {
		return m.UseforID
	}
	return nil
}

// Excel:道具商店表.xls sheet:技能书商店
type LuaSkillShop struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	ItemID               *int32   `protobuf:"zigzag32,2,opt,name=itemID" json:"itemID,omitempty"`
	Num                  *int32   `protobuf:"zigzag32,3,opt,name=num" json:"num,omitempty"`
	CostType             *int32   `protobuf:"zigzag32,4,opt,name=costType" json:"costType,omitempty"`
	Price                *int32   `protobuf:"zigzag32,5,opt,name=price" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaSkillShop) Reset()         { *m = LuaSkillShop{} }
func (m *LuaSkillShop) String() string { return proto.CompactTextString(m) }
func (*LuaSkillShop) ProtoMessage()    {}
func (*LuaSkillShop) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{111}
}
func (m *LuaSkillShop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaSkillShop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaSkillShop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaSkillShop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaSkillShop.Merge(m, src)
}
func (m *LuaSkillShop) XXX_Size() int {
	return m.Size()
}
func (m *LuaSkillShop) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaSkillShop.DiscardUnknown(m)
}

var xxx_messageInfo_LuaSkillShop proto.InternalMessageInfo

func (m *LuaSkillShop) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaSkillShop) GetItemID() int32 {
	if m != nil && m.ItemID != nil {
		return *m.ItemID
	}
	return 0
}

func (m *LuaSkillShop) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

func (m *LuaSkillShop) GetCostType() int32 {
	if m != nil && m.CostType != nil {
		return *m.CostType
	}
	return 0
}

func (m *LuaSkillShop) GetPrice() int32 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

// Excel:equip装备.xls sheet:equip
type LuaEquip struct {
	Id                   *int32              `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte              `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	DesID                []byte              `protobuf:"bytes,3,opt,name=desID" json:"desID,omitempty"`
	Type                 *int32              `protobuf:"zigzag32,4,opt,name=type" json:"type,omitempty"`
	WingCSB              []byte              `protobuf:"bytes,5,opt,name=wingCSB" json:"wingCSB,omitempty"`
	WingSuffix           []byte              `protobuf:"bytes,6,opt,name=wingSuffix" json:"wingSuffix,omitempty"`
	WingBindType         *int32              `protobuf:"zigzag32,7,opt,name=wingBindType" json:"wingBindType,omitempty"`
	CsbName              []byte              `protobuf:"bytes,8,opt,name=csbName" json:"csbName,omitempty"`
	AnimSuffix           *int32              `protobuf:"zigzag32,9,opt,name=animSuffix" json:"animSuffix,omitempty"`
	Quality              *int32              `protobuf:"zigzag32,10,opt,name=quality" json:"quality,omitempty"`
	WearLevel            *int32              `protobuf:"zigzag32,11,opt,name=wearLevel" json:"wearLevel,omitempty"`
	AtkMin               *int32              `protobuf:"zigzag32,12,opt,name=atkMin" json:"atkMin,omitempty"`
	AtkMax               *int32              `protobuf:"zigzag32,13,opt,name=atkMax" json:"atkMax,omitempty"`
	Hp                   *int32              `protobuf:"zigzag32,14,opt,name=hp" json:"hp,omitempty"`
	Def                  *int32              `protobuf:"zigzag32,15,opt,name=def" json:"def,omitempty"`
	Crit                 *int32              `protobuf:"zigzag32,16,opt,name=crit" json:"crit,omitempty"`
	Block                *int32              `protobuf:"zigzag32,17,opt,name=block" json:"block,omitempty"`
	Speed                *int32              `protobuf:"zigzag32,18,opt,name=speed" json:"speed,omitempty"`
	FullAttr             *int32              `protobuf:"zigzag32,19,opt,name=fullAttr" json:"fullAttr,omitempty"`
	Endurance            *int32              `protobuf:"zigzag32,20,opt,name=endurance" json:"endurance,omitempty"`
	Icon                 *int32              `protobuf:"zigzag32,21,opt,name=icon" json:"icon,omitempty"`
	WeaponEffect         *int32              `protobuf:"zigzag32,22,opt,name=weaponEffect" json:"weaponEffect,omitempty"`
	BasePrice            *int32              `protobuf:"zigzag32,23,opt,name=basePrice" json:"basePrice,omitempty"`
	AtkStarStepValue     *int32              `protobuf:"zigzag32,24,opt,name=atkStarStepValue" json:"atkStarStepValue,omitempty"`
	HpStarStepValue      *int32              `protobuf:"zigzag32,25,opt,name=hpStarStepValue" json:"hpStarStepValue,omitempty"`
	DefStarStepValue     *int32              `protobuf:"zigzag32,26,opt,name=defStarStepValue" json:"defStarStepValue,omitempty"`
	CritStarStepValue    *int32              `protobuf:"zigzag32,27,opt,name=critStarStepValue" json:"critStarStepValue,omitempty"`
	BlockStarStepValue   *int32              `protobuf:"zigzag32,28,opt,name=blockStarStepValue" json:"blockStarStepValue,omitempty"`
	SpeedStarStepValue   *int32              `protobuf:"zigzag32,29,opt,name=speedStarStepValue" json:"speedStarStepValue,omitempty"`
	ResolveBaseList      []*ItemConfig       `protobuf:"bytes,30,rep,name=resolveBaseList" json:"resolveBaseList,omitempty"`
	ResolveExtraList     []*EquipResolveItem `protobuf:"bytes,31,rep,name=resolveExtraList" json:"resolveExtraList,omitempty"`
	StarUpperLimit       *int32              `protobuf:"zigzag32,32,opt,name=starUpperLimit" json:"starUpperLimit,omitempty"`
	IsResoluble          *int32              `protobuf:"zigzag32,33,opt,name=isResoluble" json:"isResoluble,omitempty"`
	QualityAtkList       []int32             `protobuf:"zigzag32,34,rep,name=qualityAtkList" json:"qualityAtkList,omitempty"`
	QualityHpList        []int32             `protobuf:"zigzag32,35,rep,name=qualityHpList" json:"qualityHpList,omitempty"`
	QualityDefList       []int32             `protobuf:"zigzag32,36,rep,name=qualityDefList" json:"qualityDefList,omitempty"`
	QualityCritList      []int32             `protobuf:"zigzag32,37,rep,name=qualityCritList" json:"qualityCritList,omitempty"`
	QualityBlockList     []int32             `protobuf:"zigzag32,38,rep,name=qualityBlockList" json:"qualityBlockList,omitempty"`
	QualitySpeedList     []int32             `protobuf:"zigzag32,39,rep,name=qualitySpeedList" json:"qualitySpeedList,omitempty"`
	MoveSpeed            *int32              `protobuf:"zigzag32,40,opt,name=moveSpeed" json:"moveSpeed,omitempty"`
	CarSound             []byte              `protobuf:"bytes,41,opt,name=carSound" json:"carSound,omitempty"`
	RareDegree           *int32              `protobuf:"zigzag32,42,opt,name=rareDegree" json:"rareDegree,omitempty"`
	FromID               []byte              `protobuf:"bytes,43,opt,name=fromID" json:"fromID,omitempty"`
	UseforID             []byte              `protobuf:"bytes,44,opt,name=useforID" json:"useforID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *LuaEquip) Reset()         { *m = LuaEquip{} }
func (m *LuaEquip) String() string { return proto.CompactTextString(m) }
func (*LuaEquip) ProtoMessage()    {}
func (*LuaEquip) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{112}
}
func (m *LuaEquip) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaEquip) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaEquip.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaEquip) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaEquip.Merge(m, src)
}
func (m *LuaEquip) XXX_Size() int {
	return m.Size()
}
func (m *LuaEquip) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaEquip.DiscardUnknown(m)
}

var xxx_messageInfo_LuaEquip proto.InternalMessageInfo

func (m *LuaEquip) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaEquip) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaEquip) GetDesID() []byte {
	if m != nil {
		return m.DesID
	}
	return nil
}

func (m *LuaEquip) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaEquip) GetWingCSB() []byte {
	if m != nil {
		return m.WingCSB
	}
	return nil
}

func (m *LuaEquip) GetWingSuffix() []byte {
	if m != nil {
		return m.WingSuffix
	}
	return nil
}

func (m *LuaEquip) GetWingBindType() int32 {
	if m != nil && m.WingBindType != nil {
		return *m.WingBindType
	}
	return 0
}

func (m *LuaEquip) GetCsbName() []byte {
	if m != nil {
		return m.CsbName
	}
	return nil
}

func (m *LuaEquip) GetAnimSuffix() int32 {
	if m != nil && m.AnimSuffix != nil {
		return *m.AnimSuffix
	}
	return 0
}

func (m *LuaEquip) GetQuality() int32 {
	if m != nil && m.Quality != nil {
		return *m.Quality
	}
	return 0
}

func (m *LuaEquip) GetWearLevel() int32 {
	if m != nil && m.WearLevel != nil {
		return *m.WearLevel
	}
	return 0
}

func (m *LuaEquip) GetAtkMin() int32 {
	if m != nil && m.AtkMin != nil {
		return *m.AtkMin
	}
	return 0
}

func (m *LuaEquip) GetAtkMax() int32 {
	if m != nil && m.AtkMax != nil {
		return *m.AtkMax
	}
	return 0
}

func (m *LuaEquip) GetHp() int32 {
	if m != nil && m.Hp != nil {
		return *m.Hp
	}
	return 0
}

func (m *LuaEquip) GetDef() int32 {
	if m != nil && m.Def != nil {
		return *m.Def
	}
	return 0
}

func (m *LuaEquip) GetCrit() int32 {
	if m != nil && m.Crit != nil {
		return *m.Crit
	}
	return 0
}

func (m *LuaEquip) GetBlock() int32 {
	if m != nil && m.Block != nil {
		return *m.Block
	}
	return 0
}

func (m *LuaEquip) GetSpeed() int32 {
	if m != nil && m.Speed != nil {
		return *m.Speed
	}
	return 0
}

func (m *LuaEquip) GetFullAttr() int32 {
	if m != nil && m.FullAttr != nil {
		return *m.FullAttr
	}
	return 0
}

func (m *LuaEquip) GetEndurance() int32 {
	if m != nil && m.Endurance != nil {
		return *m.Endurance
	}
	return 0
}

func (m *LuaEquip) GetIcon() int32 {
	if m != nil && m.Icon != nil {
		return *m.Icon
	}
	return 0
}

func (m *LuaEquip) GetWeaponEffect() int32 {
	if m != nil && m.WeaponEffect != nil {
		return *m.WeaponEffect
	}
	return 0
}

func (m *LuaEquip) GetBasePrice() int32 {
	if m != nil && m.BasePrice != nil {
		return *m.BasePrice
	}
	return 0
}

func (m *LuaEquip) GetAtkStarStepValue() int32 {
	if m != nil && m.AtkStarStepValue != nil {
		return *m.AtkStarStepValue
	}
	return 0
}

func (m *LuaEquip) GetHpStarStepValue() int32 {
	if m != nil && m.HpStarStepValue != nil {
		return *m.HpStarStepValue
	}
	return 0
}

func (m *LuaEquip) GetDefStarStepValue() int32 {
	if m != nil && m.DefStarStepValue != nil {
		return *m.DefStarStepValue
	}
	return 0
}

func (m *LuaEquip) GetCritStarStepValue() int32 {
	if m != nil && m.CritStarStepValue != nil {
		return *m.CritStarStepValue
	}
	return 0
}

func (m *LuaEquip) GetBlockStarStepValue() int32 {
	if m != nil && m.BlockStarStepValue != nil {
		return *m.BlockStarStepValue
	}
	return 0
}

func (m *LuaEquip) GetSpeedStarStepValue() int32 {
	if m != nil && m.SpeedStarStepValue != nil {
		return *m.SpeedStarStepValue
	}
	return 0
}

func (m *LuaEquip) GetResolveBaseList() []*ItemConfig {
	if m != nil {
		return m.ResolveBaseList
	}
	return nil
}

func (m *LuaEquip) GetResolveExtraList() []*EquipResolveItem {
	if m != nil {
		return m.ResolveExtraList
	}
	return nil
}

func (m *LuaEquip) GetStarUpperLimit() int32 {
	if m != nil && m.StarUpperLimit != nil {
		return *m.StarUpperLimit
	}
	return 0
}

func (m *LuaEquip) GetIsResoluble() int32 {
	if m != nil && m.IsResoluble != nil {
		return *m.IsResoluble
	}
	return 0
}

func (m *LuaEquip) GetQualityAtkList() []int32 {
	if m != nil {
		return m.QualityAtkList
	}
	return nil
}

func (m *LuaEquip) GetQualityHpList() []int32 {
	if m != nil {
		return m.QualityHpList
	}
	return nil
}

func (m *LuaEquip) GetQualityDefList() []int32 {
	if m != nil {
		return m.QualityDefList
	}
	return nil
}

func (m *LuaEquip) GetQualityCritList() []int32 {
	if m != nil {
		return m.QualityCritList
	}
	return nil
}

func (m *LuaEquip) GetQualityBlockList() []int32 {
	if m != nil {
		return m.QualityBlockList
	}
	return nil
}

func (m *LuaEquip) GetQualitySpeedList() []int32 {
	if m != nil {
		return m.QualitySpeedList
	}
	return nil
}

func (m *LuaEquip) GetMoveSpeed() int32 {
	if m != nil && m.MoveSpeed != nil {
		return *m.MoveSpeed
	}
	return 0
}

func (m *LuaEquip) GetCarSound() []byte {
	if m != nil {
		return m.CarSound
	}
	return nil
}

func (m *LuaEquip) GetRareDegree() int32 {
	if m != nil && m.RareDegree != nil {
		return *m.RareDegree
	}
	return 0
}

func (m *LuaEquip) GetFromID() []byte {
	if m != nil {
		return m.FromID
	}
	return nil
}

func (m *LuaEquip) GetUseforID() []byte {
	if m != nil {
		return m.UseforID
	}
	return nil
}

// Excel:pet宠物.xls sheet:宠物系统技能表
type LuaPetActSkill struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte   `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	DesID                []byte   `protobuf:"bytes,3,opt,name=desID" json:"desID,omitempty"`
	Icon                 []byte   `protobuf:"bytes,4,opt,name=icon" json:"icon,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaPetActSkill) Reset()         { *m = LuaPetActSkill{} }
func (m *LuaPetActSkill) String() string { return proto.CompactTextString(m) }
func (*LuaPetActSkill) ProtoMessage()    {}
func (*LuaPetActSkill) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{113}
}
func (m *LuaPetActSkill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaPetActSkill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaPetActSkill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaPetActSkill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaPetActSkill.Merge(m, src)
}
func (m *LuaPetActSkill) XXX_Size() int {
	return m.Size()
}
func (m *LuaPetActSkill) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaPetActSkill.DiscardUnknown(m)
}

var xxx_messageInfo_LuaPetActSkill proto.InternalMessageInfo

func (m *LuaPetActSkill) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaPetActSkill) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaPetActSkill) GetDesID() []byte {
	if m != nil {
		return m.DesID
	}
	return nil
}

func (m *LuaPetActSkill) GetIcon() []byte {
	if m != nil {
		return m.Icon
	}
	return nil
}

// Excel:vip表.xls sheet:vip特权表
type LuaVip struct {
	Id                         *int32        `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	Exp                        *int32        `protobuf:"zigzag32,2,opt,name=exp" json:"exp,omitempty"`
	SpecialRewardList          []*ItemConfig `protobuf:"bytes,3,rep,name=specialRewardList" json:"specialRewardList,omitempty"`
	ShowPrice                  *ItemConfig   `protobuf:"bytes,4,opt,name=showPrice" json:"showPrice,omitempty"`
	RealPrice                  *ItemConfig   `protobuf:"bytes,5,opt,name=realPrice" json:"realPrice,omitempty"`
	DailyRewardList            []*ItemConfig `protobuf:"bytes,6,rep,name=dailyRewardList" json:"dailyRewardList,omitempty"`
	RiskAddSpeed               []int32       `protobuf:"zigzag32,7,rep,name=riskAddSpeed" json:"riskAddSpeed,omitempty"`
	UploadFaceFlag             []int32       `protobuf:"zigzag32,8,rep,name=uploadFaceFlag" json:"uploadFaceFlag,omitempty"`
	UnlockSkillPos             []int32       `protobuf:"zigzag32,9,rep,name=unlockSkillPos" json:"unlockSkillPos,omitempty"`
	VipChatPP                  []int32       `protobuf:"zigzag32,10,rep,name=vipChatPP" json:"vipChatPP,omitempty"`
	NoCdArenaFail              []int32       `protobuf:"zigzag32,11,rep,name=noCdArenaFail" json:"noCdArenaFail,omitempty"`
	FixTimePlus                []int32       `protobuf:"zigzag32,12,rep,name=fixTimePlus" json:"fixTimePlus,omitempty"`
	VipSkipFight               []int32       `protobuf:"zigzag32,13,rep,name=vipSkipFight" json:"vipSkipFight,omitempty"`
	BathExpSpeedup             []int32       `protobuf:"zigzag32,14,rep,name=bathExpSpeedup" json:"bathExpSpeedup,omitempty"`
	VipPet                     []int32       `protobuf:"zigzag32,15,rep,name=vipPet" json:"vipPet,omitempty"`
	SkilledSpeed               []int32       `protobuf:"zigzag32,16,rep,name=skilledSpeed" json:"skilledSpeed,omitempty"`
	VipBMG                     []int32       `protobuf:"zigzag32,17,rep,name=vipBMG" json:"vipBMG,omitempty"`
	VipBarrageFont             []int32       `protobuf:"zigzag32,18,rep,name=vipBarrageFont" json:"vipBarrageFont,omitempty"`
	ExpPromoteRatio            []int32       `protobuf:"zigzag32,19,rep,name=expPromoteRatio" json:"expPromoteRatio,omitempty"`
	FriendSkillCD              []int32       `protobuf:"zigzag32,20,rep,name=friendSkillCD" json:"friendSkillCD,omitempty"`
	ExchangeGoldTime           []int32       `protobuf:"zigzag32,21,rep,name=exchangeGoldTime" json:"exchangeGoldTime,omitempty"`
	BuyArenaCount              []int32       `protobuf:"zigzag32,22,rep,name=buyArenaCount" json:"buyArenaCount,omitempty"`
	BuyStaminaCount            []int32       `protobuf:"zigzag32,23,rep,name=buyStaminaCount" json:"buyStaminaCount,omitempty"`
	BuyBitCoinCount            []int32       `protobuf:"zigzag32,24,rep,name=buyBitCoinCount" json:"buyBitCoinCount,omitempty"`
	FaceRefreshCountUpperLimit []int32       `protobuf:"zigzag32,25,rep,name=faceRefreshCountUpperLimit" json:"faceRefreshCountUpperLimit,omitempty"`
	UpdateSkillShopCount       []int32       `protobuf:"zigzag32,26,rep,name=updateSkillShopCount" json:"updateSkillShopCount,omitempty"`
	UpdateMinigameShopCount    []int32       `protobuf:"zigzag32,27,rep,name=updateMinigameShopCount" json:"updateMinigameShopCount,omitempty"`
	UpdateArenaShopCount       []int32       `protobuf:"zigzag32,28,rep,name=updateArenaShopCount" json:"updateArenaShopCount,omitempty"`
	UpdateBlackShopCount       []int32       `protobuf:"zigzag32,29,rep,name=updateBlackShopCount" json:"updateBlackShopCount,omitempty"`
	UpdateDiamondShopCount     []int32       `protobuf:"zigzag32,30,rep,name=updateDiamondShopCount" json:"updateDiamondShopCount,omitempty"`
	SignManualCount            []int32       `protobuf:"zigzag32,31,rep,name=signManualCount" json:"signManualCount,omitempty"`
	DangerRiskResetCount       []int32       `protobuf:"zigzag32,32,rep,name=dangerRiskResetCount" json:"dangerRiskResetCount,omitempty"`
	ParkNum                    []int32       `protobuf:"zigzag32,33,rep,name=parkNum" json:"parkNum,omitempty"`
	VipAct                     []int32       `protobuf:"zigzag32,34,rep,name=vipAct" json:"vipAct,omitempty"`
	VipFurnitureShop           []int32       `protobuf:"zigzag32,35,rep,name=vipFurnitureShop" json:"vipFurnitureShop,omitempty"`
	VipVechical                []int32       `protobuf:"zigzag32,36,rep,name=vipVechical" json:"vipVechical,omitempty"`
	RiskDropRate               []int32       `protobuf:"zigzag32,37,rep,name=riskDropRate" json:"riskDropRate,omitempty"`
	VipFellow                  []int32       `protobuf:"zigzag32,38,rep,name=vipFellow" json:"vipFellow,omitempty"`
	SelfDefVehicle             []int32       `protobuf:"zigzag32,39,rep,name=selfDefVehicle" json:"selfDefVehicle,omitempty"`
	CarportCount               []int32       `protobuf:"zigzag32,40,rep,name=carportCount" json:"carportCount,omitempty"`
	XXX_NoUnkeyedLiteral       struct{}      `json:"-"`
	XXX_unrecognized           []byte        `json:"-"`
	XXX_sizecache              int32         `json:"-"`
}

func (m *LuaVip) Reset()         { *m = LuaVip{} }
func (m *LuaVip) String() string { return proto.CompactTextString(m) }
func (*LuaVip) ProtoMessage()    {}
func (*LuaVip) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{114}
}
func (m *LuaVip) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaVip) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaVip.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaVip) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaVip.Merge(m, src)
}
func (m *LuaVip) XXX_Size() int {
	return m.Size()
}
func (m *LuaVip) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaVip.DiscardUnknown(m)
}

var xxx_messageInfo_LuaVip proto.InternalMessageInfo

func (m *LuaVip) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaVip) GetExp() int32 {
	if m != nil && m.Exp != nil {
		return *m.Exp
	}
	return 0
}

func (m *LuaVip) GetSpecialRewardList() []*ItemConfig {
	if m != nil {
		return m.SpecialRewardList
	}
	return nil
}

func (m *LuaVip) GetShowPrice() *ItemConfig {
	if m != nil {
		return m.ShowPrice
	}
	return nil
}

func (m *LuaVip) GetRealPrice() *ItemConfig {
	if m != nil {
		return m.RealPrice
	}
	return nil
}

func (m *LuaVip) GetDailyRewardList() []*ItemConfig {
	if m != nil {
		return m.DailyRewardList
	}
	return nil
}

func (m *LuaVip) GetRiskAddSpeed() []int32 {
	if m != nil {
		return m.RiskAddSpeed
	}
	return nil
}

func (m *LuaVip) GetUploadFaceFlag() []int32 {
	if m != nil {
		return m.UploadFaceFlag
	}
	return nil
}

func (m *LuaVip) GetUnlockSkillPos() []int32 {
	if m != nil {
		return m.UnlockSkillPos
	}
	return nil
}

func (m *LuaVip) GetVipChatPP() []int32 {
	if m != nil {
		return m.VipChatPP
	}
	return nil
}

func (m *LuaVip) GetNoCdArenaFail() []int32 {
	if m != nil {
		return m.NoCdArenaFail
	}
	return nil
}

func (m *LuaVip) GetFixTimePlus() []int32 {
	if m != nil {
		return m.FixTimePlus
	}
	return nil
}

func (m *LuaVip) GetVipSkipFight() []int32 {
	if m != nil {
		return m.VipSkipFight
	}
	return nil
}

func (m *LuaVip) GetBathExpSpeedup() []int32 {
	if m != nil {
		return m.BathExpSpeedup
	}
	return nil
}

func (m *LuaVip) GetVipPet() []int32 {
	if m != nil {
		return m.VipPet
	}
	return nil
}

func (m *LuaVip) GetSkilledSpeed() []int32 {
	if m != nil {
		return m.SkilledSpeed
	}
	return nil
}

func (m *LuaVip) GetVipBMG() []int32 {
	if m != nil {
		return m.VipBMG
	}
	return nil
}

func (m *LuaVip) GetVipBarrageFont() []int32 {
	if m != nil {
		return m.VipBarrageFont
	}
	return nil
}

func (m *LuaVip) GetExpPromoteRatio() []int32 {
	if m != nil {
		return m.ExpPromoteRatio
	}
	return nil
}

func (m *LuaVip) GetFriendSkillCD() []int32 {
	if m != nil {
		return m.FriendSkillCD
	}
	return nil
}

func (m *LuaVip) GetExchangeGoldTime() []int32 {
	if m != nil {
		return m.ExchangeGoldTime
	}
	return nil
}

func (m *LuaVip) GetBuyArenaCount() []int32 {
	if m != nil {
		return m.BuyArenaCount
	}
	return nil
}

func (m *LuaVip) GetBuyStaminaCount() []int32 {
	if m != nil {
		return m.BuyStaminaCount
	}
	return nil
}

func (m *LuaVip) GetBuyBitCoinCount() []int32 {
	if m != nil {
		return m.BuyBitCoinCount
	}
	return nil
}

func (m *LuaVip) GetFaceRefreshCountUpperLimit() []int32 {
	if m != nil {
		return m.FaceRefreshCountUpperLimit
	}
	return nil
}

func (m *LuaVip) GetUpdateSkillShopCount() []int32 {
	if m != nil {
		return m.UpdateSkillShopCount
	}
	return nil
}

func (m *LuaVip) GetUpdateMinigameShopCount() []int32 {
	if m != nil {
		return m.UpdateMinigameShopCount
	}
	return nil
}

func (m *LuaVip) GetUpdateArenaShopCount() []int32 {
	if m != nil {
		return m.UpdateArenaShopCount
	}
	return nil
}

func (m *LuaVip) GetUpdateBlackShopCount() []int32 {
	if m != nil {
		return m.UpdateBlackShopCount
	}
	return nil
}

func (m *LuaVip) GetUpdateDiamondShopCount() []int32 {
	if m != nil {
		return m.UpdateDiamondShopCount
	}
	return nil
}

func (m *LuaVip) GetSignManualCount() []int32 {
	if m != nil {
		return m.SignManualCount
	}
	return nil
}

func (m *LuaVip) GetDangerRiskResetCount() []int32 {
	if m != nil {
		return m.DangerRiskResetCount
	}
	return nil
}

func (m *LuaVip) GetParkNum() []int32 {
	if m != nil {
		return m.ParkNum
	}
	return nil
}

func (m *LuaVip) GetVipAct() []int32 {
	if m != nil {
		return m.VipAct
	}
	return nil
}

func (m *LuaVip) GetVipFurnitureShop() []int32 {
	if m != nil {
		return m.VipFurnitureShop
	}
	return nil
}

func (m *LuaVip) GetVipVechical() []int32 {
	if m != nil {
		return m.VipVechical
	}
	return nil
}

func (m *LuaVip) GetRiskDropRate() []int32 {
	if m != nil {
		return m.RiskDropRate
	}
	return nil
}

func (m *LuaVip) GetVipFellow() []int32 {
	if m != nil {
		return m.VipFellow
	}
	return nil
}

func (m *LuaVip) GetSelfDefVehicle() []int32 {
	if m != nil {
		return m.SelfDefVehicle
	}
	return nil
}

func (m *LuaVip) GetCarportCount() []int32 {
	if m != nil {
		return m.CarportCount
	}
	return nil
}

// Excel:家园表.xls sheet:家具表
type LuaFurniture struct {
	Id                   *int32      `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte      `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	DesID                []byte      `protobuf:"bytes,3,opt,name=desID" json:"desID,omitempty"`
	Icon                 *int32      `protobuf:"zigzag32,4,opt,name=icon" json:"icon,omitempty"`
	Type                 *int32      `protobuf:"zigzag32,5,opt,name=type" json:"type,omitempty"`
	SubType              *int32      `protobuf:"zigzag32,6,opt,name=subType" json:"subType,omitempty"`
	Size_                *LuaSize    `protobuf:"bytes,7,opt,name=size" json:"size,omitempty"`
	DirType              *int32      `protobuf:"zigzag32,8,opt,name=dirType" json:"dirType,omitempty"`
	DirectIndex          *int32      `protobuf:"zigzag32,9,opt,name=directIndex" json:"directIndex,omitempty"`
	ResType              *int32      `protobuf:"zigzag32,10,opt,name=resType" json:"resType,omitempty"`
	Res                  []byte      `protobuf:"bytes,11,opt,name=res" json:"res,omitempty"`
	IsCanPass            *int32      `protobuf:"zigzag32,12,opt,name=isCanPass" json:"isCanPass,omitempty"`
	OffsetPos            *LuaPos     `protobuf:"bytes,13,opt,name=offsetPos" json:"offsetPos,omitempty"`
	SalePrice            *ItemConfig `protobuf:"bytes,14,opt,name=salePrice" json:"salePrice,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *LuaFurniture) Reset()         { *m = LuaFurniture{} }
func (m *LuaFurniture) String() string { return proto.CompactTextString(m) }
func (*LuaFurniture) ProtoMessage()    {}
func (*LuaFurniture) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{115}
}
func (m *LuaFurniture) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaFurniture) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaFurniture.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaFurniture) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaFurniture.Merge(m, src)
}
func (m *LuaFurniture) XXX_Size() int {
	return m.Size()
}
func (m *LuaFurniture) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaFurniture.DiscardUnknown(m)
}

var xxx_messageInfo_LuaFurniture proto.InternalMessageInfo

func (m *LuaFurniture) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaFurniture) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaFurniture) GetDesID() []byte {
	if m != nil {
		return m.DesID
	}
	return nil
}

func (m *LuaFurniture) GetIcon() int32 {
	if m != nil && m.Icon != nil {
		return *m.Icon
	}
	return 0
}

func (m *LuaFurniture) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaFurniture) GetSubType() int32 {
	if m != nil && m.SubType != nil {
		return *m.SubType
	}
	return 0
}

func (m *LuaFurniture) GetSize_() *LuaSize {
	if m != nil {
		return m.Size_
	}
	return nil
}

func (m *LuaFurniture) GetDirType() int32 {
	if m != nil && m.DirType != nil {
		return *m.DirType
	}
	return 0
}

func (m *LuaFurniture) GetDirectIndex() int32 {
	if m != nil && m.DirectIndex != nil {
		return *m.DirectIndex
	}
	return 0
}

func (m *LuaFurniture) GetResType() int32 {
	if m != nil && m.ResType != nil {
		return *m.ResType
	}
	return 0
}

func (m *LuaFurniture) GetRes() []byte {
	if m != nil {
		return m.Res
	}
	return nil
}

func (m *LuaFurniture) GetIsCanPass() int32 {
	if m != nil && m.IsCanPass != nil {
		return *m.IsCanPass
	}
	return 0
}

func (m *LuaFurniture) GetOffsetPos() *LuaPos {
	if m != nil {
		return m.OffsetPos
	}
	return nil
}

func (m *LuaFurniture) GetSalePrice() *ItemConfig {
	if m != nil {
		return m.SalePrice
	}
	return nil
}

// Excel:竞技场表.xls sheet:挑战购买表
type LuaArenaBuy struct {
	Count                *int32   `protobuf:"zigzag32,1,opt,name=count" json:"count,omitempty"`
	Diamond              *int32   `protobuf:"zigzag32,2,opt,name=diamond" json:"diamond,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaArenaBuy) Reset()         { *m = LuaArenaBuy{} }
func (m *LuaArenaBuy) String() string { return proto.CompactTextString(m) }
func (*LuaArenaBuy) ProtoMessage()    {}
func (*LuaArenaBuy) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{116}
}
func (m *LuaArenaBuy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaArenaBuy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaArenaBuy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaArenaBuy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaArenaBuy.Merge(m, src)
}
func (m *LuaArenaBuy) XXX_Size() int {
	return m.Size()
}
func (m *LuaArenaBuy) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaArenaBuy.DiscardUnknown(m)
}

var xxx_messageInfo_LuaArenaBuy proto.InternalMessageInfo

func (m *LuaArenaBuy) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *LuaArenaBuy) GetDiamond() int32 {
	if m != nil && m.Diamond != nil {
		return *m.Diamond
	}
	return 0
}

// Excel:f副本表.xls sheet:波次表
type LuaBattleWave struct {
	Id                   *int32           `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	NameID               []byte           `protobuf:"bytes,2,opt,name=nameID" json:"nameID,omitempty"`
	MonsterList          []int32          `protobuf:"zigzag32,3,rep,name=monsterList" json:"monsterList,omitempty"`
	PosList              []int32          `protobuf:"zigzag32,4,rep,name=posList" json:"posList,omitempty"`
	TalkID               *int32           `protobuf:"zigzag32,5,opt,name=talkID" json:"talkID,omitempty"`
	LevelList            []int32          `protobuf:"zigzag32,6,rep,name=levelList" json:"levelList,omitempty"`
	DiffList             []int32          `protobuf:"zigzag32,7,rep,name=diffList" json:"diffList,omitempty"`
	EventID              *int32           `protobuf:"zigzag32,8,opt,name=eventID" json:"eventID,omitempty"`
	EventConList         []int32          `protobuf:"zigzag32,9,rep,name=eventConList" json:"eventConList,omitempty"`
	EventArgList         *LuaEventArgList `protobuf:"bytes,10,opt,name=eventArgList" json:"eventArgList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *LuaBattleWave) Reset()         { *m = LuaBattleWave{} }
func (m *LuaBattleWave) String() string { return proto.CompactTextString(m) }
func (*LuaBattleWave) ProtoMessage()    {}
func (*LuaBattleWave) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{117}
}
func (m *LuaBattleWave) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaBattleWave) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaBattleWave.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaBattleWave) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaBattleWave.Merge(m, src)
}
func (m *LuaBattleWave) XXX_Size() int {
	return m.Size()
}
func (m *LuaBattleWave) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaBattleWave.DiscardUnknown(m)
}

var xxx_messageInfo_LuaBattleWave proto.InternalMessageInfo

func (m *LuaBattleWave) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaBattleWave) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaBattleWave) GetMonsterList() []int32 {
	if m != nil {
		return m.MonsterList
	}
	return nil
}

func (m *LuaBattleWave) GetPosList() []int32 {
	if m != nil {
		return m.PosList
	}
	return nil
}

func (m *LuaBattleWave) GetTalkID() int32 {
	if m != nil && m.TalkID != nil {
		return *m.TalkID
	}
	return 0
}

func (m *LuaBattleWave) GetLevelList() []int32 {
	if m != nil {
		return m.LevelList
	}
	return nil
}

func (m *LuaBattleWave) GetDiffList() []int32 {
	if m != nil {
		return m.DiffList
	}
	return nil
}

func (m *LuaBattleWave) GetEventID() int32 {
	if m != nil && m.EventID != nil {
		return *m.EventID
	}
	return 0
}

func (m *LuaBattleWave) GetEventConList() []int32 {
	if m != nil {
		return m.EventConList
	}
	return nil
}

func (m *LuaBattleWave) GetEventArgList() *LuaEventArgList {
	if m != nil {
		return m.EventArgList
	}
	return nil
}

// Excel:小游戏规则表.xls sheet:大战三侠镇
type LuaMiniWarrior struct {
	Level                 *int32   `protobuf:"zigzag32,1,opt,name=level" json:"level,omitempty"`
	NumPerGroup           *int32   `protobuf:"zigzag32,2,opt,name=numPerGroup" json:"numPerGroup,omitempty"`
	EnemyNumMax           *int32   `protobuf:"zigzag32,3,opt,name=enemyNumMax" json:"enemyNumMax,omitempty"`
	Gap                   *float32 `protobuf:"fixed32,4,opt,name=gap" json:"gap,omitempty"`
	EnemyNum              *int32   `protobuf:"zigzag32,5,opt,name=enemyNum" json:"enemyNum,omitempty"`
	AddEnemyGroup         *int32   `protobuf:"zigzag32,6,opt,name=addEnemyGroup" json:"addEnemyGroup,omitempty"`
	EnemyAddPerGroup      *int32   `protobuf:"zigzag32,7,opt,name=enemyAddPerGroup" json:"enemyAddPerGroup,omitempty"`
	FirstSpeed            *int32   `protobuf:"zigzag32,8,opt,name=firstSpeed" json:"firstSpeed,omitempty"`
	AddSpeedGroup         *int32   `protobuf:"zigzag32,9,opt,name=addSpeedGroup" json:"addSpeedGroup,omitempty"`
	SpeedAddPerGroup      *float32 `protobuf:"fixed32,10,opt,name=speedAddPerGroup" json:"speedAddPerGroup,omitempty"`
	SpeedMaxLimit         *int32   `protobuf:"zigzag32,11,opt,name=speedMaxLimit" json:"speedMaxLimit,omitempty"`
	AttLimit              *int32   `protobuf:"zigzag32,12,opt,name=attLimit" json:"attLimit,omitempty"`
	BossAppearScore       *int32   `protobuf:"zigzag32,13,opt,name=bossAppearScore" json:"bossAppearScore,omitempty"`
	BossAppearScoreAdd    *int32   `protobuf:"zigzag32,14,opt,name=bossAppearScoreAdd" json:"bossAppearScoreAdd,omitempty"`
	BossChangeColorNum    *int32   `protobuf:"zigzag32,15,opt,name=bossChangeColorNum" json:"bossChangeColorNum,omitempty"`
	BossChangeColorNumAdd *int32   `protobuf:"zigzag32,16,opt,name=bossChangeColorNumAdd" json:"bossChangeColorNumAdd,omitempty"`
	BossGatherEnergy      *int32   `protobuf:"zigzag32,17,opt,name=bossGatherEnergy" json:"bossGatherEnergy,omitempty"`
	BossGatherEnergyAdd   *int32   `protobuf:"zigzag32,18,opt,name=bossGatherEnergyAdd" json:"bossGatherEnergyAdd,omitempty"`
	EnemyScore            *int32   `protobuf:"zigzag32,19,opt,name=enemyScore" json:"enemyScore,omitempty"`
	BossScore             *int32   `protobuf:"zigzag32,20,opt,name=bossScore" json:"bossScore,omitempty"`
	MapSpeed              *int32   `protobuf:"zigzag32,21,opt,name=mapSpeed" json:"mapSpeed,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *LuaMiniWarrior) Reset()         { *m = LuaMiniWarrior{} }
func (m *LuaMiniWarrior) String() string { return proto.CompactTextString(m) }
func (*LuaMiniWarrior) ProtoMessage()    {}
func (*LuaMiniWarrior) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{118}
}
func (m *LuaMiniWarrior) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaMiniWarrior) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaMiniWarrior.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaMiniWarrior) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaMiniWarrior.Merge(m, src)
}
func (m *LuaMiniWarrior) XXX_Size() int {
	return m.Size()
}
func (m *LuaMiniWarrior) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaMiniWarrior.DiscardUnknown(m)
}

var xxx_messageInfo_LuaMiniWarrior proto.InternalMessageInfo

func (m *LuaMiniWarrior) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaMiniWarrior) GetNumPerGroup() int32 {
	if m != nil && m.NumPerGroup != nil {
		return *m.NumPerGroup
	}
	return 0
}

func (m *LuaMiniWarrior) GetEnemyNumMax() int32 {
	if m != nil && m.EnemyNumMax != nil {
		return *m.EnemyNumMax
	}
	return 0
}

func (m *LuaMiniWarrior) GetGap() float32 {
	if m != nil && m.Gap != nil {
		return *m.Gap
	}
	return 0
}

func (m *LuaMiniWarrior) GetEnemyNum() int32 {
	if m != nil && m.EnemyNum != nil {
		return *m.EnemyNum
	}
	return 0
}

func (m *LuaMiniWarrior) GetAddEnemyGroup() int32 {
	if m != nil && m.AddEnemyGroup != nil {
		return *m.AddEnemyGroup
	}
	return 0
}

func (m *LuaMiniWarrior) GetEnemyAddPerGroup() int32 {
	if m != nil && m.EnemyAddPerGroup != nil {
		return *m.EnemyAddPerGroup
	}
	return 0
}

func (m *LuaMiniWarrior) GetFirstSpeed() int32 {
	if m != nil && m.FirstSpeed != nil {
		return *m.FirstSpeed
	}
	return 0
}

func (m *LuaMiniWarrior) GetAddSpeedGroup() int32 {
	if m != nil && m.AddSpeedGroup != nil {
		return *m.AddSpeedGroup
	}
	return 0
}

func (m *LuaMiniWarrior) GetSpeedAddPerGroup() float32 {
	if m != nil && m.SpeedAddPerGroup != nil {
		return *m.SpeedAddPerGroup
	}
	return 0
}

func (m *LuaMiniWarrior) GetSpeedMaxLimit() int32 {
	if m != nil && m.SpeedMaxLimit != nil {
		return *m.SpeedMaxLimit
	}
	return 0
}

func (m *LuaMiniWarrior) GetAttLimit() int32 {
	if m != nil && m.AttLimit != nil {
		return *m.AttLimit
	}
	return 0
}

func (m *LuaMiniWarrior) GetBossAppearScore() int32 {
	if m != nil && m.BossAppearScore != nil {
		return *m.BossAppearScore
	}
	return 0
}

func (m *LuaMiniWarrior) GetBossAppearScoreAdd() int32 {
	if m != nil && m.BossAppearScoreAdd != nil {
		return *m.BossAppearScoreAdd
	}
	return 0
}

func (m *LuaMiniWarrior) GetBossChangeColorNum() int32 {
	if m != nil && m.BossChangeColorNum != nil {
		return *m.BossChangeColorNum
	}
	return 0
}

func (m *LuaMiniWarrior) GetBossChangeColorNumAdd() int32 {
	if m != nil && m.BossChangeColorNumAdd != nil {
		return *m.BossChangeColorNumAdd
	}
	return 0
}

func (m *LuaMiniWarrior) GetBossGatherEnergy() int32 {
	if m != nil && m.BossGatherEnergy != nil {
		return *m.BossGatherEnergy
	}
	return 0
}

func (m *LuaMiniWarrior) GetBossGatherEnergyAdd() int32 {
	if m != nil && m.BossGatherEnergyAdd != nil {
		return *m.BossGatherEnergyAdd
	}
	return 0
}

func (m *LuaMiniWarrior) GetEnemyScore() int32 {
	if m != nil && m.EnemyScore != nil {
		return *m.EnemyScore
	}
	return 0
}

func (m *LuaMiniWarrior) GetBossScore() int32 {
	if m != nil && m.BossScore != nil {
		return *m.BossScore
	}
	return 0
}

func (m *LuaMiniWarrior) GetMapSpeed() int32 {
	if m != nil && m.MapSpeed != nil {
		return *m.MapSpeed
	}
	return 0
}

// Excel:q抢车位.xls sheet:车位表
type LuaParkCarport struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	BenefitRate          *float32 `protobuf:"fixed32,2,opt,name=benefitRate" json:"benefitRate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaParkCarport) Reset()         { *m = LuaParkCarport{} }
func (m *LuaParkCarport) String() string { return proto.CompactTextString(m) }
func (*LuaParkCarport) ProtoMessage()    {}
func (*LuaParkCarport) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{119}
}
func (m *LuaParkCarport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaParkCarport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaParkCarport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaParkCarport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaParkCarport.Merge(m, src)
}
func (m *LuaParkCarport) XXX_Size() int {
	return m.Size()
}
func (m *LuaParkCarport) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaParkCarport.DiscardUnknown(m)
}

var xxx_messageInfo_LuaParkCarport proto.InternalMessageInfo

func (m *LuaParkCarport) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaParkCarport) GetBenefitRate() float32 {
	if m != nil && m.BenefitRate != nil {
		return *m.BenefitRate
	}
	return 0
}

// Excel:q抢车位.xls sheet:点赞效果
type LuaParkSayyes struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	Res                  []byte   `protobuf:"bytes,2,opt,name=res" json:"res,omitempty"`
	Effect               []byte   `protobuf:"bytes,3,opt,name=effect" json:"effect,omitempty"`
	ValueList            []int32  `protobuf:"zigzag32,4,rep,name=valueList" json:"valueList,omitempty"`
	Sound                []byte   `protobuf:"bytes,5,opt,name=sound" json:"sound,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaParkSayyes) Reset()         { *m = LuaParkSayyes{} }
func (m *LuaParkSayyes) String() string { return proto.CompactTextString(m) }
func (*LuaParkSayyes) ProtoMessage()    {}
func (*LuaParkSayyes) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{120}
}
func (m *LuaParkSayyes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaParkSayyes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaParkSayyes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaParkSayyes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaParkSayyes.Merge(m, src)
}
func (m *LuaParkSayyes) XXX_Size() int {
	return m.Size()
}
func (m *LuaParkSayyes) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaParkSayyes.DiscardUnknown(m)
}

var xxx_messageInfo_LuaParkSayyes proto.InternalMessageInfo

func (m *LuaParkSayyes) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaParkSayyes) GetRes() []byte {
	if m != nil {
		return m.Res
	}
	return nil
}

func (m *LuaParkSayyes) GetEffect() []byte {
	if m != nil {
		return m.Effect
	}
	return nil
}

func (m *LuaParkSayyes) GetValueList() []int32 {
	if m != nil {
		return m.ValueList
	}
	return nil
}

func (m *LuaParkSayyes) GetSound() []byte {
	if m != nil {
		return m.Sound
	}
	return nil
}

// Excel:q抢车位.xls sheet:修理位扩充价格
type LuaParkRepairPort struct {
	Id                   *int32        `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	CostItemList         []*ItemConfig `protobuf:"bytes,2,rep,name=costItemList" json:"costItemList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaParkRepairPort) Reset()         { *m = LuaParkRepairPort{} }
func (m *LuaParkRepairPort) String() string { return proto.CompactTextString(m) }
func (*LuaParkRepairPort) ProtoMessage()    {}
func (*LuaParkRepairPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{121}
}
func (m *LuaParkRepairPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaParkRepairPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaParkRepairPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaParkRepairPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaParkRepairPort.Merge(m, src)
}
func (m *LuaParkRepairPort) XXX_Size() int {
	return m.Size()
}
func (m *LuaParkRepairPort) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaParkRepairPort.DiscardUnknown(m)
}

var xxx_messageInfo_LuaParkRepairPort proto.InternalMessageInfo

func (m *LuaParkRepairPort) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaParkRepairPort) GetCostItemList() []*ItemConfig {
	if m != nil {
		return m.CostItemList
	}
	return nil
}

// Excel:家园表.xls sheet:家园等级表
type LuaHouseLevel struct {
	Level                *int32   `protobuf:"zigzag32,1,opt,name=level" json:"level,omitempty"`
	Exp                  *int32   `protobuf:"zigzag32,2,opt,name=exp" json:"exp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaHouseLevel) Reset()         { *m = LuaHouseLevel{} }
func (m *LuaHouseLevel) String() string { return proto.CompactTextString(m) }
func (*LuaHouseLevel) ProtoMessage()    {}
func (*LuaHouseLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{122}
}
func (m *LuaHouseLevel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaHouseLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaHouseLevel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaHouseLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaHouseLevel.Merge(m, src)
}
func (m *LuaHouseLevel) XXX_Size() int {
	return m.Size()
}
func (m *LuaHouseLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaHouseLevel.DiscardUnknown(m)
}

var xxx_messageInfo_LuaHouseLevel proto.InternalMessageInfo

func (m *LuaHouseLevel) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *LuaHouseLevel) GetExp() int32 {
	if m != nil && m.Exp != nil {
		return *m.Exp
	}
	return 0
}

// Excel:7天登陆.xls sheet:Sheet1
type LuaSevenDays struct {
	ID                   *int32        `protobuf:"zigzag32,1,opt,name=ID" json:"ID,omitempty"`
	Reward               []*ItemConfig `protobuf:"bytes,2,rep,name=reward" json:"reward,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaSevenDays) Reset()         { *m = LuaSevenDays{} }
func (m *LuaSevenDays) String() string { return proto.CompactTextString(m) }
func (*LuaSevenDays) ProtoMessage()    {}
func (*LuaSevenDays) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{123}
}
func (m *LuaSevenDays) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaSevenDays) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaSevenDays.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaSevenDays) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaSevenDays.Merge(m, src)
}
func (m *LuaSevenDays) XXX_Size() int {
	return m.Size()
}
func (m *LuaSevenDays) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaSevenDays.DiscardUnknown(m)
}

var xxx_messageInfo_LuaSevenDays proto.InternalMessageInfo

func (m *LuaSevenDays) GetID() int32 {
	if m != nil && m.ID != nil {
		return *m.ID
	}
	return 0
}

func (m *LuaSevenDays) GetReward() []*ItemConfig {
	if m != nil {
		return m.Reward
	}
	return nil
}

// Excel:pet宠物.xls sheet:宠物效果道具
type LuaPetPill struct {
	ItemId               *int32   `protobuf:"zigzag32,1,opt,name=itemId" json:"itemId,omitempty"`
	Type                 *int32   `protobuf:"zigzag32,2,opt,name=type" json:"type,omitempty"`
	EffectValue          *int32   `protobuf:"zigzag32,3,opt,name=effectValue" json:"effectValue,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaPetPill) Reset()         { *m = LuaPetPill{} }
func (m *LuaPetPill) String() string { return proto.CompactTextString(m) }
func (*LuaPetPill) ProtoMessage()    {}
func (*LuaPetPill) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{124}
}
func (m *LuaPetPill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaPetPill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaPetPill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaPetPill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaPetPill.Merge(m, src)
}
func (m *LuaPetPill) XXX_Size() int {
	return m.Size()
}
func (m *LuaPetPill) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaPetPill.DiscardUnknown(m)
}

var xxx_messageInfo_LuaPetPill proto.InternalMessageInfo

func (m *LuaPetPill) GetItemId() int32 {
	if m != nil && m.ItemId != nil {
		return *m.ItemId
	}
	return 0
}

func (m *LuaPetPill) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaPetPill) GetEffectValue() int32 {
	if m != nil && m.EffectValue != nil {
		return *m.EffectValue
	}
	return 0
}

// Excel:场景表.xls sheet:场景表
type LuaScene struct {
	Id                   *int32    `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	Type                 *int32    `protobuf:"zigzag32,2,opt,name=type" json:"type,omitempty"`
	NameID               []byte    `protobuf:"bytes,3,opt,name=nameID" json:"nameID,omitempty"`
	MaxRole              *int32    `protobuf:"zigzag32,4,opt,name=maxRole" json:"maxRole,omitempty"`
	IsCanMoreOpen        *int32    `protobuf:"zigzag32,5,opt,name=isCanMoreOpen" json:"isCanMoreOpen,omitempty"`
	MapList              []int32   `protobuf:"zigzag32,6,rep,name=mapList" json:"mapList,omitempty"`
	DataFile             []byte    `protobuf:"bytes,7,opt,name=dataFile" json:"dataFile,omitempty"`
	MapSize              *LuaSize  `protobuf:"bytes,8,opt,name=mapSize" json:"mapSize,omitempty"`
	TransportList        []int32   `protobuf:"zigzag32,9,rep,name=transportList" json:"transportList,omitempty"`
	FastTransEnable      *int32    `protobuf:"zigzag32,10,opt,name=fastTransEnable" json:"fastTransEnable,omitempty"`
	OpenFuncID           *int32    `protobuf:"zigzag32,11,opt,name=openFuncID" json:"openFuncID,omitempty"`
	BuildingList         []int32   `protobuf:"zigzag32,12,rep,name=buildingList" json:"buildingList,omitempty"`
	NpcList              []int32   `protobuf:"zigzag32,13,rep,name=npcList" json:"npcList,omitempty"`
	BornPosList          []*LuaPos `protobuf:"bytes,14,rep,name=bornPosList" json:"bornPosList,omitempty"`
	MusicList            [][]byte  `protobuf:"bytes,15,rep,name=musicList" json:"musicList,omitempty"`
	RoleScale            *float32  `protobuf:"fixed32,16,opt,name=roleScale" json:"roleScale,omitempty"`
	PetRefreshPosList    []*LuaPos `protobuf:"bytes,17,rep,name=petRefreshPosList" json:"petRefreshPosList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *LuaScene) Reset()         { *m = LuaScene{} }
func (m *LuaScene) String() string { return proto.CompactTextString(m) }
func (*LuaScene) ProtoMessage()    {}
func (*LuaScene) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{125}
}
func (m *LuaScene) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaScene) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaScene.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaScene) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaScene.Merge(m, src)
}
func (m *LuaScene) XXX_Size() int {
	return m.Size()
}
func (m *LuaScene) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaScene.DiscardUnknown(m)
}

var xxx_messageInfo_LuaScene proto.InternalMessageInfo

func (m *LuaScene) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaScene) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *LuaScene) GetNameID() []byte {
	if m != nil {
		return m.NameID
	}
	return nil
}

func (m *LuaScene) GetMaxRole() int32 {
	if m != nil && m.MaxRole != nil {
		return *m.MaxRole
	}
	return 0
}

func (m *LuaScene) GetIsCanMoreOpen() int32 {
	if m != nil && m.IsCanMoreOpen != nil {
		return *m.IsCanMoreOpen
	}
	return 0
}

func (m *LuaScene) GetMapList() []int32 {
	if m != nil {
		return m.MapList
	}
	return nil
}

func (m *LuaScene) GetDataFile() []byte {
	if m != nil {
		return m.DataFile
	}
	return nil
}

func (m *LuaScene) GetMapSize() *LuaSize {
	if m != nil {
		return m.MapSize
	}
	return nil
}

func (m *LuaScene) GetTransportList() []int32 {
	if m != nil {
		return m.TransportList
	}
	return nil
}

func (m *LuaScene) GetFastTransEnable() int32 {
	if m != nil && m.FastTransEnable != nil {
		return *m.FastTransEnable
	}
	return 0
}

func (m *LuaScene) GetOpenFuncID() int32 {
	if m != nil && m.OpenFuncID != nil {
		return *m.OpenFuncID
	}
	return 0
}

func (m *LuaScene) GetBuildingList() []int32 {
	if m != nil {
		return m.BuildingList
	}
	return nil
}

func (m *LuaScene) GetNpcList() []int32 {
	if m != nil {
		return m.NpcList
	}
	return nil
}

func (m *LuaScene) GetBornPosList() []*LuaPos {
	if m != nil {
		return m.BornPosList
	}
	return nil
}

func (m *LuaScene) GetMusicList() [][]byte {
	if m != nil {
		return m.MusicList
	}
	return nil
}

func (m *LuaScene) GetRoleScale() float32 {
	if m != nil && m.RoleScale != nil {
		return *m.RoleScale
	}
	return 0
}

func (m *LuaScene) GetPetRefreshPosList() []*LuaPos {
	if m != nil {
		return m.PetRefreshPosList
	}
	return nil
}

// Excel:竞技场表.xls sheet:每日排名奖励表
type LuaArenaDayRank struct {
	Id                   *int32        `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	RankRect             []int32       `protobuf:"zigzag32,2,rep,name=rankRect" json:"rankRect,omitempty"`
	RewardList           []*ItemConfig `protobuf:"bytes,3,rep,name=rewardList" json:"rewardList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LuaArenaDayRank) Reset()         { *m = LuaArenaDayRank{} }
func (m *LuaArenaDayRank) String() string { return proto.CompactTextString(m) }
func (*LuaArenaDayRank) ProtoMessage()    {}
func (*LuaArenaDayRank) Descriptor() ([]byte, []int) {
	return fileDescriptor_01619d082ff2f883, []int{126}
}
func (m *LuaArenaDayRank) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaArenaDayRank) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaArenaDayRank.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaArenaDayRank) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaArenaDayRank.Merge(m, src)
}
func (m *LuaArenaDayRank) XXX_Size() int {
	return m.Size()
}
func (m *LuaArenaDayRank) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaArenaDayRank.DiscardUnknown(m)
}

var xxx_messageInfo_LuaArenaDayRank proto.InternalMessageInfo

func (m *LuaArenaDayRank) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *LuaArenaDayRank) GetRankRect() []int32 {
	if m != nil {
		return m.RankRect
	}
	return nil
}

func (m *LuaArenaDayRank) GetRewardList() []*ItemConfig {
	if m != nil {
		return m.RewardList
	}
	return nil
}

func init() {
	proto.RegisterType((*LuaSignReward)(nil), "pbd.lua_sign_reward")
	proto.RegisterType((*LuaParkShop)(nil), "pbd.lua_park_shop")
	proto.RegisterType((*LuaDailyActivity)(nil), "pbd.lua_daily_activity")
	proto.RegisterType((*LuaAchieve)(nil), "pbd.lua_achieve")
	proto.RegisterType((*LuaFaceShop)(nil), "pbd.lua_face_shop")
	proto.RegisterType((*LuaBgm)(nil), "pbd.lua_bgm")
	proto.RegisterType((*LuaArenaReward)(nil), "pbd.lua_arena_reward")
	proto.RegisterType((*LuaArenaSelectRule)(nil), "pbd.lua_arena_select_rule")
	proto.RegisterType((*LuaDangerChapter)(nil), "pbd.lua_danger_chapter")
	proto.RegisterType((*LuaAssistantTip)(nil), "pbd.lua_assistant_tip")
	proto.RegisterType((*LuaVehicleCompose)(nil), "pbd.lua_vehicle_compose")
	proto.RegisterType((*LuaChapter)(nil), "pbd.lua_chapter")
	proto.RegisterType((*LuaBuilding)(nil), "pbd.lua_building")
	proto.RegisterType((*LuaDiamondShop)(nil), "pbd.lua_diamond_shop")
	proto.RegisterType((*LuaParkBreak)(nil), "pbd.lua_park_break")
	proto.RegisterType((*LuaParkCar)(nil), "pbd.lua_park_car")
	proto.RegisterType((*LuaPetPassiveTalent)(nil), "pbd.lua_pet_passive_talent")
	proto.RegisterType((*LuaEquipManual)(nil), "pbd.lua_equip_manual")
	proto.RegisterType((*LuaMinigameShop)(nil), "pbd.lua_minigame_shop")
	proto.RegisterType((*LuaTransInfo)(nil), "pbd.lua_trans_info")
	proto.RegisterType((*LuaSkill)(nil), "pbd.lua_skill")
	proto.RegisterType((*LuaBuyStamina)(nil), "pbd.lua_buy_stamina")
	proto.RegisterType((*LuaGuadraticBoss)(nil), "pbd.lua_guadratic_boss")
	proto.RegisterType((*LuaVipSale)(nil), "pbd.lua_vip_sale")
	proto.RegisterType((*LuaZuipao)(nil), "pbd.lua_zuipao")
	proto.RegisterType((*LuaParkShopRandom)(nil), "pbd.lua_park_shop_random")
	proto.RegisterType((*LuaNiudan)(nil), "pbd.lua_niudan")
	proto.RegisterType((*LuaPet)(nil), "pbd.lua_pet")
	proto.RegisterType((*LuaParkPlace)(nil), "pbd.lua_park_place")
	proto.RegisterType((*LuaRoleCreate)(nil), "pbd.lua_role_create")
	proto.RegisterType((*LuaNiudanShopRandom)(nil), "pbd.lua_niudan_shop_random")
	proto.RegisterType((*LuaSkillShopRandom)(nil), "pbd.lua_skill_shop_random")
	proto.RegisterType((*LuaReward)(nil), "pbd.lua_reward")
	proto.RegisterType((*LuaPetTalentLevel)(nil), "pbd.lua_pet_talent_level")
	proto.RegisterType((*LuaNotable)(nil), "pbd.lua_notable")
	proto.RegisterType((*LuaFace)(nil), "pbd.lua_face")
	proto.RegisterType((*LuaDailyTask)(nil), "pbd.lua_daily_task")
	proto.RegisterType((*LuaArenaNpc)(nil), "pbd.lua_arena_npc")
	proto.RegisterType((*LuaCard)(nil), "pbd.lua_card")
	proto.RegisterType((*LuaHangup)(nil), "pbd.lua_hangup")
	proto.RegisterType((*LuaDiamondShopRandom)(nil), "pbd.lua_diamond_shop_random")
	proto.RegisterType((*LuaNiudanShop)(nil), "pbd.lua_niudan_shop")
	proto.RegisterType((*LuaSuitShop)(nil), "pbd.lua_suit_shop")
	proto.RegisterType((*LuaRisk)(nil), "pbd.lua_risk")
	proto.RegisterType((*LuaGuadraticLevelReward)(nil), "pbd.lua_guadratic_level_reward")
	proto.RegisterType((*LuaBlackShopRandom)(nil), "pbd.lua_black_shop_random")
	proto.RegisterType((*LuaBlackShop)(nil), "pbd.lua_black_shop")
	proto.RegisterType((*LuaSceneFail)(nil), "pbd.lua_scene_fail")
	proto.RegisterType((*LuaBathFightStep)(nil), "pbd.lua_bath_fight_step")
	proto.RegisterType((*LuaBathToolType)(nil), "pbd.lua_bath_tool_type")
	proto.RegisterType((*LuaArenaTemplate)(nil), "pbd.lua_arena_template")
	proto.RegisterType((*LuaBathFightEnd)(nil), "pbd.lua_bath_fight_end")
	proto.RegisterType((*LuaBathStatus)(nil), "pbd.lua_bath_status")
	proto.RegisterType((*LuaStoneExchange)(nil), "pbd.lua_stone_exchange")
	proto.RegisterType((*LuaMinigameRank)(nil), "pbd.lua_minigame_rank")
	proto.RegisterType((*LuaFriendLevel)(nil), "pbd.lua_friend_level")
	proto.RegisterType((*LuaMinigameLevel)(nil), "pbd.lua_minigame_level")
	proto.RegisterType((*LuaGuadraticDup)(nil), "pbd.lua_guadratic_dup")
	proto.RegisterType((*LuaMinigameScore)(nil), "pbd.lua_minigame_score")
	proto.RegisterType((*LuaArenaShopRandom)(nil), "pbd.lua_arena_shop_random")
	proto.RegisterType((*LuaRoleLevel)(nil), "pbd.lua_role_level")
	proto.RegisterType((*LuaArenaShop)(nil), "pbd.lua_arena_shop")
	proto.RegisterType((*LuaAvatarConfig)(nil), "pbd.lua_avatar_config")
	proto.RegisterType((*LuaPetLevel)(nil), "pbd.lua_pet_level")
	proto.RegisterType((*LuaFunctionOpen)(nil), "pbd.lua_function_open")
	proto.RegisterType((*LuaMainTaskModule)(nil), "pbd.lua_main_task_module")
	proto.RegisterType((*LuaHouseStorage)(nil), "pbd.lua_house_storage")
	proto.RegisterType((*LuaBuyBitcoin)(nil), "pbd.lua_buy_bitcoin")
	proto.RegisterType((*LuaSword)(nil), "pbd.lua_sword")
	proto.RegisterType((*LuaArenaHistoryRank)(nil), "pbd.lua_arena_history_rank")
	proto.RegisterType((*LuaBorn)(nil), "pbd.lua_born")
	proto.RegisterType((*LuaSignCost)(nil), "pbd.lua_sign_cost")
	proto.RegisterType((*LuaMinigame)(nil), "pbd.lua_minigame")
	proto.RegisterType((*LuaGuadraticReward)(nil), "pbd.lua_guadratic_reward")
	proto.RegisterType((*LuaRiskFightReset)(nil), "pbd.lua_risk_fight_reset")
	proto.RegisterType((*LuaEasterEgg)(nil), "pbd.lua_easter_egg")
	proto.RegisterType((*LuaEquipMake)(nil), "pbd.lua_equip_make")
	proto.RegisterType((*LuaRoleSkill)(nil), "pbd.lua_role_skill")
	proto.RegisterType((*LuaDailyActivityGrowReward)(nil), "pbd.lua_daily_activity_growReward")
	proto.RegisterType((*LuaEquipFix)(nil), "pbd.lua_equip_fix")
	proto.RegisterType((*LuaNiudanPackage)(nil), "pbd.lua_niudan_package")
	proto.RegisterType((*LuaTransport)(nil), "pbd.lua_transport")
	proto.RegisterType((*LuaGuadraticBossSkill)(nil), "pbd.lua_guadratic_boss_skill")
	proto.RegisterType((*LuaSkillHole)(nil), "pbd.lua_skill_hole")
	proto.RegisterType((*LuaRandomBox)(nil), "pbd.lua_random_box")
	proto.RegisterType((*LuaCommonShop)(nil), "pbd.lua_common_shop")
	proto.RegisterType((*LuaParkItem)(nil), "pbd.lua_park_item")
	proto.RegisterType((*LuaDailySubtask)(nil), "pbd.lua_daily_subtask")
	proto.RegisterType((*LuaInteraction)(nil), "pbd.lua_interaction")
	proto.RegisterType((*LuaGiftBag)(nil), "pbd.lua_gift_bag")
	proto.RegisterType((*LuaMinigameShopRandom)(nil), "pbd.lua_minigame_shop_random")
	proto.RegisterType((*LuaSwordResult)(nil), "pbd.lua_sword_result")
	proto.RegisterType((*LuaNpcInteract)(nil), "pbd.lua_npc_interact")
	proto.RegisterType((*LuaFaceLvl)(nil), "pbd.lua_face_lvl")
	proto.RegisterType((*LuaEquipBag)(nil), "pbd.lua_equip_bag")
	proto.RegisterType((*LuaMainTask)(nil), "pbd.lua_main_task")
	proto.RegisterType((*LuaExchangeGold)(nil), "pbd.lua_exchange_gold")
	proto.RegisterType((*LuaSuit)(nil), "pbd.lua_suit")
	proto.RegisterType((*LuaGlobalConfig)(nil), "pbd.lua_global_config")
	proto.RegisterType((*LuaInteractSystem)(nil), "pbd.lua_interact_system")
	proto.RegisterType((*LuaParkDriver)(nil), "pbd.lua_park_driver")
	proto.RegisterType((*LuaHouseShop)(nil), "pbd.lua_house_shop")
	proto.RegisterType((*LuaFindwayGuid)(nil), "pbd.lua_findway_guid")
	proto.RegisterType((*LuaParkGaragePort)(nil), "pbd.lua_park_garage_port")
	proto.RegisterType((*LuaInteractManual)(nil), "pbd.lua_interact_manual")
	proto.RegisterType((*LuaFaceDiscount)(nil), "pbd.lua_face_discount")
	proto.RegisterType((*LuaParkEvent)(nil), "pbd.lua_park_event")
	proto.RegisterType((*LuaNpc)(nil), "pbd.lua_npc")
	proto.RegisterType((*LuaWingExtraEffect)(nil), "pbd.lua_wing_extra_effect")
	proto.RegisterType((*LuaHouseExpand)(nil), "pbd.lua_house_expand")
	proto.RegisterType((*LuaItem)(nil), "pbd.lua_item")
	proto.RegisterType((*LuaSkillShop)(nil), "pbd.lua_skill_shop")
	proto.RegisterType((*LuaEquip)(nil), "pbd.lua_equip")
	proto.RegisterType((*LuaPetActSkill)(nil), "pbd.lua_pet_act_skill")
	proto.RegisterType((*LuaVip)(nil), "pbd.lua_vip")
	proto.RegisterType((*LuaFurniture)(nil), "pbd.lua_furniture")
	proto.RegisterType((*LuaArenaBuy)(nil), "pbd.lua_arena_buy")
	proto.RegisterType((*LuaBattleWave)(nil), "pbd.lua_battle_wave")
	proto.RegisterType((*LuaMiniWarrior)(nil), "pbd.lua_mini_warrior")
	proto.RegisterType((*LuaParkCarport)(nil), "pbd.lua_park_carport")
	proto.RegisterType((*LuaParkSayyes)(nil), "pbd.lua_park_sayyes")
	proto.RegisterType((*LuaParkRepairPort)(nil), "pbd.lua_park_repair_port")
	proto.RegisterType((*LuaHouseLevel)(nil), "pbd.lua_house_level")
	proto.RegisterType((*LuaSevenDays)(nil), "pbd.lua_seven_days")
	proto.RegisterType((*LuaPetPill)(nil), "pbd.lua_pet_pill")
	proto.RegisterType((*LuaScene)(nil), "pbd.lua_scene")
	proto.RegisterType((*LuaArenaDayRank)(nil), "pbd.lua_arena_day_rank")
}

func init() { proto.RegisterFile("ServerDef.proto", fileDescriptor_01619d082ff2f883) }

var fileDescriptor_01619d082ff2f883 = []byte{
	// 8659 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x7d, 0x4b, 0x8c, 0x24, 0x49,
	0x9a, 0x16, 0xf9, 0x88, 0x7c, 0x58, 0x44, 0x64, 0x66, 0x44, 0x66, 0x56, 0x45, 0x3d, 0xbb, 0x3a,
	0xba, 0xa7, 0xa7, 0x7a, 0xba, 0xa7, 0x67, 0xbb, 0x67, 0x58, 0x76, 0x81, 0x5d, 0xc8, 0xcc, 0xa8,
	0xca, 0xca, 0xa5, 0x1e, 0x39, 0x99, 0x55, 0xfd, 0x98, 0xe9, 0xd9, 0x58, 0x0b, 0x77, 0x8b, 0x08,
	0x23, 0x3c, 0xdc, 0xbd, 0xcd, 0xcd, 0x23, 0x33, 0x9b, 0x03, 0xbb, 0xd2, 0xde, 0x38, 0x81, 0x10,
	0x20, 0x21, 0x90, 0x56, 0x20, 0x21, 0x0e, 0x70, 0x43, 0x42, 0x42, 0x80, 0xf6, 0xb6, 0x2b, 0x2e,
	0x7b, 0x42, 0x5c, 0x80, 0xd5, 0x00, 0x42, 0x7b, 0x42, 0x42, 0x70, 0x44, 0x42, 0xf6, 0xff, 0xf6,
	0x9b, 0x9b, 0xc7, 0x23, 0xbb, 0x6b, 0x28, 0x0e, 0x7b, 0xaa, 0x0a, 0x33, 0x73, 0x7b, 0xfe, 0xcf,
	0xef, 0xff, 0xcd, 0x92, 0x6d, 0x9f, 0x0b, 0x35, 0x11, 0xaa, 0x23, 0xfa, 0x1f, 0xa5, 0x2a, 0xd1,
	0x49, 0x73, 0x25, 0xed, 0x85, 0xb7, 0xb7, 0x4e, 0xcd, 0xff, 0x5d, 0xe1, 0xed, 0x26, 0xfc, 0x3e,
	0xe4, 0x99, 0x70, 0x65, 0xed, 0x23, 0xb6, 0x1d, 0xe5, 0xbc, 0x9b, 0xc9, 0x41, 0xdc, 0x55, 0xe2,
	0x82, 0xab, 0xb0, 0xc9, 0xd8, 0xf2, 0x49, 0xa7, 0xb5, 0xf4, 0x60, 0xe9, 0x61, 0xa3, 0xf9, 0x2e,
	0x5b, 0xc3, 0xd2, 0xd6, 0xf2, 0x83, 0x95, 0x87, 0xd5, 0x4f, 0xf6, 0x3e, 0x4a, 0x7b, 0xe1, 0x47,
	0xd0, 0x3a, 0xe4, 0x57, 0xf6, 0x8b, 0xf6, 0x97, 0xac, 0x6e, 0x3a, 0x49, 0xb9, 0x1a, 0x75, 0xb3,
	0x61, 0x92, 0x36, 0xb7, 0xd8, 0x9a, 0xd4, 0x62, 0x7c, 0x12, 0xda, 0x6e, 0xea, 0xac, 0x12, 0x70,
	0x75, 0x62, 0x7a, 0x31, 0x3f, 0xab, 0x6c, 0x25, 0xce, 0xc7, 0xad, 0x15, 0xf8, 0xb1, 0xc3, 0x36,
	0x82, 0x24, 0xd3, 0x2f, 0xaf, 0x52, 0xd1, 0x5a, 0xa5, 0xd6, 0xa9, 0x92, 0x81, 0x68, 0x55, 0xcc,
	0xcf, 0xf6, 0x31, 0x6b, 0x9a, 0xde, 0x43, 0x2e, 0xa3, 0xab, 0x2e, 0x0f, 0xb4, 0x9c, 0x48, 0x7d,
	0x65, 0x66, 0x29, 0xa9, 0xfb, 0x7d, 0x56, 0xa7, 0xf2, 0x4f, 0x79, 0x94, 0x0b, 0x3b, 0xcc, 0x96,
	0x9b, 0xfc, 0xca, 0x83, 0x95, 0x87, 0x8d, 0xf6, 0x1f, 0x2e, 0xb1, 0xaa, 0xe9, 0x89, 0x07, 0x43,
	0x29, 0x26, 0xa2, 0xd4, 0xc5, 0x0e, 0xdb, 0xd0, 0x57, 0xa9, 0x78, 0xce, 0xc7, 0xf8, 0x75, 0xad,
	0x59, 0x63, 0xab, 0xb1, 0xf9, 0xb5, 0x42, 0xbf, 0x74, 0x31, 0x43, 0xb3, 0xbe, 0xec, 0x89, 0x0c,
	0xed, 0x14, 0xcd, 0x82, 0x42, 0x91, 0xb5, 0xd6, 0xa0, 0xe9, 0x0d, 0xb6, 0x15, 0x24, 0x71, 0x28,
	0xb5, 0x4c, 0x62, 0x9c, 0xce, 0xfa, 0x83, 0xa5, 0x87, 0xcd, 0xe6, 0x1e, 0xab, 0xd9, 0x91, 0x4f,
	0x13, 0x19, 0xeb, 0xd6, 0x86, 0xdd, 0x61, 0x86, 0x93, 0x7c, 0x2a, 0x33, 0xdd, 0xda, 0x84, 0x5d,
	0xde, 0x81, 0x5d, 0x36, 0x3b, 0xd8, 0x0d, 0x92, 0xb8, 0x2f, 0x07, 0xcd, 0x6d, 0xb6, 0xfe, 0x55,
	0xce, 0x23, 0xa9, 0xaf, 0x5a, 0x0c, 0x36, 0xe5, 0x67, 0xb8, 0xe5, 0x7d, 0x1e, 0x08, 0xdc, 0xf2,
	0x3a, 0xab, 0xc8, 0x38, 0x14, 0x97, 0x76, 0x3d, 0xb8, 0xb6, 0x65, 0x5a, 0x5b, 0x98, 0x2b, 0x6e,
	0xe6, 0x83, 0x3b, 0x71, 0xfd, 0x9e, 0x9b, 0xad, 0xfa, 0x29, 0x5b, 0x37, 0xdd, 0xf7, 0x06, 0xe3,
	0xd2, 0x2e, 0x35, 0xd8, 0x66, 0x6f, 0x30, 0x36, 0x9b, 0x74, 0xd2, 0xb1, 0xdb, 0x54, 0x67, 0x95,
	0x2c, 0xc9, 0xe3, 0xd0, 0xee, 0xd3, 0x1e, 0xab, 0xc5, 0x42, 0x84, 0x9f, 0xca, 0xf4, 0xa9, 0x98,
	0x88, 0xc8, 0xf6, 0x6e, 0x76, 0x4f, 0x8e, 0x71, 0xb7, 0x96, 0xdb, 0x9a, 0xed, 0xc0, 0x31, 0x28,
	0x11, 0x73, 0x22, 0xba, 0x3a, 0xab, 0x44, 0xf0, 0x01, 0x0e, 0xf4, 0x5d, 0x56, 0xbf, 0x90, 0xf1,
	0x59, 0xb1, 0x31, 0xcb, 0x0b, 0x36, 0xe6, 0x21, 0xdb, 0x8a, 0x92, 0x4c, 0x78, 0x2d, 0x57, 0xe6,
	0xb7, 0x6c, 0x77, 0xd9, 0x7e, 0x31, 0x6a, 0x26, 0x22, 0x11, 0xe8, 0xae, 0xca, 0xa3, 0x19, 0x32,
	0x50, 0x3c, 0x1e, 0x9d, 0x89, 0x00, 0x87, 0x6c, 0x34, 0x1f, 0xb2, 0x6a, 0x9a, 0x64, 0xa6, 0xc0,
	0xeb, 0x7d, 0x17, 0x7a, 0xf7, 0x17, 0x11, 0xe8, 0xf6, 0x1f, 0x2c, 0x11, 0xa1, 0xc6, 0x03, 0xa1,
	0xba, 0xc1, 0x90, 0xa7, 0x5a, 0xa8, 0x52, 0xf7, 0x5b, 0x6c, 0x2d, 0xf6, 0x37, 0x6f, 0x9b, 0xad,
	0x87, 0x79, 0xea, 0x3a, 0x86, 0x8d, 0x92, 0x41, 0x12, 0xc3, 0xb6, 0xc1, 0xde, 0x6a, 0xa9, 0x23,
	0xdc, 0xb7, 0x9a, 0x99, 0x5c, 0x94, 0x04, 0xa3, 0x13, 0xd3, 0x00, 0x49, 0xad, 0x4c, 0x3c, 0xeb,
	0x0b, 0xf6, 0x68, 0x87, 0x6d, 0x64, 0x43, 0xae, 0xc4, 0xa9, 0x0c, 0x80, 0xe8, 0x6a, 0xcd, 0xfb,
	0x6c, 0x43, 0xc4, 0x62, 0x7c, 0x75, 0x9a, 0x64, 0xad, 0xcd, 0x07, 0x4b, 0x0f, 0xab, 0x9f, 0xd4,
	0xdc, 0x8a, 0xd2, 0x24, 0x6b, 0xe7, 0xac, 0x01, 0x8b, 0xcb, 0x32, 0x99, 0x69, 0x1e, 0xeb, 0xae,
	0x96, 0x69, 0x69, 0x21, 0x4d, 0xc6, 0xbe, 0xca, 0x45, 0x66, 0x48, 0xca, 0x2d, 0x66, 0x87, 0x6d,
	0xf0, 0x38, 0xbb, 0x10, 0xea, 0xa4, 0x53, 0x30, 0x8d, 0xb7, 0x9a, 0x07, 0x8e, 0x1d, 0x2b, 0x30,
	0xe4, 0xec, 0x11, 0x71, 0xb6, 0x6b, 0x86, 0x9d, 0x88, 0xa1, 0x0c, 0x22, 0xd1, 0x0d, 0x92, 0x71,
	0x9a, 0x64, 0xc2, 0x27, 0x7e, 0x1c, 0xfd, 0x3d, 0x24, 0xb2, 0x13, 0x2d, 0xc6, 0xd7, 0x12, 0x47,
	0x83, 0x6d, 0x9a, 0x76, 0x48, 0x89, 0x20, 0x6d, 0xda, 0xbf, 0x6f, 0x65, 0xc0, 0x9f, 0xe6, 0xd3,
	0xf9, 0x9d, 0x25, 0x56, 0x03, 0xee, 0xcc, 0x65, 0x14, 0xca, 0x78, 0x70, 0xed, 0x22, 0xb6, 0xd8,
	0xda, 0xd7, 0x2f, 0x54, 0x28, 0x94, 0x15, 0xb7, 0x65, 0x41, 0xb6, 0xcd, 0xd6, 0x95, 0xc8, 0x40,
	0x0e, 0x38, 0x49, 0xa6, 0x9c, 0x24, 0xbb, 0xc5, 0x56, 0xd2, 0x24, 0x03, 0xf1, 0x35, 0x3d, 0x87,
	0x2f, 0x91, 0x87, 0x43, 0xc9, 0xc7, 0x49, 0x1c, 0xa2, 0x08, 0x9a, 0x9a, 0x06, 0x68, 0x80, 0xce,
	0x2f, 0x24, 0xf2, 0xff, 0x1a, 0xdb, 0x72, 0x0a, 0xa5, 0xa7, 0x04, 0x1f, 0x7d, 0xd3, 0x12, 0x43,
	0x91, 0x05, 0x8e, 0xec, 0xec, 0x1a, 0x56, 0xa9, 0x52, 0xf4, 0xfb, 0x86, 0x9f, 0xf1, 0x98, 0x1a,
	0x6c, 0x73, 0x62, 0x84, 0x32, 0x9c, 0xc9, 0x1a, 0x1c, 0xab, 0x13, 0x61, 0x66, 0xa1, 0xb5, 0xf6,
	0xef, 0xac, 0xe0, 0xf6, 0xc2, 0xe8, 0x01, 0xbf, 0x9e, 0x46, 0x88, 0x24, 0x56, 0x68, 0x3b, 0x89,
	0x52, 0x57, 0x69, 0xa5, 0x63, 0x7e, 0x89, 0x04, 0x58, 0xa1, 0x12, 0xd3, 0xf1, 0x4b, 0x23, 0x0e,
	0xd7, 0xa0, 0x64, 0x8f, 0xd5, 0x8c, 0x2e, 0x16, 0x81, 0x2e, 0xb4, 0x45, 0xa3, 0xd9, 0x62, 0x3b,
	0x11, 0xcf, 0xf4, 0xa9, 0x5f, 0x83, 0x1a, 0xe3, 0x26, 0xdb, 0x56, 0x22, 0xe5, 0x52, 0x1d, 0x25,
	0x99, 0x3e, 0x4a, 0xf2, 0x58, 0x03, 0x95, 0x34, 0x9a, 0xb7, 0x58, 0x23, 0x14, 0x96, 0x69, 0x8e,
	0x85, 0xad, 0x02, 0x75, 0xd1, 0x7c, 0x9f, 0x6d, 0x9b, 0x51, 0x5f, 0xc5, 0x52, 0x1f, 0x8a, 0x58,
	0xf4, 0xa5, 0x6e, 0x55, 0xe7, 0x33, 0x61, 0xf3, 0x3e, 0xbb, 0xc1, 0xc3, 0xf0, 0xb4, 0xdc, 0xfa,
	0x8c, 0x6b, 0xd1, 0xaa, 0x19, 0xe9, 0xdd, 0x7c, 0x8b, 0xdd, 0xcc, 0xf8, 0xd5, 0x17, 0x22, 0x3b,
	0x13, 0x61, 0x1e, 0x88, 0x67, 0xfc, 0xf2, 0x94, 0xd6, 0x53, 0x87, 0xb1, 0x1e, 0x30, 0x66, 0xc6,
	0x7a, 0xd1, 0xef, 0x67, 0x42, 0xb7, 0xb6, 0x66, 0x89, 0xc7, 0xb4, 0xc8, 0x86, 0xc9, 0x85, 0x6d,
	0xb1, 0x3d, 0x87, 0xbc, 0xfe, 0xc1, 0x12, 0xbb, 0x01, 0xff, 0x17, 0xba, 0x9b, 0x1a, 0x31, 0x34,
	0x11, 0x5d, 0xcd, 0x23, 0x11, 0xeb, 0x19, 0xad, 0x0d, 0xa5, 0xd6, 0xb4, 0xa8, 0x35, 0x77, 0x59,
	0x15, 0x4b, 0x3a, 0x22, 0x3b, 0x21, 0xa5, 0x64, 0x88, 0x31, 0x48, 0xe2, 0x93, 0xb0, 0xa0, 0x89,
	0x0b, 0x21, 0x07, 0x43, 0x6d, 0xcf, 0x84, 0x78, 0x62, 0x8d, 0x0e, 0x91, 0xab, 0x81, 0xe3, 0xd9,
	0x46, 0x99, 0x64, 0x36, 0x40, 0x3f, 0x1e, 0x20, 0xf9, 0x8b, 0xaf, 0x72, 0x99, 0x76, 0xc7, 0x3c,
	0xce, 0x79, 0x44, 0x24, 0xbe, 0x64, 0x37, 0xa1, 0x30, 0x9c, 0xe6, 0x0b, 0xbb, 0x9f, 0xa1, 0x8c,
	0x1d, 0xcb, 0x58, 0x0e, 0xf8, 0x58, 0xbc, 0x69, 0x16, 0xfa, 0x0d, 0x64, 0x21, 0xad, 0x78, 0x9c,
	0x75, 0x65, 0xdc, 0x4f, 0x66, 0x37, 0x4e, 0x0d, 0x84, 0x76, 0xbd, 0xdf, 0x66, 0xab, 0x46, 0x8b,
	0x59, 0x05, 0x57, 0x3e, 0x8d, 0xff, 0x5c, 0x61, 0x9b, 0x60, 0x25, 0x8e, 0x64, 0x14, 0xbd, 0x16,
	0x2b, 0x1a, 0x9d, 0xa0, 0xc6, 0xdc, 0x9b, 0x26, 0xed, 0x75, 0x85, 0x68, 0x5f, 0x4c, 0x44, 0xac,
	0x8f, 0x92, 0xd8, 0x63, 0x48, 0x2a, 0xfd, 0x94, 0x47, 0xde, 0x31, 0x34, 0x19, 0xe3, 0x7a, 0xf4,
	0xa8, 0xdf, 0x2f, 0xce, 0xc1, 0x94, 0x85, 0xa2, 0x4f, 0x65, 0x9b, 0x50, 0xb6, 0xcf, 0xea, 0xa9,
	0x12, 0x07, 0x45, 0x53, 0xe6, 0x15, 0x77, 0x8a, 0xd6, 0x55, 0x32, 0x85, 0xb8, 0x1e, 0x9d, 0x03,
	0xff, 0xd7, 0xc8, 0x84, 0xe9, 0x47, 0x57, 0x8f, 0xfa, 0xfd, 0x93, 0x0e, 0xb4, 0xab, 0xd3, 0xe7,
	0xc3, 0x5c, 0xe9, 0xa2, 0x78, 0x8b, 0x3e, 0x57, 0x22, 0x3b, 0x01, 0xcb, 0x6b, 0x9b, 0xc8, 0xc7,
	0x0c, 0x1f, 0xcb, 0x71, 0x6b, 0x87, 0xd4, 0x48, 0xaa, 0x04, 0x30, 0x48, 0x03, 0x38, 0x68, 0x9b,
	0xad, 0xf7, 0xa3, 0x2b, 0x68, 0xd1, 0xa4, 0x16, 0x5c, 0x8f, 0xa0, 0x60, 0x97, 0xa8, 0x98, 0x6b,
	0xe0, 0x29, 0x18, 0x6a, 0xef, 0xc1, 0xca, 0xc3, 0x65, 0x63, 0x57, 0x72, 0x3d, 0x7a, 0x92, 0x2b,
	0x7d, 0x2a, 0x14, 0x94, 0xef, 0xd3, 0x6e, 0xd1, 0x0a, 0xa0, 0xf4, 0xc6, 0x83, 0x95, 0x87, 0xb5,
	0xe6, 0x43, 0x56, 0xcf, 0x86, 0x7c, 0x24, 0x5c, 0x27, 0x37, 0xe1, 0x60, 0x1b, 0x68, 0xc0, 0x9b,
	0x1a, 0x62, 0x78, 0xbb, 0xaf, 0x71, 0x08, 0x53, 0x6c, 0xc1, 0x14, 0x9b, 0x8c, 0x21, 0x7d, 0xc0,
	0xc9, 0xdd, 0xa2, 0x85, 0x85, 0x12, 0x75, 0xc5, 0x6d, 0x28, 0xb8, 0xc3, 0x76, 0x33, 0xcd, 0x95,
	0x3e, 0xcc, 0xfb, 0xfd, 0x97, 0xd0, 0x1a, 0x06, 0xba, 0x43, 0xfb, 0xe5, 0x2a, 0xa1, 0xf8, 0x2e,
	0x14, 0xdf, 0x62, 0x0d, 0x11, 0x87, 0x53, 0x5f, 0xdc, 0x83, 0xaa, 0x5d, 0x56, 0xb5, 0x55, 0x50,
	0x78, 0xdf, 0x1d, 0x30, 0x1f, 0xf3, 0x81, 0x80, 0x71, 0xdf, 0x82, 0x71, 0x77, 0x59, 0x35, 0x15,
	0xca, 0x6c, 0x04, 0x34, 0x7c, 0x40, 0x5f, 0xf7, 0xe5, 0xa5, 0x2b, 0x7c, 0x9b, 0x38, 0xd7, 0x1c,
	0x1a, 0x9e, 0x6e, 0x9b, 0x4e, 0xd7, 0x14, 0x99, 0xee, 0x3a, 0x5c, 0xf3, 0xd6, 0x3b, 0xc0, 0xcf,
	0x1f, 0xa1, 0x1b, 0xd4, 0xcb, 0xaf, 0xba, 0x99, 0xe6, 0x63, 0x19, 0xf3, 0x12, 0x99, 0xc3, 0xd2,
	0x41, 0xd3, 0x21, 0xb7, 0xb4, 0xff, 0x83, 0xb5, 0xf5, 0x06, 0x39, 0x0f, 0x8d, 0x65, 0x1d, 0x74,
	0x7b, 0x49, 0x96, 0x4d, 0xdb, 0xca, 0x22, 0xd6, 0x42, 0xc1, 0xc4, 0x9d, 0x21, 0x2e, 0x2e, 0x25,
	0xee, 0xe9, 0x0a, 0x35, 0x1a, 0x27, 0x13, 0x71, 0x9e, 0x0a, 0x11, 0x5a, 0x06, 0x71, 0xdf, 0x91,
	0xc1, 0x5c, 0x14, 0x99, 0xd5, 0x59, 0x21, 0xf5, 0x2e, 0xab, 0xbb, 0xa2, 0x73, 0xf9, 0xb5, 0xb0,
	0x4a, 0xba, 0xee, 0xf8, 0x36, 0x93, 0x5f, 0x0b, 0xd2, 0x84, 0x68, 0x56, 0x34, 0x19, 0x83, 0x4f,
	0x70, 0x37, 0x36, 0x49, 0x1b, 0x02, 0x53, 0x17, 0x7c, 0xd2, 0xfe, 0xc7, 0xd6, 0xba, 0x98, 0xc8,
	0xb4, 0x9b, 0xf1, 0x29, 0xfb, 0xd8, 0x09, 0x99, 0x65, 0x3a, 0x89, 0x9e, 0x71, 0x27, 0xed, 0xde,
	0xac, 0x38, 0x9e, 0xbe, 0xd4, 0x8a, 0x53, 0xa9, 0x5b, 0x56, 0x5f, 0xaa, 0x4c, 0x3f, 0x8e, 0xf8,
	0xc0, 0x2e, 0xeb, 0x16, 0x6b, 0x40, 0xd1, 0x23, 0xbf, 0xf5, 0x1a, 0x8d, 0x23, 0x79, 0x7a, 0xd2,
	0x41, 0x95, 0x6c, 0x3e, 0x96, 0x3c, 0x3d, 0xcf, 0xfb, 0x7d, 0x79, 0x89, 0xab, 0x69, 0xff, 0xee,
	0x12, 0x63, 0x66, 0x9a, 0x5f, 0xe7, 0x32, 0xe5, 0xc9, 0xb4, 0xff, 0xb0, 0xcd, 0xd6, 0x61, 0x5d,
	0x4e, 0xbc, 0x99, 0xe1, 0x79, 0x20, 0x50, 0x27, 0xba, 0xbd, 0x2f, 0xac, 0xc3, 0x55, 0x52, 0xba,
	0x3c, 0x0c, 0x1f, 0xc5, 0x42, 0x0d, 0xae, 0x4e, 0x85, 0x0a, 0x44, 0x8c, 0x2a, 0x02, 0x98, 0x0f,
	0x37, 0xca, 0xb4, 0x76, 0xa2, 0xaa, 0xd2, 0xfe, 0x9c, 0xed, 0x95, 0x5c, 0xdf, 0xae, 0xe2, 0x71,
	0x98, 0x8c, 0xa7, 0xe7, 0xf3, 0x31, 0x63, 0xe8, 0x10, 0x7b, 0xf6, 0xea, 0x3d, 0xcb, 0x8a, 0xee,
	0xa3, 0x6e, 0x26, 0x02, 0x63, 0x51, 0x77, 0x23, 0x99, 0xe9, 0xf6, 0xbf, 0xb5, 0x0b, 0x8c, 0x65,
	0x1e, 0xf2, 0x78, 0xda, 0xdf, 0x4d, 0x95, 0x98, 0x48, 0x71, 0x71, 0x56, 0x38, 0xe7, 0xb0, 0x20,
	0xa3, 0x56, 0x33, 0x20, 0xa6, 0x95, 0xc2, 0xfe, 0x50, 0x23, 0x53, 0x6c, 0x97, 0xf8, 0x21, 0xab,
	0xf6, 0x72, 0xad, 0xed, 0x28, 0xe0, 0xee, 0x55, 0x3f, 0xb9, 0x09, 0x53, 0xc1, 0x91, 0xba, 0xb6,
	0x1a, 0x74, 0xc6, 0x1e, 0xab, 0x69, 0x71, 0xa9, 0xbb, 0x64, 0xd5, 0xac, 0xd1, 0x40, 0x50, 0x9a,
	0xaa, 0xa4, 0x57, 0x08, 0x67, 0x28, 0x0a, 0x45, 0x76, 0xd2, 0xb1, 0x47, 0xf4, 0xaf, 0x57, 0xd0,
	0x8b, 0x4c, 0x85, 0xbe, 0x56, 0x69, 0xd4, 0x59, 0x05, 0x3f, 0x5b, 0x71, 0xf2, 0x92, 0xcb, 0xd8,
	0xa8, 0xa6, 0xc2, 0xdb, 0x0e, 0xc0, 0xd1, 0x70, 0xec, 0x80, 0x87, 0x4b, 0xa6, 0x36, 0xca, 0x8e,
	0x49, 0x12, 0x4d, 0x04, 0x9e, 0xe6, 0x7a, 0xb9, 0xf0, 0x54, 0x18, 0x03, 0x01, 0xad, 0xa7, 0x87,
	0x6c, 0x0b, 0x0b, 0x8d, 0xf5, 0x74, 0xad, 0xcf, 0x6d, 0x99, 0x87, 0xc1, 0xa4, 0x10, 0x62, 0x78,
	0x9e, 0xa8, 0xb1, 0xd5, 0x49, 0x55, 0x27, 0x7b, 0x03, 0x7d, 0xee, 0x58, 0xa8, 0x06, 0xa5, 0x86,
	0x8c, 0x6c, 0xe9, 0xa9, 0x4a, 0x7a, 0x9e, 0x16, 0x69, 0xb0, 0xcd, 0x50, 0x8a, 0x10, 0x59, 0x70,
	0x8b, 0xe0, 0x02, 0x23, 0x90, 0x4e, 0x79, 0x9e, 0x89, 0xc7, 0x8a, 0x8f, 0x85, 0xd5, 0x23, 0x6d,
	0x56, 0xed, 0x99, 0x66, 0x32, 0x1e, 0x1c, 0x26, 0x97, 0xa0, 0x4b, 0x7c, 0xfe, 0x36, 0xca, 0xba,
	0x79, 0x97, 0xad, 0x0d, 0xa5, 0x36, 0x7e, 0x42, 0x63, 0x8e, 0x99, 0x75, 0x97, 0xad, 0xe9, 0x24,
	0x35, 0xb5, 0xcd, 0x39, 0xb5, 0xbe, 0x69, 0xba, 0x4b, 0xfb, 0x6c, 0xcd, 0xa2, 0x3d, 0x10, 0x72,
	0xbf, 0xe6, 0x59, 0xe1, 0x69, 0xc4, 0x03, 0x31, 0x2d, 0x13, 0xb3, 0x40, 0xc4, 0xc2, 0xb1, 0x58,
	0x71, 0xac, 0x70, 0x8e, 0xed, 0x7f, 0xbe, 0x84, 0x42, 0x55, 0x25, 0xc6, 0x97, 0x53, 0x82, 0xeb,
	0x72, 0x07, 0x6f, 0xb3, 0xf5, 0x21, 0xd7, 0xd7, 0x3a, 0x70, 0x6d, 0xb6, 0x61, 0xb8, 0x76, 0xc6,
	0xaf, 0x07, 0xd8, 0xc3, 0xb6, 0x79, 0x97, 0xb1, 0x0b, 0xc1, 0x53, 0x6b, 0x40, 0xac, 0x2e, 0xee,
	0xe9, 0x42, 0xc6, 0x68, 0xd5, 0x55, 0x16, 0x20, 0x04, 0x3f, 0x41, 0x9b, 0xd3, 0xb2, 0xc1, 0x9b,
	0xe5, 0xe6, 0x2f, 0x10, 0x7d, 0x00, 0xba, 0x7d, 0xc3, 0x5d, 0xff, 0xb6, 0x15, 0x14, 0x05, 0x7c,
	0xb7, 0xd0, 0x84, 0xac, 0xb3, 0x4a, 0xe0, 0x49, 0x40, 0x43, 0x02, 0x32, 0x96, 0x60, 0xdc, 0x3b,
	0x7f, 0x70, 0xcc, 0x2f, 0xa1, 0xa0, 0x42, 0x3c, 0x24, 0xb3, 0x33, 0x91, 0x09, 0xed, 0x79, 0x2c,
	0xdb, 0x6c, 0x7d, 0x60, 0x0b, 0x80, 0xd3, 0xda, 0xaf, 0xac, 0x14, 0x14, 0xda, 0x5a, 0xe9, 0x5d,
	0x58, 0xd3, 0xf4, 0xe2, 0x90, 0x5b, 0x0a, 0x11, 0xba, 0x4c, 0xdc, 0x62, 0x4d, 0xfc, 0xa2, 0x06,
	0x01, 0xbb, 0x43, 0xf4, 0xd5, 0xe3, 0x44, 0xf3, 0x5e, 0x24, 0x9c, 0xe9, 0x88, 0x9d, 0xdd, 0x60,
	0x5b, 0x29, 0x37, 0xfc, 0xa2, 0x85, 0x42, 0x59, 0xb6, 0x4c, 0xde, 0x9c, 0x27, 0x4d, 0xda, 0x7f,
	0x67, 0x89, 0x6d, 0x10, 0x52, 0xf6, 0x3a, 0x52, 0xa8, 0xce, 0x2a, 0x0a, 0x7e, 0xae, 0x92, 0xf1,
	0xcd, 0xf5, 0xc8, 0x6e, 0x0a, 0x63, 0xcb, 0xc3, 0xd4, 0xee, 0x05, 0x40, 0x7f, 0x7d, 0x2b, 0x71,
	0x6a, 0x6c, 0x35, 0x50, 0x92, 0xa0, 0xbd, 0x3a, 0xab, 0xf4, 0xa2, 0x24, 0x18, 0x59, 0xf7, 0xcc,
	0xb8, 0x99, 0x20, 0x9a, 0x11, 0xc1, 0xfb, 0x18, 0xb9, 0x0b, 0x61, 0x4d, 0xcd, 0xb3, 0xb2, 0x8f,
	0xbb, 0xcb, 0xaa, 0x59, 0xde, 0x7b, 0xc9, 0xb3, 0x51, 0xb1, 0x53, 0xed, 0x1e, 0x82, 0x7e, 0x88,
	0x39, 0xc5, 0x69, 0x60, 0xc6, 0x53, 0x3c, 0x1e, 0xd9, 0x6f, 0x08, 0xb1, 0x74, 0x9e, 0xa9, 0x16,
	0xe3, 0xd4, 0x1e, 0x75, 0x15, 0x5d, 0x79, 0xe7, 0x2a, 0x44, 0x9e, 0x4b, 0x6a, 0x96, 0x20, 0xfb,
	0xb8, 0x1e, 0xe3, 0xfd, 0xc2, 0x7e, 0x05, 0x73, 0x68, 0xe9, 0x5a, 0x53, 0x7f, 0x06, 0x58, 0x20,
	0x9d, 0x51, 0x21, 0xc4, 0xc8, 0x68, 0x5b, 0xd4, 0xad, 0x76, 0xef, 0xc8, 0x79, 0x76, 0x4a, 0x7e,
	0xa0, 0x92, 0x3c, 0x05, 0xb1, 0xee, 0x4c, 0x16, 0xcf, 0x0c, 0xdd, 0xa4, 0x9d, 0xc1, 0x32, 0xdf,
	0xbf, 0xdd, 0x63, 0x35, 0x25, 0x22, 0xc1, 0x33, 0x01, 0x06, 0x3a, 0x38, 0xb7, 0x30, 0xa6, 0x2d,
	0x35, 0x42, 0xb0, 0x46, 0x9f, 0xfb, 0xa6, 0x75, 0x7d, 0x81, 0x69, 0xbd, 0xe5, 0xbb, 0x1c, 0xd6,
	0x34, 0xde, 0x06, 0x4b, 0x60, 0x97, 0x55, 0xad, 0x23, 0x00, 0x0d, 0x77, 0xc8, 0x0d, 0x48, 0x85,
	0x42, 0x2f, 0xbd, 0x41, 0xbc, 0xd5, 0x97, 0x97, 0x58, 0xd2, 0x24, 0x82, 0xed, 0x95, 0xed, 0xde,
	0x5d, 0xfa, 0xb6, 0x47, 0x46, 0xef, 0x1e, 0x9c, 0xf3, 0x39, 0x32, 0xf4, 0x90, 0xc7, 0x83, 0x3c,
	0x9d, 0x66, 0x22, 0xb3, 0x7e, 0x39, 0x16, 0xaf, 0xd2, 0x48, 0x8e, 0xa5, 0x2e, 0x2c, 0xcb, 0x3c,
	0x96, 0xc8, 0x92, 0x0e, 0x8a, 0x30, 0x25, 0x8f, 0x2e, 0x53, 0x3c, 0x91, 0xf6, 0x4f, 0xd9, 0xcd,
	0x69, 0xc4, 0xe6, 0xcd, 0xc9, 0xa0, 0x9f, 0xa2, 0xa8, 0xf7, 0x44, 0xe7, 0x1b, 0x74, 0x65, 0x2d,
	0xd6, 0x9d, 0xe5, 0x52, 0xff, 0xff, 0xc0, 0xba, 0xff, 0xd5, 0x2a, 0x52, 0xbc, 0x92, 0xd9, 0xe8,
	0x75, 0x24, 0xc4, 0x0e, 0xdb, 0xb8, 0xe0, 0x13, 0xe1, 0xd4, 0x0e, 0xd0, 0xb3, 0x71, 0x03, 0xe6,
	0xa2, 0x0a, 0x00, 0xf3, 0x25, 0x17, 0x30, 0x8d, 0x75, 0xa2, 0x87, 0x0b, 0x19, 0x1b, 0x33, 0xe4,
	0x1c, 0x5d, 0x8e, 0x02, 0xdf, 0x89, 0x92, 0x4c, 0xf8, 0x15, 0x9b, 0x64, 0xf7, 0x24, 0xa9, 0x88,
	0x51, 0x65, 0x13, 0xae, 0x53, 0x35, 0x45, 0x1d, 0x0b, 0x53, 0x56, 0xbd, 0x20, 0x8d, 0x29, 0xef,
	0x86, 0x79, 0x4a, 0x1a, 0x70, 0x97, 0x55, 0x61, 0x38, 0xeb, 0x25, 0xd6, 0x88, 0xc0, 0x2f, 0x64,
	0x7c, 0x60, 0xe1, 0x8e, 0x3a, 0xd9, 0x34, 0x38, 0x7e, 0x1c, 0xc2, 0x6c, 0xb7, 0x68, 0x70, 0x20,
	0x38, 0xc7, 0x09, 0xb0, 0x8f, 0x63, 0x30, 0xd2, 0x77, 0x9c, 0xc8, 0x32, 0x1e, 0xdf, 0x79, 0xa0,
	0x84, 0x88, 0x0b, 0x36, 0x08, 0x55, 0x92, 0x9e, 0xf1, 0x78, 0xd0, 0x6a, 0x52, 0xf7, 0xe3, 0x24,
	0xce, 0xb4, 0x50, 0x87, 0xc9, 0xe5, 0x49, 0xc7, 0xda, 0x1e, 0x0d, 0xb6, 0x69, 0xb6, 0x0e, 0x8b,
	0xf6, 0x68, 0x7f, 0xcc, 0x8e, 0x79, 0xd0, 0x3e, 0xfa, 0xbb, 0xdf, 0x65, 0xf5, 0x81, 0xd0, 0x5e,
	0xf1, 0x8d, 0x05, 0x3a, 0x9f, 0xc4, 0xcb, 0x4d, 0x38, 0xae, 0x0f, 0xac, 0xb7, 0xd1, 0x51, 0x49,
	0xea, 0x90, 0xe3, 0xd6, 0x82, 0x4f, 0xf7, 0x58, 0x2d, 0xcb, 0x07, 0x03, 0x91, 0xe9, 0xc7, 0x60,
	0x10, 0xdd, 0x22, 0x79, 0xd2, 0x37, 0x3f, 0x51, 0xf2, 0x80, 0x13, 0xdc, 0xfe, 0x31, 0xbb, 0x5d,
	0x76, 0x04, 0x81, 0x93, 0x16, 0x84, 0x35, 0xca, 0x88, 0xf0, 0x02, 0xab, 0x87, 0x6c, 0x85, 0x5e,
	0xc4, 0x83, 0x37, 0xed, 0x54, 0xfc, 0x04, 0x95, 0x4e, 0xd1, 0xf5, 0x1b, 0x64, 0xd3, 0xdf, 0x5d,
	0xc2, 0xce, 0xc1, 0x2a, 0xec, 0xf6, 0xb9, 0x04, 0xa8, 0xe8, 0xc4, 0x0b, 0x19, 0x64, 0x2a, 0x38,
	0x07, 0x93, 0x91, 0xb8, 0xd5, 0xc8, 0x77, 0x75, 0x45, 0x65, 0x2b, 0xe4, 0xdc, 0x28, 0xa1, 0x73,
	0x15, 0x53, 0xf1, 0xaa, 0x8d, 0x08, 0x35, 0xb0, 0xf8, 0x30, 0x51, 0xf1, 0x69, 0x92, 0x79, 0x96,
	0x5c, 0x19, 0xac, 0xfa, 0x77, 0x4b, 0x18, 0x45, 0xe8, 0x71, 0x3d, 0xec, 0xc2, 0x71, 0x75, 0x33,
	0x2d, 0x52, 0x43, 0x0d, 0xe6, 0xdf, 0x62, 0xa9, 0x01, 0x4a, 0x75, 0x9c, 0xc9, 0x47, 0xac, 0x1e,
	0x8b, 0x4b, 0x7d, 0xae, 0x45, 0x5a, 0xf8, 0x88, 0xe4, 0x18, 0x41, 0x57, 0xd2, 0xf8, 0xce, 0x3c,
	0xd0, 0x5d, 0x9d, 0x24, 0x51, 0xf3, 0x47, 0x6c, 0x37, 0x16, 0x17, 0x27, 0xb6, 0xec, 0x65, 0x92,
	0x44, 0x9e, 0xf9, 0xb9, 0xf0, 0xab, 0x7d, 0x56, 0x97, 0xd9, 0x67, 0x5c, 0x0b, 0x95, 0xa5, 0x11,
	0xcf, 0x86, 0x85, 0x23, 0xdc, 0x53, 0x09, 0x0f, 0x03, 0x9e, 0x01, 0x7f, 0x99, 0x59, 0x58, 0x75,
	0xfc, 0x23, 0xc4, 0x19, 0xa0, 0x2f, 0xd3, 0x45, 0xd7, 0x88, 0x94, 0x29, 0x4b, 0xc8, 0x08, 0xff,
	0xcc, 0xba, 0xb6, 0x08, 0x4f, 0xfc, 0xcf, 0x65, 0xfc, 0x0c, 0x2d, 0x05, 0x63, 0x06, 0x44, 0xd3,
	0xd6, 0xb7, 0x35, 0x68, 0x96, 0x7d, 0x23, 0x66, 0xc5, 0xb3, 0x6e, 0x56, 0x4b, 0x06, 0x4d, 0xa5,
	0x6c, 0xd0, 0xac, 0x95, 0x0d, 0x9a, 0x75, 0xd7, 0x63, 0x40, 0xb6, 0xcf, 0x16, 0x5b, 0x33, 0xf2,
	0xfa, 0xa4, 0x63, 0x65, 0xd7, 0x16, 0x5b, 0x33, 0x16, 0xd8, 0x49, 0xc7, 0x0a, 0x2e, 0x23, 0x3c,
	0xc1, 0x6a, 0x77, 0xca, 0xba, 0xce, 0x2a, 0x43, 0x6e, 0x3e, 0xa8, 0x39, 0x67, 0x44, 0xc6, 0x83,
	0x93, 0x8e, 0x45, 0x95, 0x4b, 0x48, 0x05, 0x6a, 0xe7, 0x59, 0x9f, 0x7c, 0x1b, 0xca, 0x6f, 0xb3,
	0x66, 0x66, 0x7d, 0xaf, 0xb4, 0xa8, 0xdb, 0x21, 0x98, 0xc8, 0xcc, 0xeb, 0xdc, 0x82, 0x03, 0x0d,
	0x27, 0x69, 0xa8, 0x10, 0xa5, 0x6b, 0xd3, 0x62, 0xa2, 0x4d, 0x57, 0xee, 0x3a, 0xb3, 0x02, 0xcb,
	0xb0, 0x03, 0x31, 0x32, 0x6a, 0xed, 0x0b, 0xef, 0xa8, 0x90, 0xee, 0x44, 0x3c, 0x63, 0x42, 0x95,
	0x88, 0xee, 0x63, 0xb6, 0x23, 0xe2, 0xf0, 0x88, 0x82, 0xc5, 0x9e, 0x9b, 0xb3, 0x90, 0x82, 0x9a,
	0x25, 0x09, 0x02, 0x6a, 0xa7, 0x1d, 0x5b, 0xf0, 0xca, 0xb4, 0xce, 0x34, 0xd7, 0x79, 0x19, 0x88,
	0x22, 0x62, 0x71, 0x40, 0x88, 0xf9, 0x75, 0x66, 0x54, 0x64, 0x61, 0x2a, 0x58, 0xd0, 0xab, 0x30,
	0x76, 0xc5, 0x65, 0x5a, 0x04, 0x2c, 0xfa, 0x79, 0x14, 0xc5, 0x22, 0xcb, 0x2c, 0x4d, 0x3e, 0xc1,
	0x85, 0x66, 0x3a, 0x89, 0x45, 0x57, 0x5c, 0x06, 0xc6, 0x4e, 0x11, 0x33, 0x31, 0xff, 0x36, 0xdb,
	0xa0, 0x20, 0xdd, 0x42, 0x0c, 0xfc, 0x7c, 0x0a, 0x03, 0x37, 0xc6, 0x6c, 0x69, 0xee, 0x9f, 0xb0,
	0x46, 0x28, 0x0d, 0xaf, 0x5c, 0x01, 0x1e, 0x51, 0xd8, 0xf9, 0xb4, 0x45, 0xa5, 0x4f, 0xa1, 0x4d,
	0xfb, 0x2b, 0xc4, 0xe6, 0xfb, 0x4a, 0x8a, 0x38, 0xb4, 0x8e, 0x48, 0x95, 0xad, 0x44, 0x93, 0xa8,
	0xb0, 0x17, 0x86, 0x69, 0x41, 0xf9, 0x86, 0x0d, 0x56, 0x7c, 0x36, 0x78, 0x6d, 0xd2, 0x6f, 0xbf,
	0xc4, 0x1d, 0x71, 0x93, 0x99, 0xeb, 0xfd, 0xfc, 0x80, 0x55, 0xf1, 0xe8, 0xfc, 0x55, 0xdc, 0x2e,
	0xaf, 0xc2, 0x57, 0x1e, 0xed, 0xff, 0xb5, 0x84, 0xdb, 0x53, 0xe8, 0x96, 0x30, 0x4f, 0x67, 0x8e,
	0xb6, 0x20, 0xa7, 0xfb, 0xc6, 0x79, 0x4b, 0x01, 0x0d, 0x5c, 0x99, 0x87, 0x06, 0xbe, 0xc7, 0xea,
	0x46, 0xc7, 0x3e, 0x32, 0x04, 0xe5, 0x49, 0xab, 0x6d, 0xa4, 0xb5, 0x24, 0xcb, 0xba, 0x80, 0x0f,
	0x36, 0x1f, 0x7a, 0xed, 0xce, 0x30, 0x72, 0x56, 0x40, 0xc7, 0x56, 0xcc, 0x22, 0xfe, 0x00, 0xee,
	0x62, 0xea, 0xe0, 0x30, 0xb0, 0x89, 0x42, 0xae, 0xf9, 0x63, 0x19, 0x09, 0x6b, 0xd5, 0xbf, 0xcd,
	0xaa, 0x3d, 0x4f, 0x62, 0x6f, 0xcc, 0x4a, 0x6c, 0xb0, 0x23, 0xf2, 0x4c, 0x06, 0x88, 0x49, 0xce,
	0x6c, 0x66, 0x16, 0x24, 0x4a, 0xc0, 0x8e, 0x9b, 0xff, 0xbc, 0xc6, 0x66, 0x42, 0x7b, 0xda, 0xcc,
	0x2f, 0x4a, 0xe1, 0xff, 0x37, 0xaa, 0x54, 0x7f, 0xcf, 0x2a, 0x3e, 0x00, 0x3a, 0xe6, 0xd0, 0x9b,
	0x65, 0x27, 0xa7, 0xf2, 0x50, 0x38, 0x41, 0x0e, 0xc8, 0x02, 0x06, 0x44, 0x0a, 0xad, 0xf8, 0x14,
	0xfa, 0xff, 0xe8, 0x6d, 0x5a, 0xc5, 0x5f, 0x2c, 0xff, 0x0d, 0x2a, 0xfe, 0x33, 0x9b, 0x2d, 0x30,
	0xe1, 0x9a, 0x2b, 0xb2, 0xa0, 0x8c, 0x02, 0x18, 0x26, 0xa9, 0xcb, 0x24, 0xda, 0x61, 0x1b, 0x20,
	0xc9, 0x26, 0x3c, 0xb2, 0x83, 0x98, 0xe9, 0x27, 0x19, 0xed, 0x81, 0x39, 0x06, 0x70, 0x68, 0xd0,
	0x5b, 0xf9, 0x8f, 0x4b, 0x36, 0xa7, 0x48, 0x10, 0x96, 0x30, 0x05, 0x43, 0xe3, 0x99, 0x2d, 0xfb,
	0x1b, 0x5c, 0x4c, 0x57, 0x49, 0x7d, 0xaa, 0x92, 0xde, 0x3c, 0xdf, 0xdd, 0xee, 0xe0, 0x9a, 0xb7,
	0xcf, 0xaf, 0xbd, 0x9b, 0xa4, 0xea, 0xaa, 0x34, 0x20, 0xd7, 0xa3, 0xa7, 0x30, 0xf9, 0x9a, 0x33,
	0x7a, 0x45, 0x1f, 0x4b, 0xea, 0x74, 0xc2, 0xc3, 0x14, 0x0b, 0xc0, 0x9c, 0x6e, 0xff, 0x37, 0xcb,
	0xdb, 0xfd, 0x3c, 0x46, 0x4a, 0x32, 0xe6, 0xfa, 0xf4, 0x1a, 0xd1, 0xc9, 0x99, 0x8b, 0xae, 0x15,
	0x5b, 0xe0, 0xd6, 0x38, 0x91, 0x9e, 0xc8, 0xd6, 0x84, 0x1c, 0x20, 0x62, 0xfb, 0x7d, 0xb6, 0x61,
	0xdc, 0x1b, 0x2f, 0x11, 0xe1, 0x0e, 0x02, 0x69, 0x76, 0x78, 0x70, 0x16, 0x4c, 0x0b, 0x84, 0x7d,
	0xc9, 0x72, 0x2e, 0xbc, 0x70, 0x99, 0x9e, 0xca, 0xc0, 0xc1, 0xa5, 0xe0, 0xac, 0x6b, 0x99, 0xbe,
	0x14, 0x97, 0xda, 0xaa, 0x74, 0x0c, 0xbd, 0x62, 0x91, 0xf3, 0x45, 0x6a, 0xed, 0x5f, 0x46, 0x64,
	0x68, 0xcc, 0x65, 0x0c, 0x20, 0x47, 0x77, 0x9c, 0x84, 0xd3, 0x49, 0x37, 0x4d, 0xc6, 0xb0, 0xb4,
	0x08, 0x95, 0xb4, 0x5f, 0xe1, 0xf6, 0x0c, 0x93, 0x3c, 0x13, 0x46, 0xd3, 0x28, 0x3e, 0x98, 0xc9,
	0xd4, 0x19, 0xf3, 0x4b, 0xcf, 0xe8, 0x31, 0x0a, 0xc7, 0xd0, 0x13, 0x28, 0x9c, 0x95, 0x05, 0x0a,
	0x27, 0x28, 0xe2, 0x3c, 0x3d, 0xa9, 0x83, 0x44, 0xc6, 0xd3, 0x90, 0x64, 0x2f, 0xbf, 0xba, 0x4e,
	0x65, 0x99, 0x26, 0x30, 0xca, 0x35, 0x83, 0xfc, 0x96, 0x8d, 0x96, 0x5e, 0x24, 0x53, 0x10, 0x0a,
	0xe2, 0x6d, 0x4f, 0x3d, 0xca, 0xf5, 0x41, 0x58, 0x17, 0x95, 0xe8, 0xf1, 0x4c, 0x1c, 0xf2, 0x81,
	0xc3, 0x9e, 0x76, 0xd8, 0xc6, 0x20, 0x09, 0xb1, 0x04, 0x39, 0xee, 0x29, 0x22, 0x95, 0xc8, 0xcd,
	0x43, 0x69, 0xf6, 0xe7, 0x0a, 0x95, 0x67, 0x19, 0x11, 0xfa, 0x76, 0xfe, 0xc6, 0xff, 0x58, 0x46,
	0x07, 0xd8, 0xc8, 0xe9, 0xeb, 0x21, 0xde, 0x1a, 0x5b, 0x1d, 0x24, 0x51, 0xb8, 0x48, 0x6c, 0x79,
	0x61, 0xb2, 0x4a, 0x99, 0x4f, 0xd7, 0xe6, 0xc8, 0xbe, 0x75, 0x9f, 0x70, 0x37, 0xe8, 0x08, 0x25,
	0xb9, 0x66, 0x9b, 0xdf, 0x02, 0x13, 0x66, 0x0b, 0x30, 0xe1, 0x36, 0xdb, 0x30, 0x86, 0x9b, 0xe7,
	0x13, 0x63, 0x1b, 0x80, 0x10, 0xbc, 0x83, 0xe4, 0xca, 0xf9, 0xc2, 0x0b, 0xbc, 0x40, 0xb2, 0xbe,
	0x3c, 0xff, 0xf8, 0x06, 0xdb, 0x8a, 0x04, 0x57, 0xf1, 0xf9, 0xac, 0x39, 0x1a, 0x2a, 0x91, 0x65,
	0x45, 0xf9, 0x36, 0x61, 0xfe, 0xa9, 0xd0, 0x56, 0xa1, 0x80, 0x15, 0xda, 0xfe, 0xd0, 0x22, 0x1a,
	0x72, 0x10, 0x77, 0x0d, 0x35, 0x15, 0xc0, 0xec, 0x52, 0x49, 0x34, 0x22, 0x2f, 0xfc, 0x33, 0x1b,
	0x91, 0x23, 0xc5, 0xf6, 0x5a, 0x30, 0x7c, 0x81, 0x5a, 0xac, 0x96, 0x12, 0x56, 0x2a, 0xd4, 0xb8,
	0x97, 0x40, 0x76, 0x90, 0x43, 0xe4, 0x86, 0x32, 0x24, 0x84, 0xe2, 0x3d, 0x56, 0x33, 0xd3, 0x38,
	0xca, 0x95, 0x12, 0x71, 0x70, 0x05, 0x87, 0x34, 0x6f, 0x9f, 0xa6, 0x14, 0xf8, 0xbf, 0x59, 0x42,
	0xa6, 0x2f, 0xec, 0x96, 0x39, 0x99, 0xa5, 0x9f, 0xb0, 0xdd, 0x4c, 0xc6, 0x83, 0x48, 0x74, 0xf8,
	0xd5, 0x4c, 0x9e, 0xdf, 0x7e, 0x31, 0x84, 0xd1, 0xb0, 0x34, 0xce, 0x27, 0x6c, 0x37, 0x4c, 0xf2,
	0xde, 0xf4, 0x37, 0x2b, 0xd7, 0x7d, 0xd3, 0x62, 0x3b, 0x6e, 0x1c, 0x0a, 0xe9, 0xad, 0x12, 0xee,
	0xec, 0x7a, 0x2b, 0x82, 0x7d, 0xe6, 0x78, 0x1e, 0xe1, 0xfc, 0x41, 0x1e, 0xa2, 0x25, 0xaf, 0x44,
	0x36, 0x15, 0xc4, 0xf2, 0xe4, 0xc0, 0x22, 0xeb, 0xf6, 0xe7, 0xcb, 0xa8, 0x74, 0x05, 0xcf, 0xb4,
	0x50, 0x5d, 0x31, 0x18, 0x5c, 0x7f, 0x72, 0x75, 0x56, 0x89, 0x53, 0x02, 0x54, 0x81, 0x9e, 0x8c,
	0x01, 0xfd, 0x32, 0xc9, 0x83, 0x21, 0xca, 0xb9, 0x55, 0x87, 0x60, 0x42, 0x46, 0x13, 0x16, 0x3a,
	0x9c, 0x3e, 0x55, 0x49, 0x8f, 0xf7, 0xa4, 0x8d, 0xd3, 0xcd, 0xb2, 0xff, 0xa2, 0x04, 0xb4, 0xc2,
	0x2b, 0xd9, 0xa0, 0xae, 0x42, 0x7e, 0xe5, 0x12, 0x88, 0x36, 0x29, 0x81, 0x08, 0xd0, 0x13, 0x6f,
	0xdb, 0xd9, 0x82, 0xfe, 0xf6, 0x59, 0x5d, 0x9b, 0x39, 0x1f, 0xc4, 0x12, 0x52, 0x45, 0x41, 0x4d,
	0xa2, 0x16, 0x31, 0xc5, 0x7e, 0xaa, 0xc5, 0x4d, 0xb6, 0x9d, 0xe5, 0x41, 0x20, 0xb2, 0xcc, 0x35,
	0xae, 0x53, 0x94, 0xde, 0x56, 0xf8, 0xa1, 0xb2, 0x26, 0x63, 0x83, 0x28, 0xe9, 0xf1, 0x08, 0x14,
	0x05, 0x80, 0x50, 0xed, 0x3f, 0xb1, 0xc6, 0x17, 0xa5, 0xe2, 0x8c, 0xc4, 0x74, 0x14, 0xbe, 0xc0,
	0xcc, 0x96, 0xcb, 0x42, 0x69, 0x41, 0xce, 0x56, 0x8d, 0xad, 0x66, 0xd2, 0x05, 0x40, 0xde, 0x67,
	0xdb, 0x01, 0xcf, 0xc4, 0x8b, 0x58, 0x38, 0xd0, 0x68, 0x6d, 0xc1, 0xc2, 0x6d, 0xd3, 0x97, 0x17,
	0x89, 0x6b, 0xba, 0x68, 0xcf, 0x9b, 0x8c, 0xc1, 0x84, 0x4f, 0xc2, 0x17, 0x31, 0xed, 0x7b, 0x51,
	0xf6, 0xf2, 0x22, 0xb1, 0xdb, 0x5e, 0x63, 0xab, 0xa9, 0x4a, 0x52, 0x6b, 0xc4, 0xfd, 0xcb, 0x65,
	0xcf, 0xd0, 0xfc, 0xe6, 0x64, 0x9c, 0x29, 0xbc, 0x72, 0xd6, 0x5d, 0x76, 0x7c, 0x90, 0xa5, 0x22,
	0x90, 0xdc, 0xab, 0xa9, 0x10, 0x9e, 0xe9, 0x21, 0x98, 0x33, 0x68, 0x7d, 0xb1, 0xb1, 0x1b, 0x94,
	0xb4, 0x0b, 0x82, 0xf1, 0xe4, 0x9b, 0x44, 0x38, 0x64, 0xd9, 0x6a, 0xe1, 0x25, 0xe7, 0x18, 0x19,
	0xa9, 0x92, 0xbe, 0xf4, 0x42, 0xab, 0xef, 0x33, 0x96, 0x17, 0x40, 0x5d, 0xed, 0x3a, 0x1e, 0xf7,
	0xb1, 0xd5, 0xfa, 0xf4, 0xa1, 0xa2, 0xbd, 0x75, 0xc1, 0xee, 0xcd, 0x26, 0x91, 0x77, 0x07, 0x8a,
	0xf0, 0xc5, 0xd2, 0x46, 0xbe, 0xcb, 0x98, 0xd1, 0xc1, 0x67, 0xd7, 0x26, 0x70, 0x4d, 0x71, 0xd7,
	0xa2, 0xb4, 0xe3, 0xbf, 0x61, 0x0d, 0x59, 0xa4, 0xcf, 0xbe, 0xbc, 0x9c, 0x4d, 0x67, 0xdd, 0x67,
	0xf5, 0xbe, 0xbc, 0x7c, 0x6e, 0x9d, 0x65, 0x07, 0x8e, 0x61, 0x16, 0x94, 0xba, 0x32, 0x15, 0xcf,
	0x9d, 0x35, 0xbe, 0xcf, 0xea, 0xae, 0x14, 0x98, 0x16, 0x89, 0xf6, 0x3b, 0xac, 0xda, 0xe7, 0x99,
	0x7e, 0x2c, 0x2f, 0x8f, 0x92, 0x4c, 0x2f, 0xcc, 0xb0, 0xd5, 0xe8, 0x5b, 0x59, 0x9c, 0x3e, 0xe5,
	0xc1, 0x68, 0xda, 0xae, 0xfa, 0x9e, 0x39, 0x44, 0xe3, 0x84, 0x5a, 0x17, 0xc7, 0x2e, 0x1f, 0x33,
	0x9e, 0xcb, 0xde, 0x8f, 0xd1, 0x0f, 0xb6, 0x0b, 0xf4, 0xc2, 0x16, 0xed, 0xc1, 0x1f, 0xd9, 0x3d,
	0x80, 0x64, 0xb4, 0x34, 0x51, 0xd7, 0xa7, 0x03, 0xd8, 0xac, 0xd3, 0x95, 0x39, 0x31, 0x6b, 0x2f,
	0x5d, 0x75, 0xd5, 0x4f, 0x57, 0xad, 0x50, 0xe2, 0x80, 0xcc, 0x1e, 0x47, 0x32, 0xfd, 0xbc, 0x88,
	0x53, 0x62, 0xc1, 0x17, 0x56, 0xa1, 0x6d, 0xb1, 0x35, 0x95, 0x68, 0xae, 0x3d, 0x96, 0xd3, 0x45,
	0x38, 0x66, 0x93, 0x48, 0x31, 0x8f, 0x8d, 0xe9, 0x7f, 0xe6, 0x82, 0xff, 0xae, 0xe8, 0x34, 0xc9,
	0x90, 0x3a, 0xdb, 0x7f, 0xb8, 0xc4, 0x5a, 0xb3, 0x09, 0x40, 0x73, 0x98, 0x12, 0xe3, 0x4d, 0x1d,
	0xc8, 0xa3, 0x76, 0x79, 0x33, 0x46, 0xcd, 0xe6, 0x8a, 0x5c, 0x9f, 0xb7, 0xd8, 0x86, 0xf9, 0x05,
	0xae, 0xf6, 0xea, 0xbc, 0x30, 0xbf, 0x9f, 0xa3, 0x56, 0x99, 0xce, 0x29, 0x5b, 0x83, 0xa8, 0x14,
	0x24, 0x5f, 0x5b, 0x11, 0xea, 0x18, 0x14, 0x13, 0x5f, 0xcf, 0x5c, 0x06, 0xd0, 0x3e, 0xab, 0x67,
	0x22, 0xea, 0x3f, 0x72, 0xc5, 0xa8, 0xaf, 0x7f, 0xd3, 0xe2, 0xb6, 0x10, 0x9b, 0x1e, 0x26, 0x68,
	0x9d, 0x3b, 0x1c, 0xe7, 0x21, 0xdb, 0xc2, 0xc5, 0x7f, 0x63, 0xba, 0xf5, 0x0d, 0x6a, 0xe9, 0xb2,
	0xff, 0x57, 0xac, 0x7f, 0x88, 0x52, 0x0b, 0x89, 0xa7, 0x97, 0x5c, 0xbe, 0xb6, 0x51, 0x0c, 0x59,
	0x76, 0x86, 0xd5, 0xc8, 0x26, 0x6e, 0xff, 0xc3, 0x65, 0xb4, 0xe4, 0x83, 0x64, 0x3c, 0x4e, 0xe6,
	0x47, 0x9c, 0xa6, 0xa3, 0x95, 0x9a, 0x47, 0x23, 0x3f, 0xc9, 0xa4, 0x4c, 0x49, 0xbe, 0x5d, 0x84,
	0xb7, 0x1a, 0x02, 0x1e, 0xd1, 0xee, 0x2e, 0x4e, 0x84, 0x76, 0x32, 0xd2, 0xc1, 0x9e, 0xa9, 0x50,
	0x32, 0x09, 0x8b, 0x60, 0xe5, 0x85, 0x10, 0xa3, 0x90, 0x5f, 0x79, 0xc2, 0x0e, 0x53, 0xd5, 0x5c,
	0x08, 0xb2, 0x4a, 0xf9, 0x72, 0x2e, 0xbe, 0xe2, 0x05, 0x68, 0x40, 0x30, 0xca, 0x40, 0x78, 0xf6,
	0xe7, 0x2e, 0xab, 0xe6, 0x69, 0xc8, 0xb5, 0xe8, 0x80, 0x70, 0xdf, 0xa2, 0xf5, 0x04, 0x22, 0x8a,
	0x8c, 0x9c, 0xd8, 0xb6, 0x9b, 0x5e, 0xdc, 0xc9, 0x31, 0x87, 0x74, 0xad, 0xbf, 0x6f, 0x54, 0x0f,
	0x10, 0x45, 0x39, 0x35, 0xad, 0xc8, 0x7a, 0x45, 0xa0, 0xf1, 0xaf, 0xa3, 0x53, 0x86, 0x42, 0x34,
	0xcb, 0x7b, 0x33, 0x51, 0x6b, 0xa7, 0x71, 0x96, 0x89, 0xde, 0xdc, 0x4d, 0x18, 0xaf, 0xe7, 0xd9,
	0x0b, 0x32, 0xab, 0x53, 0xf7, 0x75, 0x2a, 0x2e, 0x35, 0xd3, 0x4a, 0x6a, 0x8b, 0x3c, 0xfe, 0xfb,
	0x55, 0x3c, 0x75, 0xb2, 0xca, 0x8d, 0x10, 0x5a, 0x0c, 0x75, 0x4e, 0x5b, 0xc2, 0xdb, 0x6c, 0xdd,
	0xfc, 0x3e, 0xb0, 0x6c, 0x06, 0x1e, 0x2b, 0x12, 0x2c, 0xee, 0x64, 0xa5, 0x94, 0x2c, 0xdc, 0x29,
	0xd2, 0xb3, 0x65, 0x2c, 0xb5, 0xe4, 0x3a, 0x51, 0x47, 0xe7, 0x87, 0x96, 0xbb, 0x6e, 0xb2, 0x6d,
	0x57, 0x7a, 0x80, 0x82, 0x12, 0x79, 0xac, 0xc5, 0x76, 0xa6, 0x2a, 0x3e, 0xb1, 0xb9, 0x76, 0xfe,
	0x27, 0xc8, 0x82, 0x56, 0xbc, 0xdc, 0x61, 0xbb, 0x53, 0x15, 0x8f, 0xb9, 0x8c, 0xac, 0xd9, 0x04,
	0xd7, 0x0a, 0x92, 0x14, 0xb6, 0xaf, 0x46, 0x13, 0x0a, 0x92, 0x38, 0xcb, 0xc7, 0x36, 0xb7, 0xb0,
	0x3e, 0x53, 0x6a, 0xc4, 0xc2, 0x16, 0xa5, 0xad, 0x51, 0xa9, 0x1d, 0x72, 0x9b, 0x56, 0x4e, 0xe5,
	0x66, 0x4d, 0x3b, 0xde, 0xc5, 0x25, 0x28, 0xb4, 0x4b, 0x6a, 0xd0, 0x14, 0x42, 0x11, 0x69, 0x8e,
	0x99, 0x44, 0x2b, 0x33, 0xf4, 0xe2, 0xb2, 0x87, 0x14, 0x0f, 0x65, 0x9e, 0xd9, 0xf0, 0x1d, 0x98,
	0x51, 0x5f, 0x0b, 0x1b, 0xb4, 0x2b, 0x8c, 0xcc, 0x1b, 0x44, 0x03, 0xd8, 0xc3, 0xb9, 0x88, 0xfa,
	0x2e, 0x3f, 0x15, 0x82, 0x9f, 0x58, 0xfe, 0x42, 0x0f, 0x2d, 0x4a, 0xd9, 0x22, 0x2b, 0x45, 0x7a,
	0xd1, 0x16, 0x2f, 0x2f, 0xf5, 0x06, 0xdb, 0x72, 0xdb, 0xf7, 0x0c, 0xdc, 0x90, 0xdb, 0xb4, 0x46,
	0x99, 0x41, 0xc1, 0xd3, 0x24, 0x49, 0x5b, 0x77, 0x48, 0x7d, 0xd2, 0x1a, 0xb1, 0xed, 0x5d, 0x10,
	0x81, 0x5f, 0xa1, 0x87, 0x35, 0x90, 0x7d, 0xdd, 0xed, 0xf1, 0xeb, 0x6f, 0x54, 0xec, 0xb2, 0x2a,
	0x8a, 0x32, 0x3f, 0x99, 0xf0, 0x97, 0x66, 0x70, 0xf9, 0xea, 0x27, 0x77, 0x0b, 0x41, 0x61, 0xb5,
	0x24, 0x48, 0x4b, 0xcc, 0xb1, 0x6a, 0x7f, 0x89, 0x0a, 0xa4, 0x94, 0xff, 0xfd, 0xe6, 0x30, 0xc9,
	0xcf, 0x10, 0x04, 0x07, 0x0c, 0xc2, 0x78, 0x2f, 0x79, 0xa4, 0x67, 0x2f, 0x3a, 0x59, 0x13, 0xcc,
	0x65, 0x0f, 0x42, 0xd2, 0xb5, 0x77, 0xdf, 0x05, 0x82, 0x0d, 0xe6, 0x53, 0x4f, 0x06, 0xfc, 0xfe,
	0x12, 0xf6, 0x1c, 0xa7, 0x81, 0x63, 0xc3, 0xc2, 0x73, 0x29, 0xb0, 0xbe, 0xec, 0x4c, 0xa4, 0x82,
	0xeb, 0x82, 0x15, 0xed, 0xf1, 0xaf, 0x90, 0xc0, 0x41, 0xf6, 0x75, 0x26, 0x8c, 0x13, 0xb2, 0x95,
	0x39, 0x42, 0xd6, 0xdd, 0xd0, 0x58, 0x2b, 0x14, 0x3d, 0x1e, 0x9f, 0xbb, 0x2c, 0x21, 0xb3, 0x83,
	0x3c, 0x94, 0x09, 0x52, 0xf9, 0x41, 0x14, 0x15, 0xce, 0xcc, 0x38, 0xd7, 0xe2, 0xd2, 0x26, 0x6d,
	0x83, 0x8a, 0x6f, 0x3f, 0xc5, 0xd3, 0x06, 0xc4, 0x20, 0x9a, 0xcc, 0x00, 0xf5, 0xce, 0x19, 0x5f,
	0x2e, 0x0b, 0x35, 0x27, 0x45, 0x8c, 0xc8, 0x78, 0x3a, 0xb1, 0xd0, 0x5b, 0xfb, 0xa9, 0x6f, 0xe0,
	0x4d, 0x13, 0xcf, 0x36, 0x5b, 0xcf, 0x2d, 0xf0, 0x47, 0x20, 0x3d, 0xa1, 0x9e, 0xf3, 0x6d, 0xa5,
	0xbf, 0xbd, 0x8a, 0xdd, 0x39, 0xc4, 0xec, 0x5a, 0x5a, 0x04, 0xf5, 0x20, 0x5e, 0x16, 0x9a, 0xcd,
	0xa6, 0xb5, 0x5e, 0xda, 0xa2, 0xd5, 0x42, 0xe0, 0x8e, 0xd3, 0x48, 0x68, 0x6a, 0x5a, 0x29, 0xaf,
	0x6c, 0xad, 0x94, 0xc1, 0xb3, 0x4e, 0x47, 0x44, 0x1f, 0x9d, 0xf4, 0x6d, 0xba, 0xbd, 0x91, 0x85,
	0xd9, 0x13, 0x9e, 0x9d, 0x9a, 0x31, 0xb3, 0x51, 0x91, 0x97, 0x10, 0xbb, 0x1d, 0x66, 0xc4, 0xee,
	0xfd, 0x3c, 0x0e, 0x5c, 0x70, 0xcf, 0x08, 0x07, 0x99, 0x8d, 0x20, 0xba, 0x47, 0x2a, 0x10, 0xe2,
	0x33, 0xc8, 0x43, 0x2e, 0xc4, 0x67, 0x4c, 0x10, 0x2c, 0xda, 0x2a, 0xfb, 0x6a, 0xdb, 0x85, 0x2c,
	0xb6, 0x42, 0xc0, 0x10, 0xce, 0x8e, 0x35, 0x59, 0xb7, 0xa9, 0xf4, 0x79, 0x8a, 0x20, 0x65, 0xc3,
	0x8b, 0x58, 0xb8, 0x00, 0x5a, 0x9c, 0x06, 0x60, 0x8e, 0x29, 0x11, 0xf3, 0x17, 0x78, 0x63, 0xa5,
	0x49, 0xdd, 0xf6, 0xb8, 0x1e, 0x7e, 0xc6, 0xb3, 0x21, 0x94, 0xee, 0x52, 0x1e, 0x46, 0x12, 0x47,
	0x32, 0x16, 0x2f, 0x13, 0xcd, 0x23, 0xa8, 0xd8, 0x2b, 0xfb, 0xe9, 0xfb, 0x76, 0xf8, 0x1d, 0x1e,
	0x04, 0x22, 0xfd, 0x36, 0x29, 0x09, 0x65, 0x9f, 0xe1, 0xe6, 0xe2, 0x7b, 0x6b, 0x01, 0x8f, 0x8f,
	0xe5, 0x44, 0xbc, 0x4a, 0x21, 0x21, 0xbf, 0xd1, 0xe6, 0xa8, 0x7a, 0x29, 0xda, 0xd6, 0x1d, 0x24,
	0x51, 0xe8, 0xc2, 0x3f, 0x4b, 0x85, 0x06, 0xc8, 0x63, 0xdd, 0xf1, 0x33, 0xd5, 0x9b, 0x0f, 0x21,
	0x57, 0xef, 0x18, 0x51, 0xbb, 0x22, 0x6e, 0x56, 0xea, 0x08, 0xe4, 0x52, 0xfb, 0x9f, 0xda, 0x4c,
	0xb9, 0x2c, 0x97, 0xaf, 0x95, 0xaf, 0xdb, 0x60, 0x9b, 0x32, 0x3b, 0x47, 0x0f, 0xb2, 0x08, 0x10,
	0x28, 0xa7, 0x52, 0xa7, 0x42, 0x18, 0x3e, 0xe6, 0x6e, 0xc1, 0xf8, 0x8d, 0x12, 0x00, 0xbf, 0x59,
	0x06, 0xe0, 0x59, 0x19, 0x80, 0x07, 0x7a, 0x6a, 0xff, 0xf7, 0x96, 0x0d, 0x8d, 0x01, 0x1c, 0x40,
	0xfb, 0xe6, 0x4f, 0xda, 0x78, 0xbb, 0x81, 0x88, 0xc5, 0x33, 0x97, 0x5e, 0xbf, 0xec, 0x6e, 0xf7,
	0x04, 0xfa, 0x40, 0x09, 0x5e, 0x38, 0x54, 0x20, 0x25, 0x4f, 0x28, 0x3a, 0xe1, 0x78, 0x06, 0x28,
	0xef, 0x55, 0x4a, 0x49, 0x38, 0x15, 0x6a, 0xde, 0xcb, 0xaf, 0x8e, 0x85, 0xcb, 0xcd, 0x59, 0x23,
	0x62, 0xb1, 0x58, 0xa8, 0xeb, 0x67, 0x9d, 0x4e, 0x05, 0xba, 0x3f, 0x4e, 0x42, 0x08, 0x49, 0x38,
	0xb1, 0x94, 0xc9, 0x41, 0xdc, 0x91, 0x13, 0x99, 0x25, 0xca, 0x2e, 0xd9, 0x34, 0x95, 0x83, 0xf8,
	0x94, 0x1b, 0x5d, 0xe1, 0x22, 0xe5, 0xef, 0x61, 0xe9, 0xf9, 0x30, 0xb9, 0x98, 0xc1, 0x33, 0xa7,
	0x20, 0x05, 0x18, 0x08, 0xd9, 0xa7, 0xe6, 0xc4, 0xac, 0xa1, 0x76, 0x9f, 0xcb, 0xe0, 0x7a, 0x93,
	0x29, 0xeb, 0x58, 0x1e, 0x33, 0xf4, 0x0b, 0x05, 0xc6, 0x79, 0x3f, 0xea, 0x80, 0xff, 0xb8, 0xbd,
	0xc0, 0xe7, 0xbd, 0xc9, 0xb6, 0x8d, 0x9b, 0xf9, 0xd2, 0x38, 0x72, 0x27, 0x68, 0x41, 0xee, 0x50,
	0xa8, 0x1c, 0x3a, 0x29, 0x23, 0x73, 0x0d, 0x60, 0xf6, 0x3b, 0x6c, 0x17, 0x84, 0xe3, 0xb9, 0x56,
	0x22, 0x1e, 0xe8, 0xa1, 0xf5, 0x72, 0x9b, 0x16, 0x47, 0xbb, 0x05, 0x95, 0x67, 0x22, 0x4b, 0xa2,
	0x89, 0x38, 0x83, 0x1c, 0x0f, 0x82, 0xe3, 0x90, 0x11, 0x7f, 0x95, 0xed, 0x43, 0x93, 0x8e, 0x08,
	0x0c, 0x3b, 0x9e, 0x52, 0xd6, 0x27, 0xb0, 0x23, 0x45, 0xfd, 0x50, 0xfc, 0x46, 0x3c, 0xd3, 0x32,
	0x1e, 0x74, 0x43, 0x6c, 0x6a, 0xa6, 0x85, 0x72, 0xe6, 0x00, 0xae, 0xb2, 0x1e, 0xa1, 0x0e, 0x42,
	0xbe, 0xbd, 0xc7, 0xf6, 0x95, 0x08, 0x86, 0xc6, 0xff, 0x7b, 0x64, 0xb9, 0xe1, 0x1c, 0x6c, 0xfe,
	0x1b, 0x56, 0x50, 0xdf, 0x30, 0x42, 0xe1, 0xb1, 0x8d, 0x7d, 0xbf, 0x4a, 0x53, 0xa1, 0x30, 0x42,
	0x75, 0xd3, 0x65, 0xc6, 0xc6, 0x52, 0x1f, 0x71, 0x65, 0x3c, 0x5a, 0x64, 0x53, 0x33, 0x9e, 0x29,
	0x3c, 0xc3, 0xfb, 0x79, 0x5c, 0xe1, 0xc6, 0xdf, 0xf2, 0x12, 0x56, 0x47, 0xe7, 0x3a, 0x49, 0x8f,
	0x3a, 0x30, 0x8f, 0xdb, 0x94, 0xfd, 0x61, 0xca, 0xed, 0x4d, 0x3f, 0x5b, 0x75, 0x87, 0xe6, 0x60,
	0xaa, 0x0e, 0x95, 0xe0, 0x53, 0xf5, 0x77, 0x69, 0x38, 0x53, 0x8f, 0xc3, 0xbd, 0xa2, 0x04, 0xc0,
	0x7b, 0x16, 0x4b, 0xbf, 0x6d, 0xc1, 0x78, 0xbc, 0xa8, 0xe7, 0xe6, 0x04, 0x6d, 0xee, 0xd3, 0x0d,
	0x1e, 0x73, 0x9c, 0xf6, 0xfb, 0x4c, 0xd8, 0x23, 0x7d, 0xcb, 0xba, 0xa5, 0x37, 0xcd, 0xd1, 0xcf,
	0xfb, 0xfa, 0x01, 0x8d, 0x6e, 0xf6, 0xfb, 0x88, 0x2b, 0x3b, 0x37, 0xa8, 0x7b, 0x9b, 0x7a, 0x86,
	0xc5, 0xc2, 0x4d, 0xc1, 0xa7, 0x2e, 0x71, 0xac, 0xed, 0x57, 0xda, 0xbb, 0x85, 0x6e, 0xde, 0xef,
	0x50, 0xaf, 0x01, 0xee, 0xa9, 0xdf, 0xeb, 0xbb, 0x6e, 0xbe, 0x79, 0x14, 0x9d, 0x16, 0x1f, 0x43,
	0xaa, 0xf2, 0x77, 0xc0, 0x7e, 0x68, 0xb1, 0x1d, 0xaa, 0x3c, 0x23, 0x67, 0xf1, 0x3d, 0x5a, 0x89,
	0xdb, 0xc6, 0x63, 0x51, 0xba, 0xd3, 0xf8, 0x5d, 0xf8, 0x74, 0x8f, 0xd5, 0x4c, 0x83, 0x03, 0xc2,
	0x54, 0x1f, 0xfa, 0xbb, 0x7b, 0x60, 0x7c, 0xe5, 0xbe, 0x12, 0x56, 0x39, 0xbc, 0xef, 0xd7, 0x1d,
	0x0b, 0xfd, 0xe8, 0x32, 0x75, 0x2b, 0xf8, 0x1e, 0x59, 0x23, 0xc5, 0xda, 0xb1, 0x45, 0xeb, 0x03,
	0x92, 0x12, 0xfe, 0x44, 0x4c, 0xc5, 0x87, 0x3e, 0x0d, 0x1c, 0x53, 0x5e, 0x1b, 0x88, 0x8a, 0xef,
	0xfb, 0x93, 0x77, 0xbd, 0x79, 0x0d, 0x3e, 0x9a, 0x21, 0x92, 0x72, 0xfd, 0x0f, 0x88, 0xce, 0xb3,
	0xab, 0x4c, 0x8b, 0x31, 0xee, 0x4c, 0xb1, 0x92, 0x5f, 0x72, 0x49, 0x2e, 0xae, 0xfa, 0x19, 0x85,
	0xd4, 0x3e, 0x9e, 0xfd, 0xf4, 0xf0, 0xea, 0xa9, 0xe8, 0xdb, 0x0d, 0xfa, 0x84, 0x78, 0xd7, 0xeb,
	0x19, 0x6d, 0x62, 0xae, 0x24, 0xf2, 0xfe, 0x0f, 0x81, 0xf7, 0xdf, 0x66, 0xb7, 0x90, 0xe8, 0xf9,
	0x95, 0x19, 0xf3, 0xa0, 0xaf, 0x85, 0x32, 0x2c, 0x05, 0x13, 0xf8, 0x51, 0x69, 0x81, 0xc3, 0x24,
	0xb5, 0xb3, 0x73, 0x8c, 0xf3, 0x67, 0xfd, 0xbd, 0xee, 0x08, 0xcd, 0x65, 0xe4, 0x66, 0xf8, 0xcb,
	0x25, 0xa6, 0x82, 0xdd, 0x81, 0x45, 0xff, 0x39, 0xb2, 0x25, 0x02, 0xae, 0x4e, 0xb9, 0xd2, 0x27,
	0x9d, 0xd6, 0xaf, 0xd0, 0xe6, 0x4f, 0x9b, 0x09, 0xbf, 0x4a, 0xf9, 0x42, 0x98, 0x6a, 0x7b, 0x26,
	0x32, 0xad, 0xa4, 0x0d, 0xf6, 0xfc, 0x79, 0xa8, 0xb3, 0x52, 0xe0, 0x4c, 0x04, 0xc9, 0x44, 0xa8,
	0x2b, 0x90, 0x02, 0x68, 0xce, 0xfd, 0x05, 0xe8, 0xf4, 0x2e, 0xdb, 0xf3, 0xeb, 0x9d, 0xf0, 0xff,
	0x8b, 0xd6, 0x2b, 0xd8, 0x31, 0xb5, 0x2f, 0xe2, 0xa0, 0xb8, 0x87, 0xf7, 0x6b, 0x20, 0xbf, 0x6f,
	0x14, 0x09, 0x3e, 0x49, 0x1c, 0x88, 0x6e, 0xa6, 0x25, 0xdc, 0x3a, 0xc3, 0x1b, 0x48, 0xe7, 0xa0,
	0x90, 0x08, 0x6f, 0xf9, 0x75, 0x98, 0xc9, 0x3d, 0xb6, 0x8f, 0xc2, 0x0a, 0xe2, 0x4b, 0x87, 0x49,
	0x32, 0xb2, 0xdc, 0xfa, 0x97, 0x6c, 0x3c, 0xa5, 0x95, 0x0a, 0xfd, 0x12, 0xb2, 0xef, 0xcf, 0x04,
	0x5c, 0x0d, 0x77, 0x37, 0x5c, 0xfe, 0xf2, 0x02, 0x95, 0xf1, 0x03, 0x8c, 0xef, 0xb8, 0x49, 0x1f,
	0x80, 0x3c, 0xbd, 0xe5, 0xc9, 0x53, 0x11, 0x87, 0xb9, 0xe2, 0x31, 0x44, 0xd6, 0x32, 0x0d, 0x27,
	0x21, 0x7c, 0x6e, 0x80, 0xee, 0x0f, 0x61, 0x7e, 0x1f, 0xb3, 0x9b, 0x79, 0x1a, 0x25, 0x3c, 0x7c,
	0x22, 0x78, 0x78, 0x32, 0xe6, 0x83, 0xe2, 0x86, 0xcd, 0xd1, 0x82, 0xf1, 0x7f, 0x85, 0xdd, 0xef,
	0x27, 0x4a, 0x4c, 0x84, 0x7a, 0xb5, 0xe0, 0xcb, 0xce, 0x62, 0x65, 0x37, 0x4c, 0x54, 0x66, 0x35,
	0xfb, 0x23, 0xd2, 0xcc, 0x50, 0xe6, 0x96, 0xf3, 0x18, 0x78, 0x1b, 0xe4, 0x49, 0x24, 0x7b, 0xb9,
	0x8a, 0x81, 0x70, 0xf0, 0xf4, 0x8e, 0xe1, 0x93, 0x77, 0x58, 0x3d, 0xe0, 0x71, 0x9c, 0xb8, 0xf4,
	0x94, 0x27, 0x73, 0xd2, 0x53, 0x8c, 0xce, 0x33, 0x1e, 0xdb, 0x63, 0x50, 0x24, 0x40, 0xb8, 0x27,
	0x34, 0xe0, 0x40, 0x09, 0x11, 0x3f, 0xe1, 0xb6, 0xd3, 0xdf, 0x20, 0xc5, 0x40, 0xc5, 0xc7, 0x3c,
	0x6d, 0xfd, 0x15, 0x92, 0x09, 0x0e, 0x2a, 0x7c, 0xc6, 0x2f, 0xcf, 0x92, 0x48, 0xb4, 0x9e, 0x12,
	0xeb, 0xfb, 0x35, 0x48, 0xdc, 0xcf, 0x08, 0x50, 0x77, 0x55, 0xa0, 0x96, 0x9f, 0x2f, 0x50, 0xcb,
	0x1f, 0xb1, 0x7d, 0xd7, 0xf0, 0x45, 0x2a, 0x62, 0x77, 0x34, 0x2f, 0xbc, 0x0c, 0x1f, 0x63, 0x2a,
	0x1a, 0x5f, 0x71, 0x20, 0x0c, 0xd5, 0xba, 0xf6, 0xe7, 0x9a, 0x2b, 0xd2, 0x2a, 0xa7, 0xc4, 0x28,
	0xae, 0xf6, 0xc7, 0xb9, 0xd4, 0x47, 0x9d, 0xd6, 0x8f, 0x89, 0x11, 0x5d, 0xc5, 0xa3, 0x38, 0x7c,
	0x92, 0x9b, 0x0f, 0x5b, 0x67, 0x33, 0x0b, 0xb4, 0x75, 0xad, 0x73, 0x62, 0x51, 0x57, 0x73, 0xa0,
	0x47, 0x47, 0x9d, 0xd6, 0x4b, 0x12, 0xe6, 0xae, 0xfc, 0x55, 0x1c, 0x0a, 0x85, 0x95, 0xaf, 0xdc,
	0x26, 0x52, 0xe5, 0x93, 0xd3, 0xd6, 0xa7, 0x6e, 0xc3, 0x5d, 0xa1, 0x19, 0xe0, 0x33, 0xb2, 0x9b,
	0xc0, 0x54, 0x3b, 0xe3, 0xf1, 0xe8, 0x79, 0x3e, 0x6e, 0x7d, 0x4e, 0x3d, 0x18, 0x46, 0xa1, 0xc2,
	0x2f, 0x68, 0x2e, 0xa4, 0x14, 0x6d, 0xf9, 0x4f, 0x68, 0xc9, 0xe4, 0x88, 0x53, 0xc5, 0x4f, 0xa1,
	0xe2, 0x03, 0xd6, 0x30, 0x6e, 0x62, 0xc7, 0x08, 0x07, 0x63, 0x99, 0x40, 0x6e, 0xc0, 0x97, 0x0b,
	0x8e, 0xe1, 0x16, 0x6b, 0x64, 0x22, 0x8a, 0x0e, 0xf9, 0xe0, 0x58, 0xc9, 0xf0, 0x19, 0xbf, 0x34,
	0xfd, 0xfc, 0x0c, 0xfa, 0xf9, 0x21, 0xbb, 0x05, 0xf1, 0xb3, 0x73, 0x3e, 0x11, 0xcf, 0x92, 0x58,
	0x28, 0xdf, 0x4c, 0xfa, 0xcd, 0x05, 0x54, 0xfe, 0x3d, 0xb6, 0x73, 0x21, 0xe4, 0x65, 0xe9, 0x21,
	0x94, 0xee, 0xe2, 0xa8, 0x1b, 0x59, 0x33, 0x48, 0x8c, 0xbf, 0x05, 0x8f, 0xce, 0x7c, 0xc4, 0xf6,
	0x52, 0xa1, 0x1f, 0x0d, 0x06, 0xc5, 0xf4, 0xa1, 0x1b, 0xbe, 0x18, 0xc3, 0x45, 0x83, 0xe9, 0x79,
	0x3e, 0xc6, 0x7e, 0x7a, 0x24, 0x4f, 0x53, 0xc9, 0xe3, 0x04, 0xc8, 0x24, 0x20, 0xbd, 0x83, 0xe8,
	0xd9, 0x21, 0xd7, 0x3a, 0x42, 0x56, 0x44, 0xd0, 0x36, 0x24, 0xe3, 0x33, 0x9d, 0xa4, 0x07, 0x7a,
	0x04, 0x8a, 0x56, 0xd0, 0xbd, 0xe2, 0x74, 0x92, 0x76, 0x44, 0x1f, 0xca, 0xfa, 0x84, 0x51, 0xd9,
	0x33, 0x79, 0xcc, 0x03, 0x61, 0xb6, 0x6c, 0xe0, 0x48, 0x20, 0x89, 0x5c, 0xe1, 0xd0, 0x47, 0xe3,
	0x0c, 0xff, 0x1c, 0x68, 0xad, 0x5a, 0x92, 0xfc, 0x52, 0x23, 0x97, 0xcd, 0xe0, 0x50, 0xfa, 0x57,
	0x29, 0x20, 0x0f, 0x8c, 0x5b, 0x18, 0x8c, 0x23, 0x28, 0xff, 0x80, 0x35, 0x00, 0xc2, 0x3c, 0x36,
	0x4e, 0x0d, 0x6d, 0x48, 0xb4, 0xc0, 0x1f, 0xff, 0x17, 0x15, 0x4c, 0x27, 0x76, 0x5e, 0x24, 0x6a,
	0xbc, 0x6b, 0x60, 0xc7, 0x7d, 0x56, 0x0f, 0x86, 0x32, 0x0a, 0x29, 0x39, 0xd8, 0x82, 0x29, 0x85,
	0x17, 0xb5, 0xea, 0xae, 0xc6, 0x07, 0xda, 0x47, 0x1e, 0xbf, 0xcf, 0xb6, 0x71, 0x43, 0x5d, 0x46,
	0xa8, 0x0d, 0x35, 0xee, 0x95, 0xfd, 0x58, 0x6c, 0x84, 0xf7, 0xa5, 0xe1, 0xa6, 0xaa, 0x97, 0x4e,
	0x51, 0xa0, 0x97, 0x1b, 0x73, 0xd1, 0xcb, 0xcd, 0x45, 0xe8, 0x25, 0x23, 0x08, 0xd0, 0x55, 0x60,
	0xbc, 0xa1, 0xba, 0x10, 0xd5, 0xac, 0x2d, 0x42, 0x35, 0xeb, 0xd7, 0xa1, 0x9a, 0x5b, 0x33, 0xa8,
	0xe6, 0x36, 0x49, 0x03, 0xd7, 0xfc, 0x89, 0x0c, 0x85, 0xed, 0xcb, 0x79, 0x17, 0x84, 0xda, 0x79,
	0x75, 0x8d, 0xb9, 0x70, 0x68, 0x73, 0x2e, 0x1c, 0xba, 0x0b, 0xa4, 0x06, 0xe8, 0x5f, 0x94, 0xa8,
	0x0e, 0x5d, 0x11, 0xd9, 0xb3, 0x4f, 0x5a, 0x6c, 0x40, 0xf1, 0xd9, 0xf1, 0x21, 0xf8, 0x06, 0xa5,
	0x00, 0xcc, 0xa0, 0xc7, 0xe7, 0xc0, 0xa8, 0x37, 0xe6, 0xc1, 0xa8, 0x37, 0x17, 0xc0, 0xa8, 0x2d,
	0x0f, 0x0d, 0x87, 0x72, 0xdc, 0xda, 0x5b, 0x33, 0xe8, 0xea, 0xed, 0x39, 0xe8, 0xea, 0x9d, 0x29,
	0x74, 0xf5, 0x6e, 0x09, 0x5d, 0xbd, 0xe7, 0x6e, 0xfe, 0x26, 0x0a, 0x6f, 0xd6, 0xa1, 0x69, 0xdf,
	0xfe, 0x63, 0x7b, 0xfb, 0x12, 0x02, 0x00, 0xa1, 0x92, 0x93, 0xa9, 0xc7, 0x6e, 0x4a, 0x49, 0x89,
	0xc6, 0xa9, 0xb5, 0x3e, 0x46, 0xcf, 0xc3, 0xff, 0x6e, 0xb3, 0x66, 0xaf, 0x64, 0x55, 0x82, 0xf4,
	0x5b, 0x75, 0xc9, 0xd7, 0xce, 0xe8, 0xf2, 0x62, 0xc6, 0x77, 0xd8, 0x6e, 0x56, 0x36, 0x55, 0xe1,
	0xa3, 0x35, 0x97, 0x99, 0x0d, 0x95, 0x8f, 0x2e, 0xbd, 0xba, 0x75, 0x42, 0x7e, 0x11, 0xc8, 0x34,
	0x65, 0x67, 0x46, 0x4d, 0x59, 0xd0, 0xc9, 0xa8, 0x23, 0x41, 0x7e, 0x96, 0x97, 0x93, 0xd0, 0xfe,
	0x5b, 0x36, 0xf4, 0x6f, 0x93, 0xc4, 0xa6, 0x43, 0x40, 0xbb, 0xac, 0xda, 0xcf, 0x55, 0x2c, 0x75,
	0xae, 0x8a, 0x1c, 0x0b, 0x9b, 0x54, 0xf1, 0xc4, 0x7c, 0xe2, 0x47, 0x98, 0xe6, 0xbf, 0x5b, 0xe5,
	0xa7, 0x94, 0x55, 0x16, 0x27, 0xbf, 0xc8, 0xec, 0xb9, 0xb8, 0xb0, 0x21, 0x8a, 0xff, 0x6a, 0xf1,
	0xd1, 0xbe, 0x8c, 0xc3, 0x0b, 0x7e, 0xd5, 0x1d, 0xe4, 0x72, 0x26, 0x09, 0xdc, 0xde, 0x9b, 0x73,
	0xaf, 0x0c, 0x51, 0x1a, 0xc8, 0x4a, 0x19, 0x5e, 0x5a, 0x75, 0xa8, 0x00, 0x5e, 0x45, 0xf1, 0x9f,
	0x91, 0x01, 0x68, 0x96, 0x07, 0xc3, 0xa7, 0x5e, 0x7a, 0x15, 0x5c, 0xaf, 0x0c, 0x44, 0x90, 0xbe,
	0xe4, 0x00, 0xb5, 0x39, 0x00, 0xa2, 0x2f, 0x63, 0x99, 0x0d, 0x6d, 0xe9, 0x86, 0xbd, 0x06, 0xde,
	0xc0, 0xd2, 0x23, 0x7c, 0x08, 0xe9, 0x4c, 0x5a, 0x38, 0x8f, 0x50, 0x33, 0xfb, 0x40, 0x12, 0xde,
	0x8a, 0xb2, 0x6f, 0x1b, 0x41, 0x23, 0x66, 0x9f, 0x17, 0x29, 0xee, 0xbd, 0x0f, 0xb8, 0xe2, 0x03,
	0xd1, 0x9d, 0x09, 0xec, 0xda, 0xf4, 0xa1, 0x6f, 0x8a, 0x1b, 0xb6, 0x3f, 0x9f, 0x92, 0xb0, 0xf3,
	0xde, 0x53, 0xd9, 0x62, 0x6b, 0x28, 0xec, 0xec, 0x39, 0x7e, 0xbb, 0xe0, 0x7b, 0x66, 0x93, 0x2c,
	0x79, 0x20, 0xba, 0xa1, 0xcc, 0x00, 0x1e, 0x7b, 0xb3, 0xb7, 0xc7, 0xe0, 0x13, 0xdb, 0xb3, 0xa5,
	0x80, 0x7f, 0xb2, 0xe4, 0xdd, 0x9b, 0x06, 0x48, 0xfd, 0xb5, 0xee, 0x51, 0x36, 0xd8, 0xa6, 0x76,
	0x80, 0xe3, 0xea, 0x14, 0x7a, 0x5e, 0x29, 0x32, 0x72, 0xed, 0x3d, 0xae, 0x35, 0xc7, 0x75, 0xf0,
	0xa4, 0xd9, 0x11, 0xb7, 0x12, 0xca, 0x7b, 0x38, 0xe5, 0x26, 0xdb, 0x16, 0x97, 0xe5, 0x0a, 0x7c,
	0xc5, 0xe6, 0x6f, 0xda, 0x0b, 0xfa, 0x71, 0x1a, 0x7c, 0xd3, 0x23, 0x47, 0xba, 0x08, 0xdf, 0xd5,
	0xd8, 0xea, 0x50, 0x70, 0xef, 0x2d, 0x1d, 0xfb, 0xbe, 0x54, 0x65, 0xfa, 0x45, 0xa9, 0x35, 0x3f,
	0x44, 0xbf, 0x5e, 0x8e, 0xab, 0x6e, 0x80, 0xe0, 0xad, 0xb3, 0x4a, 0x1f, 0xe2, 0xf5, 0x9b, 0xe5,
	0x30, 0xa4, 0x43, 0x92, 0x5d, 0x36, 0x40, 0x75, 0x8e, 0x61, 0x5e, 0x8e, 0xde, 0xbb, 0x0b, 0x6d,
	0x18, 0xe7, 0x2d, 0x5f, 0xba, 0x0f, 0x22, 0x19, 0xe0, 0xab, 0x6e, 0x5b, 0x70, 0xe1, 0xf3, 0x6d,
	0x78, 0x26, 0x68, 0x64, 0x1c, 0x0e, 0x23, 0x77, 0xe7, 0x3c, 0x41, 0x04, 0x69, 0x4c, 0xb6, 0x09,
	0xc2, 0x42, 0x3b, 0x30, 0xe5, 0x7b, 0x6c, 0x7d, 0xcc, 0xd5, 0x68, 0xd1, 0x9d, 0xfb, 0x7b, 0x18,
	0x63, 0x5c, 0x74, 0xe9, 0xfe, 0x01, 0x63, 0x56, 0x30, 0x98, 0x16, 0xbb, 0x73, 0x5e, 0x3e, 0xfa,
	0xed, 0x25, 0x4c, 0x54, 0xbf, 0x90, 0xf1, 0xa0, 0x0b, 0xef, 0x68, 0x74, 0x71, 0x4f, 0xa6, 0xa3,
	0x14, 0xdf, 0x63, 0x75, 0x94, 0x97, 0x60, 0xa9, 0x39, 0xf6, 0x9a, 0x9b, 0xa8, 0xf1, 0xa1, 0x7d,
	0x92, 0x83, 0x6e, 0xb7, 0xae, 0x78, 0x3e, 0x28, 0x8e, 0x91, 0x0a, 0x45, 0xad, 0xdb, 0x7f, 0xdf,
	0x8a, 0x30, 0x94, 0xab, 0xe2, 0x32, 0xe5, 0x53, 0xf7, 0x58, 0xee, 0x58, 0xe5, 0xb3, 0x3c, 0xef,
	0x96, 0x41, 0xf9, 0x45, 0xac, 0x59, 0x79, 0xbb, 0x3a, 0x57, 0xde, 0x56, 0x66, 0xe4, 0xed, 0xda,
	0x82, 0x14, 0x96, 0xbf, 0x6b, 0xb3, 0x55, 0xe5, 0xf5, 0x56, 0xd8, 0x37, 0xa4, 0x41, 0x4e, 0x21,
	0xd4, 0x78, 0x85, 0xca, 0x17, 0xa6, 0x5e, 0x96, 0xce, 0x7a, 0x21, 0x71, 0x9d, 0xc4, 0xd9, 0xa0,
	0xbb, 0xe6, 0x28, 0x0b, 0x1c, 0x80, 0xab, 0x45, 0xa6, 0x3f, 0x13, 0x36, 0xaf, 0x14, 0x63, 0x21,
	0xef, 0x96, 0xa8, 0xba, 0xba, 0xf8, 0xb2, 0x62, 0x96, 0xba, 0xdb, 0x4f, 0x0d, 0xb6, 0x69, 0x2a,
	0xd1, 0x4e, 0xa8, 0x13, 0xa3, 0xf5, 0x55, 0x32, 0x76, 0x11, 0x7f, 0x9c, 0x72, 0x3f, 0x51, 0x27,
	0x1d, 0x0c, 0xea, 0x52, 0x8e, 0x7f, 0xf1, 0xc6, 0xc0, 0x1b, 0xcc, 0xf1, 0xff, 0x47, 0xeb, 0x98,
	0xd4, 0x0c, 0xb0, 0xc0, 0xeb, 0x44, 0x07, 0x66, 0xae, 0x85, 0x1b, 0xc2, 0x36, 0xc6, 0x52, 0x85,
	0x52, 0xfa, 0x4c, 0x81, 0x7d, 0xda, 0x65, 0x8d, 0x92, 0xff, 0x4c, 0xd9, 0xa1, 0xb4, 0x17, 0x50,
	0xd7, 0xe9, 0xd3, 0x20, 0xeb, 0x41, 0x82, 0x8b, 0x4b, 0x4b, 0xe7, 0xb1, 0x1c, 0xdb, 0x4f, 0x37,
	0xa7, 0x4f, 0x8d, 0xd1, 0x46, 0x5e, 0x98, 0xe3, 0x80, 0x93, 0x75, 0xb1, 0x28, 0xae, 0x47, 0xcf,
	0x64, 0x5c, 0xdc, 0x34, 0x33, 0xbf, 0xf9, 0xa5, 0x05, 0xc8, 0x31, 0x40, 0xb1, 0xe5, 0x07, 0x28,
	0xb6, 0x4b, 0x01, 0x8a, 0x9d, 0x72, 0x80, 0xa2, 0x51, 0x0e, 0x50, 0x34, 0xfd, 0x5b, 0x53, 0xe0,
	0x8d, 0xec, 0x16, 0x8f, 0xf8, 0x58, 0x34, 0xa5, 0x08, 0x91, 0x03, 0xab, 0xec, 0x13, 0xf5, 0xe0,
	0x95, 0x38, 0xcf, 0xc4, 0x74, 0xf9, 0xe0, 0xa7, 0x70, 0x16, 0x37, 0xdd, 0x2b, 0x35, 0x7a, 0x64,
	0xfc, 0xf6, 0x73, 0x2d, 0x52, 0xcc, 0xa0, 0x68, 0x91, 0x1b, 0x3b, 0x4c, 0xcb, 0x15, 0xb7, 0xe8,
	0x93, 0x50, 0xf4, 0xcb, 0x35, 0x0e, 0x7d, 0x36, 0x8b, 0x2a, 0x57, 0xdd, 0x21, 0xab, 0x1b, 0x56,
	0x58, 0xae, 0x73, 0xc8, 0x33, 0x2c, 0xb7, 0x5c, 0x77, 0x8f, 0x52, 0x26, 0x15, 0xa2, 0xf9, 0x87,
	0x3c, 0x13, 0xee, 0x31, 0xa7, 0x79, 0x54, 0xff, 0x31, 0xdb, 0xb1, 0x4d, 0xe1, 0x11, 0x20, 0x68,
	0xfb, 0x96, 0x1f, 0xa6, 0x02, 0x14, 0xca, 0x36, 0x41, 0x96, 0x37, 0x86, 0xa7, 0xe6, 0xca, 0x43,
	0xe2, 0x1e, 0x94, 0x5e, 0xaa, 0x48, 0xa2, 0xbc, 0x17, 0x11, 0x0c, 0x7d, 0x83, 0x6d, 0x59, 0x7a,
	0x38, 0xd0, 0x78, 0xfb, 0xa1, 0x4d, 0xd9, 0x36, 0xb6, 0xfc, 0x09, 0x5e, 0x5f, 0x7a, 0x87, 0x8c,
	0x5a, 0x5b, 0xdc, 0x11, 0x98, 0x95, 0xf0, 0x2e, 0x69, 0x50, 0x5b, 0x7e, 0xa4, 0x6c, 0x5a, 0xf9,
	0x77, 0x28, 0x2b, 0xc1, 0x56, 0x1c, 0x42, 0x50, 0xd8, 0xd4, 0xbc, 0x37, 0x55, 0x83, 0x8e, 0xb1,
	0xa9, 0xf9, 0x2e, 0xa9, 0xa3, 0xe2, 0xcd, 0xa7, 0x87, 0xde, 0x65, 0x42, 0xe4, 0xf6, 0xf7, 0x89,
	0xb8, 0x15, 0x57, 0xa2, 0x23, 0x06, 0x4a, 0x10, 0xae, 0x5c, 0x48, 0x80, 0x0f, 0x66, 0x24, 0xc0,
	0x87, 0x20, 0x01, 0x9e, 0xa2, 0xbd, 0x93, 0x0a, 0xdd, 0x05, 0x57, 0xf5, 0x75, 0x53, 0x44, 0x4b,
	0x0f, 0x5c, 0xb6, 0xff, 0xf7, 0x3a, 0x9a, 0x07, 0x93, 0x29, 0x8e, 0x2f, 0xb9, 0x0e, 0x1f, 0xb0,
	0x86, 0xcd, 0x1e, 0xfd, 0xe6, 0x37, 0x58, 0x9b, 0xef, 0xe0, 0x0b, 0x45, 0x48, 0xcc, 0xab, 0x0b,
	0x0c, 0xea, 0x77, 0xd8, 0xa6, 0x12, 0x3c, 0x3a, 0x75, 0xd2, 0x67, 0x41, 0xae, 0x2d, 0xf8, 0xf0,
	0xde, 0xa0, 0x6b, 0x8b, 0xb3, 0xf8, 0x8d, 0x11, 0x7b, 0x10, 0x86, 0xe7, 0xf6, 0xca, 0x9e, 0x3d,
	0x6a, 0x84, 0x2b, 0x1f, 0xf3, 0x40, 0xc0, 0xa3, 0x54, 0x1b, 0xae, 0x1c, 0xfc, 0x6b, 0xbc, 0xf5,
	0x09, 0x4f, 0x70, 0xd2, 0x23, 0x80, 0x32, 0x3d, 0x1a, 0x72, 0x7d, 0x7a, 0x5a, 0xbc, 0x28, 0x17,
	0x27, 0x47, 0xe1, 0x81, 0x12, 0x31, 0xb7, 0x19, 0x3b, 0xe5, 0xf4, 0xae, 0xd3, 0x28, 0xcf, 0xac,
	0x5d, 0xb2, 0xc7, 0x6a, 0x13, 0x99, 0x9e, 0x8f, 0x64, 0x8a, 0x17, 0xca, 0xdd, 0x55, 0x82, 0x1e,
	0xd7, 0xc3, 0x47, 0x97, 0x29, 0x4c, 0x2d, 0x4f, 0xed, 0x55, 0x82, 0x2d, 0xb6, 0x36, 0x91, 0xe9,
	0xa9, 0xa0, 0x2b, 0x04, 0xc6, 0x07, 0x30, 0xd3, 0x11, 0x76, 0x09, 0x3b, 0x5e, 0xab, 0xc3, 0x67,
	0xc7, 0x36, 0xce, 0x76, 0x83, 0x6d, 0x99, 0xdf, 0x5c, 0x19, 0x73, 0xfc, 0x71, 0x12, 0x6b, 0x9b,
	0xad, 0x03, 0xf6, 0x5f, 0x7a, 0xaa, 0x92, 0x71, 0xa2, 0xed, 0xc5, 0xcf, 0x5d, 0x5a, 0x00, 0x82,
	0x3d, 0xb0, 0xd6, 0xa3, 0x0e, 0x5e, 0x64, 0x35, 0xa4, 0x4b, 0xe1, 0xe1, 0xe3, 0x24, 0xa2, 0x90,
	0xd9, 0x8a, 0x0b, 0x7e, 0x1e, 0x14, 0x21, 0xc5, 0x1b, 0x34, 0x40, 0x2f, 0xbf, 0xb2, 0x01, 0x51,
	0xac, 0xb8, 0xe9, 0x55, 0x1c, 0x4a, 0x7d, 0x94, 0x48, 0x44, 0x5f, 0x6d, 0x36, 0x4f, 0x9b, 0xdd,
	0x36, 0x46, 0x39, 0xe1, 0xfd, 0xa6, 0xc6, 0x63, 0xe8, 0x5b, 0xd0, 0xe6, 0x2e, 0xdb, 0xc3, 0x3c,
	0x37, 0x98, 0xdd, 0xf9, 0x30, 0x49, 0xe9, 0xde, 0xfd, 0x0a, 0x46, 0x0d, 0xb0, 0xf6, 0x99, 0xc5,
	0xed, 0x8a, 0x06, 0x77, 0xca, 0x9f, 0xc3, 0x74, 0x8b, 0xda, 0xbb, 0xe5, 0xda, 0xc3, 0x88, 0x07,
	0xa3, 0xa2, 0xf6, 0x1e, 0xa1, 0xfe, 0x36, 0xc5, 0x0e, 0x81, 0xa9, 0xa2, 0xfe, 0x3e, 0xad, 0x2b,
	0x93, 0x83, 0xf8, 0x19, 0x38, 0x2a, 0x58, 0xf1, 0x16, 0x75, 0x8b, 0xcf, 0xff, 0x1a, 0x57, 0x09,
	0x9e, 0xcd, 0xc1, 0x5a, 0x7c, 0xa3, 0x0e, 0x5e, 0xb6, 0x52, 0x80, 0x2e, 0xbe, 0xed, 0x9d, 0xe0,
	0x41, 0x40, 0x62, 0xa9, 0xc5, 0x76, 0x26, 0x32, 0x7d, 0x4c, 0x5e, 0xab, 0x19, 0xd6, 0x4a, 0xa6,
	0x5d, 0x56, 0x9d, 0xc8, 0xf4, 0x53, 0x11, 0x0c, 0x65, 0xc0, 0x23, 0x2b, 0x96, 0x2c, 0x65, 0x77,
	0xe0, 0x81, 0x05, 0x88, 0x83, 0x15, 0x94, 0xfa, 0x58, 0x44, 0x51, 0x72, 0x61, 0x85, 0x91, 0x91,
	0x99, 0x22, 0xea, 0x77, 0x44, 0xff, 0x53, 0x7c, 0x5b, 0xd7, 0x8a, 0xa2, 0x3d, 0x56, 0x0b, 0x7c,
	0xbf, 0xfa, 0x21, 0xb8, 0x05, 0xbf, 0xb7, 0x6c, 0x1f, 0x97, 0xa6, 0x79, 0xfc, 0xa2, 0x22, 0x64,
	0xfa, 0xb5, 0x47, 0xe3, 0xea, 0xe6, 0x3d, 0xcf, 0x37, 0x20, 0x43, 0x72, 0xee, 0xe3, 0x75, 0x70,
	0x9b, 0x08, 0x31, 0x9d, 0xe2, 0x62, 0x82, 0x54, 0x22, 0xd0, 0xf8, 0xdc, 0xe2, 0xe6, 0xb4, 0xbf,
	0xc1, 0x7c, 0x7f, 0xa3, 0x5a, 0xe4, 0x26, 0x1c, 0xf1, 0xf8, 0x94, 0x67, 0xf4, 0x00, 0xcc, 0x5b,
	0x6c, 0x33, 0x81, 0x87, 0x47, 0x0d, 0x6f, 0xd7, 0xe7, 0xd8, 0xe8, 0x46, 0x48, 0xf1, 0xc8, 0x6a,
	0xdc, 0xad, 0x05, 0x56, 0xe8, 0x0f, 0xfc, 0xa7, 0x78, 0x7a, 0xf9, 0xd5, 0xf4, 0x0d, 0x9e, 0x99,
	0x17, 0x03, 0xff, 0xd3, 0x92, 0xbb, 0xa5, 0xad, 0x23, 0xd1, 0xbd, 0xe0, 0x13, 0xf1, 0x4d, 0x59,
	0x66, 0xf6, 0x99, 0x0c, 0x0f, 0x90, 0x31, 0x04, 0x64, 0x23, 0x15, 0xab, 0x44, 0x40, 0xda, 0xcf,
	0xe8, 0x69, 0xb0, 0xcd, 0xa8, 0xf4, 0x42, 0x9d, 0x75, 0x50, 0xed, 0xf3, 0x32, 0xeb, 0xd4, 0x0b,
	0xb8, 0xa5, 0x3e, 0x48, 0x58, 0x7a, 0x85, 0x73, 0xd3, 0xde, 0x19, 0xc4, 0x52, 0x7a, 0x1d, 0x84,
	0x79, 0x2f, 0x22, 0x80, 0x29, 0x68, 0x2a, 0xbb, 0x5c, 0x0d, 0x30, 0xe3, 0xec, 0x4f, 0x56, 0xd0,
	0x6b, 0x18, 0xcb, 0x58, 0x76, 0x2f, 0xb8, 0x52, 0x32, 0x51, 0x73, 0xde, 0xae, 0x89, 0xf3, 0xf1,
	0xa9, 0x50, 0xc7, 0x2a, 0xc9, 0xd3, 0xe2, 0x11, 0x41, 0x78, 0xee, 0xf8, 0x79, 0x3e, 0x36, 0x46,
	0x98, 0xbb, 0x8a, 0x3d, 0xe0, 0xa9, 0xcd, 0x0c, 0xdb, 0xb1, 0x0f, 0x22, 0x1b, 0xc6, 0x71, 0x59,
	0x18, 0xf8, 0x50, 0xdf, 0xf8, 0x0a, 0xbb, 0x5a, 0x23, 0x33, 0x07, 0x1a, 0x1e, 0x84, 0xa1, 0x1b,
	0x64, 0xbd, 0x78, 0xba, 0x43, 0x65, 0x1a, 0xe5, 0xe7, 0x86, 0xd7, 0x09, 0x94, 0x60, 0xd3, 0x4d,
	0xea, 0x04, 0x4c, 0x1b, 0xbf, 0x13, 0x46, 0xf0, 0x21, 0xd4, 0x3c, 0xe3, 0x97, 0x28, 0xa8, 0xbc,
	0x0b, 0xa0, 0xda, 0xbf, 0x00, 0x6a, 0xe4, 0x5e, 0x92, 0x65, 0x07, 0x69, 0x2a, 0xb8, 0x3a, 0x87,
	0x6b, 0xcb, 0x75, 0x67, 0x52, 0x95, 0x2b, 0x0e, 0xc2, 0xd0, 0xda, 0x9a, 0xb6, 0xee, 0x08, 0x04,
	0xef, 0x51, 0x12, 0x25, 0xca, 0x65, 0xf3, 0x36, 0xef, 0xb1, 0xfd, 0xd9, 0x3a, 0xf3, 0xe9, 0x0e,
	0x4d, 0xd9, 0x54, 0x1f, 0x73, 0x3d, 0x14, 0xca, 0x3e, 0xb1, 0xd4, 0x20, 0x58, 0x75, 0xba, 0xc6,
	0x7c, 0xd6, 0x74, 0xfe, 0xb6, 0xd9, 0x2e, 0x9c, 0x61, 0xe9, 0x21, 0x16, 0x2c, 0xda, 0x2b, 0xf2,
	0xb1, 0x51, 0x43, 0xa1, 0xa9, 0xda, 0xfe, 0x21, 0x1e, 0x35, 0xbd, 0x90, 0x3c, 0x83, 0xfc, 0xec,
	0xb2, 0x6a, 0xcf, 0x0b, 0xb2, 0x2f, 0xc3, 0xb3, 0xef, 0x5f, 0x7a, 0x80, 0x64, 0xc6, 0xaf, 0xae,
	0x44, 0x36, 0x6d, 0x55, 0x18, 0xbe, 0x5d, 0x9e, 0x7a, 0xb5, 0x79, 0x65, 0xf6, 0xd5, 0xe6, 0xd5,
	0xf2, 0xab, 0xcd, 0xe0, 0x48, 0x94, 0x00, 0x29, 0x7c, 0x1e, 0xf9, 0x17, 0x07, 0xa4, 0xbe, 0x8f,
	0x33, 0x45, 0xff, 0x77, 0xee, 0x5d, 0x7e, 0xdf, 0x04, 0x6a, 0xff, 0xba, 0xf5, 0xbb, 0x0c, 0x43,
	0x74, 0x43, 0x7e, 0x95, 0x95, 0x2e, 0xba, 0x3d, 0x98, 0xfa, 0x13, 0x0a, 0xb3, 0xc3, 0x1d, 0xd8,
	0xf7, 0xa6, 0x85, 0xee, 0xa6, 0xc6, 0x60, 0x9b, 0x7e, 0x49, 0xa1, 0xec, 0xd8, 0x1a, 0x76, 0x81,
	0xad, 0x41, 0x93, 0x1b, 0x53, 0xec, 0xff, 0xcf, 0xb2, 0xbd, 0x73, 0x1a, 0x88, 0x58, 0xbc, 0x5e,
	0x4a, 0xf4, 0xd8, 0x46, 0x23, 0x57, 0x89, 0x27, 0x40, 0x60, 0x3e, 0x4b, 0x94, 0x78, 0x91, 0x8a,
	0xb8, 0x90, 0xdc, 0xfe, 0x45, 0xff, 0xc6, 0x9c, 0x8b, 0xfe, 0xde, 0xeb, 0x03, 0x1b, 0xf3, 0xc4,
	0xf9, 0x3e, 0xab, 0xbb, 0xfb, 0x1f, 0x9e, 0x94, 0xf1, 0x33, 0x8a, 0x1e, 0xc5, 0xdc, 0x98, 0xee,
	0x8c, 0x88, 0x33, 0x49, 0x45, 0xfc, 0xd8, 0x4f, 0x23, 0xdc, 0x63, 0x35, 0x7a, 0xf4, 0xdc, 0xc3,
	0x7c, 0xb6, 0xd9, 0x7a, 0x6c, 0x03, 0xfa, 0x75, 0x9b, 0x74, 0x50, 0x7a, 0x73, 0x60, 0x6b, 0x0e,
	0x76, 0x64, 0x8c, 0x70, 0x48, 0x0d, 0xa6, 0x7b, 0x9a, 0x40, 0x63, 0x2a, 0x89, 0x84, 0x0f, 0xf6,
	0x7c, 0x97, 0x35, 0x8a, 0x78, 0x37, 0x75, 0xd7, 0x98, 0xf3, 0xe8, 0xcc, 0xe7, 0xfe, 0x7b, 0x2b,
	0xf0, 0x97, 0x31, 0xa6, 0x5f, 0xb2, 0x98, 0xfd, 0xcb, 0x02, 0xdf, 0x0a, 0xc2, 0x3c, 0xdc, 0xf9,
	0x83, 0x9f, 0xdf, 0x5f, 0xfa, 0xa3, 0x9f, 0xdf, 0x5f, 0xfa, 0xe3, 0x9f, 0xdf, 0x5f, 0xfa, 0x7b,
	0xff, 0xe5, 0xfe, 0x9f, 0xf9, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x8d, 0x6d, 0x8f, 0xbd, 0xed,
	0x63, 0x00, 0x00,
}

func (m *LuaSignReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaSignReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaSignReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Reward) > 0 {
		for iNdEx := len(m.Reward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Reward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ID)<<1)^uint32((*m.ID>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaParkShop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaParkShop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaParkShop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Price != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Price)<<1)^uint32((*m.Price>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.CostType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CostType)<<1)^uint32((*m.CostType>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Num != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Num)<<1)^uint32((*m.Num>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.CarId != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CarId)<<1)^uint32((*m.CarId>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.ItemId != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ItemId)<<1)^uint32((*m.ItemId>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaDailyActivity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaDailyActivity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaDailyActivity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Reward) > 0 {
		for iNdEx := len(m.Reward) - 1; iNdEx >= 0; iNdEx-- {
			x1 := (uint32(m.Reward[iNdEx]) << 1) ^ uint32((m.Reward[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x1))
			i--
			dAtA[i] = 0x18
		}
	}
	if m.ActivityValue != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ActivityValue)<<1)^uint32((*m.ActivityValue>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaAchieve) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaAchieve) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaAchieve) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Quality != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Quality)<<1)^uint32((*m.Quality>>31))))
		i--
		dAtA[i] = 0x50
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.AchievePoint != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.AchievePoint)<<1)^uint32((*m.AchievePoint>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.ConditionValue != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint64(*m.ConditionValue)<<1)^uint64((*m.ConditionValue>>63))))
		i--
		dAtA[i] = 0x38
	}
	if m.Des != nil {
		i -= len(m.Des)
		copy(dAtA[i:], m.Des)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Des)))
		i--
		dAtA[i] = 0x32
	}
	if m.IsHide != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IsHide)<<1)^uint32((*m.IsHide>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Name != nil {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TypeName != nil {
		i -= len(m.TypeName)
		copy(dAtA[i:], m.TypeName)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.TypeName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaFaceShop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaFaceShop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaFaceShop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Price) > 0 {
		for iNdEx := len(m.Price) - 1; iNdEx >= 0; iNdEx-- {
			x2 := (uint32(m.Price[iNdEx]) << 1) ^ uint32((m.Price[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x2))
			i--
			dAtA[i] = 0x28
		}
	}
	if m.CostType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CostType)<<1)^uint32((*m.CostType>>31))))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Duration) > 0 {
		for iNdEx := len(m.Duration) - 1; iNdEx >= 0; iNdEx-- {
			x3 := (uint32(m.Duration[iNdEx]) << 1) ^ uint32((m.Duration[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x3))
			i--
			dAtA[i] = 0x18
		}
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Index)<<1)^uint32((*m.Index>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaBgm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaBgm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaBgm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Time != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Time))))
		i--
		dAtA[i] = 0x2d
	}
	if m.NeedVipLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.NeedVipLevel)<<1)^uint32((*m.NeedVipLevel>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Sound != nil {
		i -= len(m.Sound)
		copy(dAtA[i:], m.Sound)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Sound)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BgmNameID != nil {
		i -= len(m.BgmNameID)
		copy(dAtA[i:], m.BgmNameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.BgmNameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaArenaReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaArenaReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaArenaReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LoseRewardList) > 0 {
		for iNdEx := len(m.LoseRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LoseRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.WinRewardList) > 0 {
		for iNdEx := len(m.WinRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WinRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaArenaSelectRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaArenaSelectRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaArenaSelectRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PosRectList) > 0 {
		for iNdEx := len(m.PosRectList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PosRectList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.RankRect) > 0 {
		for iNdEx := len(m.RankRect) - 1; iNdEx >= 0; iNdEx-- {
			x4 := (uint32(m.RankRect[iNdEx]) << 1) ^ uint32((m.RankRect[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x4))
			i--
			dAtA[i] = 0x10
		}
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaDangerChapter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaDangerChapter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaDangerChapter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EnemyPos != nil {
		{
			size, err := m.EnemyPos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.SharePic != nil {
		i -= len(m.SharePic)
		copy(dAtA[i:], m.SharePic)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.SharePic)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.LockIcon != nil {
		i -= len(m.LockIcon)
		copy(dAtA[i:], m.LockIcon)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.LockIcon)))
		i--
		dAtA[i] = 0x32
	}
	if m.Title != nil {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Icon != nil {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DupList) > 0 {
		for iNdEx := len(m.DupList) - 1; iNdEx >= 0; iNdEx-- {
			x6 := (uint32(m.DupList[iNdEx]) << 1) ^ uint32((m.DupList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x6))
			i--
			dAtA[i] = 0x18
		}
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaAssistantTip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaAssistantTip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaAssistantTip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Reward != nil {
		{
			size, err := m.Reward.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Icon != nil {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x22
	}
	if m.AnswerID != nil {
		i -= len(m.AnswerID)
		copy(dAtA[i:], m.AnswerID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.AnswerID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.QuestionID != nil {
		i -= len(m.QuestionID)
		copy(dAtA[i:], m.QuestionID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.QuestionID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaVehicleCompose) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaVehicleCompose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaVehicleCompose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NeedLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.NeedLevel)<<1)^uint32((*m.NeedLevel>>31))))
		i--
		dAtA[i] = 0x18
	}
	if len(m.NeedItemList) > 0 {
		for iNdEx := len(m.NeedItemList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NeedItemList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Quality != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Quality)<<1)^uint32((*m.Quality>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaChapter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaChapter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaChapter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EnemyPos != nil {
		{
			size, err := m.EnemyPos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.SharePic != nil {
		i -= len(m.SharePic)
		copy(dAtA[i:], m.SharePic)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.SharePic)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.LockIcon != nil {
		i -= len(m.LockIcon)
		copy(dAtA[i:], m.LockIcon)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.LockIcon)))
		i--
		dAtA[i] = 0x32
	}
	if m.Title != nil {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Icon != nil {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DupList) > 0 {
		for iNdEx := len(m.DupList) - 1; iNdEx >= 0; iNdEx-- {
			x9 := (uint32(m.DupList[iNdEx]) << 1) ^ uint32((m.DupList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x9))
			i--
			dAtA[i] = 0x18
		}
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaBuilding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaBuilding) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaBuilding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pos != nil {
		{
			size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Res != nil {
		i -= len(m.Res)
		copy(dAtA[i:], m.Res)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Res)))
		i--
		dAtA[i] = 0x32
	}
	if m.ResType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ResType)<<1)^uint32((*m.ResType>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.ZOrder != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ZOrder)<<1)^uint32((*m.ZOrder>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaDiamondShop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaDiamondShop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaDiamondShop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Price != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Price)<<1)^uint32((*m.Price>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.CostType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CostType)<<1)^uint32((*m.CostType>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Num != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Num)<<1)^uint32((*m.Num>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.ItemID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ItemID)<<1)^uint32((*m.ItemID>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaParkBreak) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaParkBreak) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaParkBreak) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Sound != nil {
		i -= len(m.Sound)
		copy(dAtA[i:], m.Sound)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Sound)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ValueList) > 0 {
		for iNdEx := len(m.ValueList) - 1; iNdEx >= 0; iNdEx-- {
			x11 := (uint32(m.ValueList[iNdEx]) << 1) ^ uint32((m.ValueList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x11))
			i--
			dAtA[i] = 0x30
		}
	}
	if m.Effect != nil {
		i -= len(m.Effect)
		copy(dAtA[i:], m.Effect)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Effect)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Res != nil {
		i -= len(m.Res)
		copy(dAtA[i:], m.Res)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Res)))
		i--
		dAtA[i] = 0x22
	}
	if m.DescID != nil {
		i -= len(m.DescID)
		copy(dAtA[i:], m.DescID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DescID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaParkCar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaParkCar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaParkCar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShowOffset != nil {
		{
			size, err := m.ShowOffset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ParkOffset != nil {
		{
			size, err := m.ParkOffset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.SayYesReduceMaxParkTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SayYesReduceMaxParkTime)<<1)^uint32((*m.SayYesReduceMaxParkTime>>31))))
		i--
		dAtA[i] = 0x68
	}
	if m.AddParkUnitBenefitRate != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.AddParkUnitBenefitRate))))
		i--
		dAtA[i] = 0x65
	}
	if m.ParkUnitBenefit != nil {
		{
			size, err := m.ParkUnitBenefit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.DecomposeGetCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.DecomposeGetCount)<<1)^uint32((*m.DecomposeGetCount>>31))))
		i--
		dAtA[i] = 0x50
	}
	if m.RepairCostCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.RepairCostCount)<<1)^uint32((*m.RepairCostCount>>31))))
		i--
		dAtA[i] = 0x48
	}
	if m.LastProtectValue != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.LastProtectValue)<<1)^uint32((*m.LastProtectValue>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.ProtectValue != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ProtectValue)<<1)^uint32((*m.ProtectValue>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.ParkTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkTime)<<1)^uint32((*m.ParkTime>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.MaxLevel)<<1)^uint32((*m.MaxLevel>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.Quality != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Quality)<<1)^uint32((*m.Quality>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Icon != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Icon)<<1)^uint32((*m.Icon>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaPetPassiveTalent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaPetPassiveTalent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaPetPassiveTalent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ValueList) > 0 {
		for iNdEx := len(m.ValueList) - 1; iNdEx >= 0; iNdEx-- {
			x15 := (uint32(m.ValueList[iNdEx]) << 1) ^ uint32((m.ValueList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x15))
			i--
			dAtA[i] = 0x40
		}
	}
	if len(m.ArgList) > 0 {
		for iNdEx := len(m.ArgList) - 1; iNdEx >= 0; iNdEx-- {
			x16 := (uint32(m.ArgList[iNdEx]) << 1) ^ uint32((m.ArgList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x16))
			i--
			dAtA[i] = 0x38
		}
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Weight != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Weight)<<1)^uint32((*m.Weight>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.IconId != nil {
		i -= len(m.IconId)
		copy(dAtA[i:], m.IconId)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.IconId)))
		i--
		dAtA[i] = 0x22
	}
	if m.TalentDesId != nil {
		i -= len(m.TalentDesId)
		copy(dAtA[i:], m.TalentDesId)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.TalentDesId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TalentId != nil {
		i -= len(m.TalentId)
		copy(dAtA[i:], m.TalentId)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.TalentId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaEquipManual) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaEquipManual) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaEquipManual) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Reward != nil {
		{
			size, err := m.Reward.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Num != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Num)<<1)^uint32((*m.Num>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaMinigameShop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaMinigameShop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaMinigameShop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Price != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Price)<<1)^uint32((*m.Price>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.CostType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CostType)<<1)^uint32((*m.CostType>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Num != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Num)<<1)^uint32((*m.Num>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.ItemID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ItemID)<<1)^uint32((*m.ItemID>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaTransInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaTransInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaTransInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Rect) > 0 {
		for iNdEx := len(m.Rect) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rect[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TargetID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.TargetID)<<1)^uint32((*m.TargetID>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaSkill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaSkill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.HurtTypeData) > 0 {
		for iNdEx := len(m.HurtTypeData) - 1; iNdEx >= 0; iNdEx-- {
			x18 := (uint32(m.HurtTypeData[iNdEx]) << 1) ^ uint32((m.HurtTypeData[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x18))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x98
		}
	}
	if m.HurtSound != nil {
		i -= len(m.HurtSound)
		copy(dAtA[i:], m.HurtSound)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.HurtSound)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if len(m.FixHurtList) > 0 {
		for iNdEx := len(m.FixHurtList) - 1; iNdEx >= 0; iNdEx-- {
			x19 := (uint32(m.FixHurtList[iNdEx]) << 1) ^ uint32((m.FixHurtList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x19))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x88
		}
	}
	if len(m.PerHurtList) > 0 {
		for iNdEx := len(m.PerHurtList) - 1; iNdEx >= 0; iNdEx-- {
			x20 := (uint32(m.PerHurtList[iNdEx]) << 1) ^ uint32((m.PerHurtList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x20))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x80
		}
	}
	if m.DamageType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.DamageType)<<1)^uint32((*m.DamageType>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if len(m.EndBuffList) > 0 {
		for iNdEx := len(m.EndBuffList) - 1; iNdEx >= 0; iNdEx-- {
			x21 := (uint32(m.EndBuffList[iNdEx]) << 1) ^ uint32((m.EndBuffList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x21))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf0
		}
	}
	if len(m.EndBuffTargetList) > 0 {
		for iNdEx := len(m.EndBuffTargetList) - 1; iNdEx >= 0; iNdEx-- {
			x22 := (uint32(m.EndBuffTargetList[iNdEx]) << 1) ^ uint32((m.EndBuffTargetList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x22))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe8
		}
	}
	if len(m.StartBuffList) > 0 {
		for iNdEx := len(m.StartBuffList) - 1; iNdEx >= 0; iNdEx-- {
			x23 := (uint32(m.StartBuffList[iNdEx]) << 1) ^ uint32((m.StartBuffList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x23))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe0
		}
	}
	if len(m.StartBuffTargetList) > 0 {
		for iNdEx := len(m.StartBuffTargetList) - 1; iNdEx >= 0; iNdEx-- {
			x24 := (uint32(m.StartBuffTargetList[iNdEx]) << 1) ^ uint32((m.StartBuffTargetList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x24))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd8
		}
	}
	if m.DisType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.DisType)<<1)^uint32((*m.DisType>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.TargetType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.TargetType)<<1)^uint32((*m.TargetType>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.AtkEndTime != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.AtkEndTime))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc5
	}
	if len(m.ShakeTimeList) > 0 {
		for iNdEx := len(m.ShakeTimeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShakeTimeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.AtkSoundList) > 0 {
		for iNdEx := len(m.AtkSoundList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AtkSoundList[iNdEx])
			copy(dAtA[i:], m.AtkSoundList[iNdEx])
			i = encodeVarintServerDef(dAtA, i, uint64(len(m.AtkSoundList[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.AtkHurtPerList) > 0 {
		for iNdEx := len(m.AtkHurtPerList) - 1; iNdEx >= 0; iNdEx-- {
			x25 := (uint32(m.AtkHurtPerList[iNdEx]) << 1) ^ uint32((m.AtkHurtPerList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x25))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa8
		}
	}
	if len(m.AtkTimeList) > 0 {
		for iNdEx := len(m.AtkTimeList) - 1; iNdEx >= 0; iNdEx-- {
			f26 := math.Float32bits(float32(m.AtkTimeList[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f26))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa5
		}
	}
	if m.AtkAnim != nil {
		i -= len(m.AtkAnim)
		copy(dAtA[i:], m.AtkAnim)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.AtkAnim)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.FlyAnim != nil {
		i -= len(m.FlyAnim)
		copy(dAtA[i:], m.FlyAnim)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.FlyAnim)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.PreTime != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.PreTime))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8d
	}
	if m.PreAnim != nil {
		i -= len(m.PreAnim)
		copy(dAtA[i:], m.PreAnim)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.PreAnim)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ResIndex != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ResIndex)<<1)^uint32((*m.ResIndex>>31))))
		i--
		dAtA[i] = 0x78
	}
	if len(m.HurtEffIDList) > 0 {
		for iNdEx := len(m.HurtEffIDList) - 1; iNdEx >= 0; iNdEx-- {
			x27 := (uint32(m.HurtEffIDList[iNdEx]) << 1) ^ uint32((m.HurtEffIDList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x27))
			i--
			dAtA[i] = 0x70
		}
	}
	if len(m.FlyEffIDList) > 0 {
		for iNdEx := len(m.FlyEffIDList) - 1; iNdEx >= 0; iNdEx-- {
			x28 := (uint32(m.FlyEffIDList[iNdEx]) << 1) ^ uint32((m.FlyEffIDList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x28))
			i--
			dAtA[i] = 0x68
		}
	}
	if m.AtkSound != nil {
		i -= len(m.AtkSound)
		copy(dAtA[i:], m.AtkSound)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.AtkSound)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.PreDefEffList) > 0 {
		for iNdEx := len(m.PreDefEffList) - 1; iNdEx >= 0; iNdEx-- {
			x29 := (uint32(m.PreDefEffList[iNdEx]) << 1) ^ uint32((m.PreDefEffList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x29))
			i--
			dAtA[i] = 0x58
		}
	}
	if len(m.PreAtkEffList) > 0 {
		for iNdEx := len(m.PreAtkEffList) - 1; iNdEx >= 0; iNdEx-- {
			x30 := (uint32(m.PreAtkEffList[iNdEx]) << 1) ^ uint32((m.PreAtkEffList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x30))
			i--
			dAtA[i] = 0x50
		}
	}
	if len(m.DefEffList) > 0 {
		for iNdEx := len(m.DefEffList) - 1; iNdEx >= 0; iNdEx-- {
			x31 := (uint32(m.DefEffList[iNdEx]) << 1) ^ uint32((m.DefEffList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x31))
			i--
			dAtA[i] = 0x48
		}
	}
	if len(m.AtkEffList) > 0 {
		for iNdEx := len(m.AtkEffList) - 1; iNdEx >= 0; iNdEx-- {
			x32 := (uint32(m.AtkEffList[iNdEx]) << 1) ^ uint32((m.AtkEffList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x32))
			i--
			dAtA[i] = 0x40
		}
	}
	if len(m.EventValList) > 0 {
		for iNdEx := len(m.EventValList) - 1; iNdEx >= 0; iNdEx-- {
			x33 := (uint32(m.EventValList[iNdEx]) << 1) ^ uint32((m.EventValList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x33))
			i--
			dAtA[i] = 0x38
		}
	}
	if len(m.EventConList) > 0 {
		for iNdEx := len(m.EventConList) - 1; iNdEx >= 0; iNdEx-- {
			x34 := (uint32(m.EventConList[iNdEx]) << 1) ^ uint32((m.EventConList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x34))
			i--
			dAtA[i] = 0x30
		}
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.ArmaType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ArmaType)<<1)^uint32((*m.ArmaType>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.DescID != nil {
		i -= len(m.DescID)
		copy(dAtA[i:], m.DescID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DescID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaBuyStamina) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaBuyStamina) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaBuyStamina) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Diamond != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Diamond)<<1)^uint32((*m.Diamond>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaGuadraticBoss) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaGuadraticBoss) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaGuadraticBoss) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SkillList) > 0 {
		for iNdEx := len(m.SkillList) - 1; iNdEx >= 0; iNdEx-- {
			x35 := (uint32(m.SkillList[iNdEx]) << 1) ^ uint32((m.SkillList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x35))
			i--
			dAtA[i] = 0x50
		}
	}
	if m.EnterSound != nil {
		i -= len(m.EnterSound)
		copy(dAtA[i:], m.EnterSound)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.EnterSound)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Res != nil {
		i -= len(m.Res)
		copy(dAtA[i:], m.Res)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Res)))
		i--
		dAtA[i] = 0x42
	}
	if m.EnterHurtSize != nil {
		{
			size, err := m.EnterHurtSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.EnterHurt != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EnterHurt)<<1)^uint32((*m.EnterHurt>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.EnterTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EnterTime)<<1)^uint32((*m.EnterTime>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.MoveSpeed != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.MoveSpeed)<<1)^uint32((*m.MoveSpeed>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.ExitType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ExitType)<<1)^uint32((*m.ExitType>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.EnterType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EnterType)<<1)^uint32((*m.EnterType>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaVipSale) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaVipSale) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaVipSale) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IapSuffix != nil {
		i -= len(m.IapSuffix)
		copy(dAtA[i:], m.IapSuffix)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.IapSuffix)))
		i--
		dAtA[i] = 0x42
	}
	if m.IapID != nil {
		i -= len(m.IapID)
		copy(dAtA[i:], m.IapID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.IapID)))
		i--
		dAtA[i] = 0x3a
	}
	if m.FirstExtraDiamond != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FirstExtraDiamond)<<1)^uint32((*m.FirstExtraDiamond>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.FirstFlag != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FirstFlag)<<1)^uint32((*m.FirstFlag>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.ExtraDiamond != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ExtraDiamond)<<1)^uint32((*m.ExtraDiamond>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.BaseDiamond != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BaseDiamond)<<1)^uint32((*m.BaseDiamond>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.Price != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Price)<<1)^uint32((*m.Price>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaZuipao) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaZuipao) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaZuipao) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SkillLevelList) > 0 {
		for iNdEx := len(m.SkillLevelList) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintServerDef(dAtA, i, uint64(m.SkillLevelList[iNdEx]))
			i--
			dAtA[i] = 0x30
		}
	}
	if m.AddEnergyPercent != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.AddEnergyPercent))))
		i--
		dAtA[i] = 0x2d
	}
	if m.NeedLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.NeedLevel)<<1)^uint32((*m.NeedLevel>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.FaceCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FaceCount)<<1)^uint32((*m.FaceCount>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.SkillID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SkillID)<<1)^uint32((*m.SkillID>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaParkShopRandom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaParkShopRandom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaParkShopRandom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ItemIdList) > 0 {
		for iNdEx := len(m.ItemIdList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemIdList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaNiudan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaNiudan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaNiudan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TextDesID != nil {
		i -= len(m.TextDesID)
		copy(dAtA[i:], m.TextDesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.TextDesID)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.TextProb) > 0 {
		for iNdEx := len(m.TextProb) - 1; iNdEx >= 0; iNdEx-- {
			x37 := (uint32(m.TextProb[iNdEx]) << 1) ^ uint32((m.TextProb[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x37))
			i--
			dAtA[i] = 0x38
		}
	}
	if len(m.TextQuality) > 0 {
		for iNdEx := len(m.TextQuality) - 1; iNdEx >= 0; iNdEx-- {
			x38 := (uint32(m.TextQuality[iNdEx]) << 1) ^ uint32((m.TextQuality[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x38))
			i--
			dAtA[i] = 0x30
		}
	}
	if len(m.ButtonList) > 0 {
		for iNdEx := len(m.ButtonList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ButtonList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Markshow != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Markshow)<<1)^uint32((*m.Markshow>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Showspeed != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Showspeed)<<1)^uint32((*m.Showspeed>>31))))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PreviewReward) > 0 {
		for iNdEx := len(m.PreviewReward) - 1; iNdEx >= 0; iNdEx-- {
			x39 := (uint32(m.PreviewReward[iNdEx]) << 1) ^ uint32((m.PreviewReward[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x39))
			i--
			dAtA[i] = 0x10
		}
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaPet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaPet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaPet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Weight != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Weight)<<1)^uint32((*m.Weight>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.MaxLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.MaxLevel)<<1)^uint32((*m.MaxLevel>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.TopPos != nil {
		{
			size, err := m.TopPos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.HitPos != nil {
		{
			size, err := m.HitPos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.BoundingBox != nil {
		{
			size, err := m.BoundingBox.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.HurtPauseFrame != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.HurtPauseFrame)<<1)^uint32((*m.HurtPauseFrame>>31))))
		i--
		dAtA[i] = 0x78
	}
	if m.DiedSound != nil {
		i -= len(m.DiedSound)
		copy(dAtA[i:], m.DiedSound)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DiedSound)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.ActSkillProbList) > 0 {
		for iNdEx := len(m.ActSkillProbList) - 1; iNdEx >= 0; iNdEx-- {
			x43 := (uint32(m.ActSkillProbList[iNdEx]) << 1) ^ uint32((m.ActSkillProbList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x43))
			i--
			dAtA[i] = 0x68
		}
	}
	if len(m.ActSkillList) > 0 {
		for iNdEx := len(m.ActSkillList) - 1; iNdEx >= 0; iNdEx-- {
			x44 := (uint32(m.ActSkillList[iNdEx]) << 1) ^ uint32((m.ActSkillList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x44))
			i--
			dAtA[i] = 0x60
		}
	}
	if len(m.ActNormalList) > 0 {
		for iNdEx := len(m.ActNormalList) - 1; iNdEx >= 0; iNdEx-- {
			x45 := (uint32(m.ActNormalList[iNdEx]) << 1) ^ uint32((m.ActNormalList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x45))
			i--
			dAtA[i] = 0x58
		}
	}
	if m.Res != nil {
		i -= len(m.Res)
		copy(dAtA[i:], m.Res)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Res)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.EvolveCostList) > 0 {
		for iNdEx := len(m.EvolveCostList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EvolveCostList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.EvolvePetId != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EvolvePetId)<<1)^uint32((*m.EvolvePetId>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.EvolveLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EvolveLevel)<<1)^uint32((*m.EvolveLevel>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.SkillIcon != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SkillIcon)<<1)^uint32((*m.SkillIcon>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.IconID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IconID)<<1)^uint32((*m.IconID>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.PaintID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.PaintID)<<1)^uint32((*m.PaintID>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.DesID != nil {
		i -= len(m.DesID)
		copy(dAtA[i:], m.DesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DesID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaParkPlace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaParkPlace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaParkPlace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SceneID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SceneID)<<1)^uint32((*m.SceneID>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaRoleCreate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaRoleCreate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaRoleCreate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.WingList) > 0 {
		for iNdEx := len(m.WingList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WingList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.WeaponList) > 0 {
		for iNdEx := len(m.WeaponList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WeaponList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.FaceList) > 0 {
		for iNdEx := len(m.FaceList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FaceList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.HatList) > 0 {
		for iNdEx := len(m.HatList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HatList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaNiudanShopRandom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaNiudanShopRandom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaNiudanShopRandom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ItemIdList) > 0 {
		for iNdEx := len(m.ItemIdList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemIdList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaSkillShopRandom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaSkillShopRandom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaSkillShopRandom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ItemIdList) > 0 {
		for iNdEx := len(m.ItemIdList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemIdList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GetTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.GetTime)<<1)^uint32((*m.GetTime>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.IsResetTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IsResetTime)<<1)^uint32((*m.IsResetTime>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxRate != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.MaxRate)<<1)^uint32((*m.MaxRate>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.MiniRate != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.MiniRate)<<1)^uint32((*m.MiniRate>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Count != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Count)<<1)^uint32((*m.Count>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.ItemID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ItemID)<<1)^uint32((*m.ItemID>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaPetTalentLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaPetTalentLevel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaPetTalentLevel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PassiveLevelList) > 0 {
		for iNdEx := len(m.PassiveLevelList) - 1; iNdEx >= 0; iNdEx-- {
			x46 := (uint32(m.PassiveLevelList[iNdEx]) << 1) ^ uint32((m.PassiveLevelList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x46))
			i--
			dAtA[i] = 0x18
		}
	}
	if len(m.ActLevelList) > 0 {
		for iNdEx := len(m.ActLevelList) - 1; iNdEx >= 0; iNdEx-- {
			x47 := (uint32(m.ActLevelList[iNdEx]) << 1) ^ uint32((m.ActLevelList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x47))
			i--
			dAtA[i] = 0x10
		}
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaNotable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaNotable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaNotable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DesID != nil {
		i -= len(m.DesID)
		copy(dAtA[i:], m.DesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DesID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ParameterList) > 0 {
		for iNdEx := len(m.ParameterList) - 1; iNdEx >= 0; iNdEx-- {
			x48 := (uint32(m.ParameterList[iNdEx]) << 1) ^ uint32((m.ParameterList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x48))
			i--
			dAtA[i] = 0x10
		}
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaFace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaFace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaFace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Speed != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Speed)<<1)^uint32((*m.Speed>>31))))
		i--
		dAtA[i] = 0x50
	}
	if m.Block != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Block)<<1)^uint32((*m.Block>>31))))
		i--
		dAtA[i] = 0x48
	}
	if m.Crit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Crit)<<1)^uint32((*m.Crit>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.Def != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Def)<<1)^uint32((*m.Def>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.Hp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Hp)<<1)^uint32((*m.Hp>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Atk != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Atk)<<1)^uint32((*m.Atk>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.ResID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ResID)<<1)^uint32((*m.ResID>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.DesID != nil {
		i -= len(m.DesID)
		copy(dAtA[i:], m.DesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DesID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaDailyTask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaDailyTask) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaDailyTask) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SubTaskList) > 0 {
		for iNdEx := len(m.SubTaskList) - 1; iNdEx >= 0; iNdEx-- {
			x49 := (uint32(m.SubTaskList[iNdEx]) << 1) ^ uint32((m.SubTaskList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x49))
			i--
			dAtA[i] = 0x10
		}
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaArenaNpc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaArenaNpc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaArenaNpc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Dif != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Dif)<<1)^uint32((*m.Dif>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.Pos != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Pos)<<1)^uint32((*m.Pos>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Temp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Temp)<<1)^uint32((*m.Temp>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.Name != nil {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Rank != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Rank)<<1)^uint32((*m.Rank>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaCard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaCard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BuffList) > 0 {
		for iNdEx := len(m.BuffList) - 1; iNdEx >= 0; iNdEx-- {
			x50 := (uint32(m.BuffList[iNdEx]) << 1) ^ uint32((m.BuffList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x50))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa0
		}
	}
	if len(m.BuffTargetList) > 0 {
		for iNdEx := len(m.BuffTargetList) - 1; iNdEx >= 0; iNdEx-- {
			x51 := (uint32(m.BuffTargetList[iNdEx]) << 1) ^ uint32((m.BuffTargetList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x51))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x98
		}
	}
	if m.FixValue != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FixValue)<<1)^uint32((*m.FixValue>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.PerValue != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.PerValue)<<1)^uint32((*m.PerValue>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.HurtEffList) > 0 {
		for iNdEx := len(m.HurtEffList) - 1; iNdEx >= 0; iNdEx-- {
			x52 := (uint32(m.HurtEffList[iNdEx]) << 1) ^ uint32((m.HurtEffList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x52))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x80
		}
	}
	if m.AtkEndTime != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.AtkEndTime))))
		i--
		dAtA[i] = 0x7d
	}
	if len(m.AtkHurtPerList) > 0 {
		for iNdEx := len(m.AtkHurtPerList) - 1; iNdEx >= 0; iNdEx-- {
			x53 := (uint32(m.AtkHurtPerList[iNdEx]) << 1) ^ uint32((m.AtkHurtPerList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x53))
			i--
			dAtA[i] = 0x70
		}
	}
	if len(m.AtkTimeList) > 0 {
		for iNdEx := len(m.AtkTimeList) - 1; iNdEx >= 0; iNdEx-- {
			f54 := math.Float32bits(float32(m.AtkTimeList[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f54))
			i--
			dAtA[i] = 0x6d
		}
	}
	if m.ReleasePos != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ReleasePos)<<1)^uint32((*m.ReleasePos>>31))))
		i--
		dAtA[i] = 0x60
	}
	if m.ReleaseEffID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ReleaseEffID)<<1)^uint32((*m.ReleaseEffID>>31))))
		i--
		dAtA[i] = 0x58
	}
	if m.TargetCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.TargetCount)<<1)^uint32((*m.TargetCount>>31))))
		i--
		dAtA[i] = 0x50
	}
	if m.TargetType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.TargetType)<<1)^uint32((*m.TargetType>>31))))
		i--
		dAtA[i] = 0x48
	}
	if m.GroupIcon != nil {
		i -= len(m.GroupIcon)
		copy(dAtA[i:], m.GroupIcon)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.GroupIcon)))
		i--
		dAtA[i] = 0x42
	}
	if m.Icon != nil {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x3a
	}
	if m.NeedEnergy != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.NeedEnergy)<<1)^uint32((*m.NeedEnergy>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Quality != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Quality)<<1)^uint32((*m.Quality>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.DescID != nil {
		i -= len(m.DescID)
		copy(dAtA[i:], m.DescID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DescID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaHangup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaHangup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaHangup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UnitExp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.UnitExp)<<1)^uint32((*m.UnitExp>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.UnitTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.UnitTime)<<1)^uint32((*m.UnitTime>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.TimeUplimit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.TimeUplimit)<<1)^uint32((*m.TimeUplimit>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaDiamondShopRandom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaDiamondShopRandom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaDiamondShopRandom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ItemIdList) > 0 {
		for iNdEx := len(m.ItemIdList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemIdList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaNiudanShop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaNiudanShop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaNiudanShop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Price != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Price)<<1)^uint32((*m.Price>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.CostType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CostType)<<1)^uint32((*m.CostType>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Num != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Num)<<1)^uint32((*m.Num>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.ItemID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ItemID)<<1)^uint32((*m.ItemID>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaSuitShop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaSuitShop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaSuitShop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Price) > 0 {
		for iNdEx := len(m.Price) - 1; iNdEx >= 0; iNdEx-- {
			x55 := (uint32(m.Price[iNdEx]) << 1) ^ uint32((m.Price[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x55))
			i--
			dAtA[i] = 0x28
		}
	}
	if m.CostType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CostType)<<1)^uint32((*m.CostType>>31))))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Duration) > 0 {
		for iNdEx := len(m.Duration) - 1; iNdEx >= 0; iNdEx-- {
			x56 := (uint32(m.Duration[iNdEx]) << 1) ^ uint32((m.Duration[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x56))
			i--
			dAtA[i] = 0x18
		}
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Index)<<1)^uint32((*m.Index>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaRisk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaRisk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaRisk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FightCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FightCount)<<1)^uint32((*m.FightCount>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.SuggestFight != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SuggestFight)<<1)^uint32((*m.SuggestFight>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if len(m.FirstDropItemList) > 0 {
		for iNdEx := len(m.FirstDropItemList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FirstDropItemList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if m.Icon != nil {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.GetRewardList) > 0 {
		for iNdEx := len(m.GetRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GetRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.ShowRewardList) > 0 {
		for iNdEx := len(m.ShowRewardList) - 1; iNdEx >= 0; iNdEx-- {
			x57 := (uint32(m.ShowRewardList[iNdEx]) << 1) ^ uint32((m.ShowRewardList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x57))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa8
		}
	}
	if m.BossBoxID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BossBoxID)<<1)^uint32((*m.BossBoxID>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.MonsterBoxID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.MonsterBoxID)<<1)^uint32((*m.MonsterBoxID>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.DropRang) > 0 {
		for iNdEx := len(m.DropRang) - 1; iNdEx >= 0; iNdEx-- {
			x58 := (uint32(m.DropRang[iNdEx]) << 1) ^ uint32((m.DropRang[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x58))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x90
		}
	}
	if m.StartScreen != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.StartScreen)<<1)^uint32((*m.StartScreen>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.MapID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.MapID)<<1)^uint32((*m.MapID>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.LimitTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.LimitTime)<<1)^uint32((*m.LimitTime>>31))))
		i--
		dAtA[i] = 0x78
	}
	if m.LoseCondType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.LoseCondType)<<1)^uint32((*m.LoseCondType>>31))))
		i--
		dAtA[i] = 0x70
	}
	if len(m.WinArgList) > 0 {
		for iNdEx := len(m.WinArgList) - 1; iNdEx >= 0; iNdEx-- {
			x59 := (uint32(m.WinArgList[iNdEx]) << 1) ^ uint32((m.WinArgList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x59))
			i--
			dAtA[i] = 0x68
		}
	}
	if len(m.WinCondList) > 0 {
		for iNdEx := len(m.WinCondList) - 1; iNdEx >= 0; iNdEx-- {
			x60 := (uint32(m.WinCondList[iNdEx]) << 1) ^ uint32((m.WinCondList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x60))
			i--
			dAtA[i] = 0x60
		}
	}
	if len(m.OpenDupList) > 0 {
		for iNdEx := len(m.OpenDupList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OpenDupList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.OpenLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.OpenLevel)<<1)^uint32((*m.OpenLevel>>31))))
		i--
		dAtA[i] = 0x50
	}
	if m.LoseCostStamina != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.LoseCostStamina)<<1)^uint32((*m.LoseCostStamina>>31))))
		i--
		dAtA[i] = 0x48
	}
	if m.WinCostStamina != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.WinCostStamina)<<1)^uint32((*m.WinCostStamina>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.ShowType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ShowType)<<1)^uint32((*m.ShowType>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Boss != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Boss)<<1)^uint32((*m.Boss>>31))))
		i--
		dAtA[i] = 0x28
	}
	if len(m.WaveList) > 0 {
		for iNdEx := len(m.WaveList) - 1; iNdEx >= 0; iNdEx-- {
			x61 := (uint32(m.WaveList[iNdEx]) << 1) ^ uint32((m.WaveList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x61))
			i--
			dAtA[i] = 0x20
		}
	}
	if m.DesID != nil {
		i -= len(m.DesID)
		copy(dAtA[i:], m.DesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DesID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaGuadraticLevelReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaGuadraticLevelReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaGuadraticLevelReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaBlackShopRandom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaBlackShopRandom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaBlackShopRandom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ItemIdList) > 0 {
		for iNdEx := len(m.ItemIdList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemIdList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaBlackShop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaBlackShop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaBlackShop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Price != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Price)<<1)^uint32((*m.Price>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.CostType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CostType)<<1)^uint32((*m.CostType>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Num != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Num)<<1)^uint32((*m.Num>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.ItemID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ItemID)<<1)^uint32((*m.ItemID>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaSceneFail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaSceneFail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaSceneFail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ReturnBornPosList) > 0 {
		for iNdEx := len(m.ReturnBornPosList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReturnBornPosList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ReturnSceneId != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ReturnSceneId)<<1)^uint32((*m.ReturnSceneId>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.TrySceneId != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.TrySceneId)<<1)^uint32((*m.TrySceneId>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.SrcSceneId != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SrcSceneId)<<1)^uint32((*m.SrcSceneId>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaBathFightStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaBathFightStep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaBathFightStep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BroadcastTimeStep != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BroadcastTimeStep)<<1)^uint32((*m.BroadcastTimeStep>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.IsWatersplash != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IsWatersplash)<<1)^uint32((*m.IsWatersplash>>31))))
		i--
		dAtA[i] = 0x28
	}
	if len(m.NewInteractToolList) > 0 {
		for iNdEx := len(m.NewInteractToolList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NewInteractToolList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.NextStepCount != nil {
		{
			size, err := m.NextStepCount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CdTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CdTime)<<1)^uint32((*m.CdTime>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Step != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Step)<<1)^uint32((*m.Step>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaBathToolType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaBathToolType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaBathToolType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UseCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.UseCount)<<1)^uint32((*m.UseCount>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaArenaTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaArenaTemplate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaArenaTemplate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CardList) > 0 {
		for iNdEx := len(m.CardList) - 1; iNdEx >= 0; iNdEx-- {
			x63 := (uint32(m.CardList[iNdEx]) << 1) ^ uint32((m.CardList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x63))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa0
		}
	}
	if m.SuitSkillPropLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SuitSkillPropLevel)<<1)^uint32((*m.SuitSkillPropLevel>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.SuitSkillLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SuitSkillLevel)<<1)^uint32((*m.SuitSkillLevel>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.SuitSkillID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SuitSkillID)<<1)^uint32((*m.SuitSkillID>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.SkillPropLevelList) > 0 {
		for iNdEx := len(m.SkillPropLevelList) - 1; iNdEx >= 0; iNdEx-- {
			x64 := (uint32(m.SkillPropLevelList[iNdEx]) << 1) ^ uint32((m.SkillPropLevelList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x64))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x80
		}
	}
	if len(m.SkillLevelList) > 0 {
		for iNdEx := len(m.SkillLevelList) - 1; iNdEx >= 0; iNdEx-- {
			x65 := (uint32(m.SkillLevelList[iNdEx]) << 1) ^ uint32((m.SkillLevelList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x65))
			i--
			dAtA[i] = 0x78
		}
	}
	if len(m.SkillList) > 0 {
		for iNdEx := len(m.SkillList) - 1; iNdEx >= 0; iNdEx-- {
			x66 := (uint32(m.SkillList[iNdEx]) << 1) ^ uint32((m.SkillList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x66))
			i--
			dAtA[i] = 0x70
		}
	}
	if m.WingID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.WingID)<<1)^uint32((*m.WingID>>31))))
		i--
		dAtA[i] = 0x68
	}
	if m.HatID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.HatID)<<1)^uint32((*m.HatID>>31))))
		i--
		dAtA[i] = 0x60
	}
	if m.WeaponID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.WeaponID)<<1)^uint32((*m.WeaponID>>31))))
		i--
		dAtA[i] = 0x58
	}
	if m.FaceID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FaceID)<<1)^uint32((*m.FaceID>>31))))
		i--
		dAtA[i] = 0x50
	}
	if m.SuitID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SuitID)<<1)^uint32((*m.SuitID>>31))))
		i--
		dAtA[i] = 0x48
	}
	if m.Act != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Act)<<1)^uint32((*m.Act>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.Speed != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Speed)<<1)^uint32((*m.Speed>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.Block != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Block)<<1)^uint32((*m.Block>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Crit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Crit)<<1)^uint32((*m.Crit>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.Hp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Hp)<<1)^uint32((*m.Hp>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Def != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Def)<<1)^uint32((*m.Def>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.Atk != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Atk)<<1)^uint32((*m.Atk>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaBathFightEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaBathFightEnd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaBathFightEnd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			x67 := (uint32(m.RewardList[iNdEx]) << 1) ^ uint32((m.RewardList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x67))
			i--
			dAtA[i] = 0x20
		}
	}
	if len(m.EndConditionList) > 0 {
		for iNdEx := len(m.EndConditionList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EndConditionList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.CdTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CdTime)<<1)^uint32((*m.CdTime>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaBathStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaBathStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaBathStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Fullness != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Fullness)<<1)^uint32((*m.Fullness>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Exp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Exp)<<1)^uint32((*m.Exp>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.Stamina != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Stamina)<<1)^uint32((*m.Stamina>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.TypeRatio != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.TypeRatio)<<1)^uint32((*m.TypeRatio>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaStoneExchange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaStoneExchange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaStoneExchange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NeedItem != nil {
		{
			size, err := m.NeedItem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ItemId != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ItemId)<<1)^uint32((*m.ItemId>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaMinigameRank) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaMinigameRank) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaMinigameRank) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DisplayInfoList) > 0 {
		for iNdEx := len(m.DisplayInfoList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DisplayInfoList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaFriendLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaFriendLevel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaFriendLevel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Speed != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Speed)<<1)^uint32((*m.Speed>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.Block != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Block)<<1)^uint32((*m.Block>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Crit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Crit)<<1)^uint32((*m.Crit>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.Def != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Def)<<1)^uint32((*m.Def>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Atk != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Atk)<<1)^uint32((*m.Atk>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.Hp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Hp)<<1)^uint32((*m.Hp>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Lvl != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Lvl)<<1)^uint32((*m.Lvl>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaMinigameLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaMinigameLevel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaMinigameLevel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaGuadraticDup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaGuadraticDup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaGuadraticDup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Music != nil {
		i -= len(m.Music)
		copy(dAtA[i:], m.Music)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Music)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.BornPosList) > 0 {
		for iNdEx := len(m.BornPosList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BornPosList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.DataFile != nil {
		i -= len(m.DataFile)
		copy(dAtA[i:], m.DataFile)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DataFile)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.MapList) > 0 {
		for iNdEx := len(m.MapList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MapList[iNdEx])
			copy(dAtA[i:], m.MapList[iNdEx])
			i = encodeVarintServerDef(dAtA, i, uint64(len(m.MapList[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.BossEnterRect) > 0 {
		for iNdEx := len(m.BossEnterRect) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BossEnterRect[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BossEnterList) > 0 {
		for iNdEx := len(m.BossEnterList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BossEnterList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.MapSize != nil {
		{
			size, err := m.MapSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Time != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Time)<<1)^uint32((*m.Time>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaMinigameScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaMinigameScore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaMinigameScore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Score != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Score)<<1)^uint32((*m.Score>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaArenaShopRandom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaArenaShopRandom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaArenaShopRandom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ItemIdList) > 0 {
		for iNdEx := len(m.ItemIdList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemIdList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaRoleLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaRoleLevel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaRoleLevel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Speed != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Speed)<<1)^uint32((*m.Speed>>31))))
		i--
		dAtA[i] = 0x50
	}
	if m.Block != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Block)<<1)^uint32((*m.Block>>31))))
		i--
		dAtA[i] = 0x48
	}
	if m.Crit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Crit)<<1)^uint32((*m.Crit>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.Def != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Def)<<1)^uint32((*m.Def>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.Atk != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Atk)<<1)^uint32((*m.Atk>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Hp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Hp)<<1)^uint32((*m.Hp>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.Stamina != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Stamina)<<1)^uint32((*m.Stamina>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.SkillPoint != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SkillPoint)<<1)^uint32((*m.SkillPoint>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.Exp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Exp)<<1)^uint32((*m.Exp>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Lvl != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Lvl)<<1)^uint32((*m.Lvl>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaArenaShop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaArenaShop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaArenaShop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Price != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Price)<<1)^uint32((*m.Price>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.CostType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CostType)<<1)^uint32((*m.CostType>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Num != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Num)<<1)^uint32((*m.Num>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.ItemID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ItemID)<<1)^uint32((*m.ItemID>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaAvatarConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaAvatarConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaAvatarConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Limit)<<1)^uint32((*m.Limit>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Cost != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Cost)<<1)^uint32((*m.Cost>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.Interval != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Interval)<<1)^uint32((*m.Interval>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.ShopID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ShopID)<<1)^uint32((*m.ShopID>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaPetLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaPetLevel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaPetLevel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HpLimit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.HpLimit)<<1)^uint32((*m.HpLimit>>31))))
		i--
		dAtA[i] = 0x70
	}
	if m.DefLimit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.DefLimit)<<1)^uint32((*m.DefLimit>>31))))
		i--
		dAtA[i] = 0x68
	}
	if m.AtkLimit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.AtkLimit)<<1)^uint32((*m.AtkLimit>>31))))
		i--
		dAtA[i] = 0x60
	}
	if m.Act != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Act)<<1)^uint32((*m.Act>>31))))
		i--
		dAtA[i] = 0x58
	}
	if m.Speed != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Speed)<<1)^uint32((*m.Speed>>31))))
		i--
		dAtA[i] = 0x50
	}
	if m.Block != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Block)<<1)^uint32((*m.Block>>31))))
		i--
		dAtA[i] = 0x48
	}
	if m.Crit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Crit)<<1)^uint32((*m.Crit>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.Hp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Hp)<<1)^uint32((*m.Hp>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.Def != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Def)<<1)^uint32((*m.Def>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Atk != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Atk)<<1)^uint32((*m.Atk>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.CritProb != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CritProb)<<1)^uint32((*m.CritProb>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Exp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Exp)<<1)^uint32((*m.Exp>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaFunctionOpen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaFunctionOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaFunctionOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TipTextList) > 0 {
		for iNdEx := len(m.TipTextList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TipTextList[iNdEx])
			copy(dAtA[i:], m.TipTextList[iNdEx])
			i = encodeVarintServerDef(dAtA, i, uint64(len(m.TipTextList[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.TipTextID != nil {
		i -= len(m.TipTextID)
		copy(dAtA[i:], m.TipTextID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.TipTextID)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.TipPicList) > 0 {
		for iNdEx := len(m.TipPicList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TipPicList[iNdEx])
			copy(dAtA[i:], m.TipPicList[iNdEx])
			i = encodeVarintServerDef(dAtA, i, uint64(len(m.TipPicList[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Icon != nil {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RiskList) > 0 {
		for iNdEx := len(m.RiskList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RiskList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.TaskList) > 0 {
		for iNdEx := len(m.TaskList) - 1; iNdEx >= 0; iNdEx-- {
			x70 := (uint32(m.TaskList[iNdEx]) << 1) ^ uint32((m.TaskList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x70))
			i--
			dAtA[i] = 0x30
		}
	}
	if m.Vip != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Vip)<<1)^uint32((*m.Vip>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Index != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Index)<<1)^uint32((*m.Index>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaMainTaskModule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaMainTaskModule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaMainTaskModule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ModuleType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ModuleType)<<1)^uint32((*m.ModuleType>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaHouseStorage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaHouseStorage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaHouseStorage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CostItem != nil {
		{
			size, err := m.CostItem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MaxCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.MaxCount)<<1)^uint32((*m.MaxCount>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaBuyBitcoin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaBuyBitcoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaBuyBitcoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CostIem != nil {
		{
			size, err := m.CostIem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BuyItem != nil {
		{
			size, err := m.BuyItem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaSword) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaSword) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaSword) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GodBagID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.GodBagID)<<1)^uint32((*m.GodBagID>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.BaseBagID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BaseBagID)<<1)^uint32((*m.BaseBagID>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.MaxLevel)<<1)^uint32((*m.MaxLevel>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.MinLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.MinLevel)<<1)^uint32((*m.MinLevel>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaArenaHistoryRank) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaArenaHistoryRank) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaArenaHistoryRank) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Rank != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Rank)<<1)^uint32((*m.Rank>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaBorn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaBorn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaBorn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PetIdList) > 0 {
		for iNdEx := len(m.PetIdList) - 1; iNdEx >= 0; iNdEx-- {
			x74 := (uint32(m.PetIdList[iNdEx]) << 1) ^ uint32((m.PetIdList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x74))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x80
		}
	}
	if len(m.DressSkillList) > 0 {
		for iNdEx := len(m.DressSkillList) - 1; iNdEx >= 0; iNdEx-- {
			x75 := (uint32(m.DressSkillList[iNdEx]) << 1) ^ uint32((m.DressSkillList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x75))
			i--
			dAtA[i] = 0x78
		}
	}
	if len(m.LearnSkillList) > 0 {
		for iNdEx := len(m.LearnSkillList) - 1; iNdEx >= 0; iNdEx-- {
			x76 := (uint32(m.LearnSkillList[iNdEx]) << 1) ^ uint32((m.LearnSkillList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x76))
			i--
			dAtA[i] = 0x70
		}
	}
	if len(m.InteractList) > 0 {
		for iNdEx := len(m.InteractList) - 1; iNdEx >= 0; iNdEx-- {
			x77 := (uint32(m.InteractList[iNdEx]) << 1) ^ uint32((m.InteractList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x77))
			i--
			dAtA[i] = 0x68
		}
	}
	if len(m.CarList) > 0 {
		for iNdEx := len(m.CarList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CarList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.SuitList) > 0 {
		for iNdEx := len(m.SuitList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SuitList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.FaceList) > 0 {
		for iNdEx := len(m.FaceList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FaceList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.ItemList) > 0 {
		for iNdEx := len(m.ItemList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Vip != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Vip)<<1)^uint32((*m.Vip>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.SkillPoint != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SkillPoint)<<1)^uint32((*m.SkillPoint>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Diamond != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Diamond)<<1)^uint32((*m.Diamond>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.Stamina != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Stamina)<<1)^uint32((*m.Stamina>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Gold != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Gold)<<1)^uint32((*m.Gold>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.SceneID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SceneID)<<1)^uint32((*m.SceneID>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaSignCost) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaSignCost) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaSignCost) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Cost != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Cost)<<1)^uint32((*m.Cost>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Count != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Count)<<1)^uint32((*m.Count>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaMinigame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaMinigame) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaMinigame) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Music != nil {
		i -= len(m.Music)
		copy(dAtA[i:], m.Music)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Music)))
		i--
		dAtA[i] = 0x4a
	}
	if m.CostCurrency != nil {
		{
			size, err := m.CostCurrency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Hide != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Hide)<<1)^uint32((*m.Hide>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.Border != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Border)<<1)^uint32((*m.Border>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Icon != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Icon)<<1)^uint32((*m.Icon>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.DesID != nil {
		i -= len(m.DesID)
		copy(dAtA[i:], m.DesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DesID)))
		i--
		dAtA[i] = 0x22
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SceneID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SceneID)<<1)^uint32((*m.SceneID>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaGuadraticReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaGuadraticReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaGuadraticReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DoubleDayPercent) > 0 {
		for iNdEx := len(m.DoubleDayPercent) - 1; iNdEx >= 0; iNdEx-- {
			x79 := (uint32(m.DoubleDayPercent[iNdEx]) << 1) ^ uint32((m.DoubleDayPercent[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x79))
			i--
			dAtA[i] = 0x28
		}
	}
	if len(m.SingleDayPercent) > 0 {
		for iNdEx := len(m.SingleDayPercent) - 1; iNdEx >= 0; iNdEx-- {
			x80 := (uint32(m.SingleDayPercent[iNdEx]) << 1) ^ uint32((m.SingleDayPercent[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x80))
			i--
			dAtA[i] = 0x20
		}
	}
	if len(m.DoubleDayRewardList) > 0 {
		for iNdEx := len(m.DoubleDayRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DoubleDayRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SingleDayRewardList) > 0 {
		for iNdEx := len(m.SingleDayRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SingleDayRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ID)<<1)^uint32((*m.ID>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaRiskFightReset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaRiskFightReset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaRiskFightReset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CostIem != nil {
		{
			size, err := m.CostIem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaEasterEgg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaEasterEgg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaEasterEgg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GlobalType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.GlobalType)<<1)^uint32((*m.GlobalType>>31))))
		i--
		dAtA[i] = 0x78
	}
	if m.SuccessSound != nil {
		i -= len(m.SuccessSound)
		copy(dAtA[i:], m.SuccessSound)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.SuccessSound)))
		i--
		dAtA[i] = 0x72
	}
	if m.SuccessAnimName != nil {
		i -= len(m.SuccessAnimName)
		copy(dAtA[i:], m.SuccessAnimName)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.SuccessAnimName)))
		i--
		dAtA[i] = 0x6a
	}
	if m.TouchSound != nil {
		i -= len(m.TouchSound)
		copy(dAtA[i:], m.TouchSound)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.TouchSound)))
		i--
		dAtA[i] = 0x62
	}
	if m.TouchAnimName != nil {
		i -= len(m.TouchAnimName)
		copy(dAtA[i:], m.TouchAnimName)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.TouchAnimName)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.FirstRewardList) > 0 {
		for iNdEx := len(m.FirstRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FirstRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.DayGetCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.DayGetCount)<<1)^uint32((*m.DayGetCount>>31))))
		i--
		dAtA[i] = 0x48
	}
	if m.CdTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CdTime)<<1)^uint32((*m.CdTime>>31))))
		i--
		dAtA[i] = 0x40
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Probability != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Probability)<<1)^uint32((*m.Probability>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.AffectCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.AffectCount)<<1)^uint32((*m.AffectCount>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.NeedTouchCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.NeedTouchCount)<<1)^uint32((*m.NeedTouchCount>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.NpcID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.NpcID)<<1)^uint32((*m.NpcID>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.SceneID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SceneID)<<1)^uint32((*m.SceneID>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaEquipMake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaEquipMake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaEquipMake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Prop != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Prop)<<1)^uint32((*m.Prop>>31))))
		i--
		dAtA[i] = 0x50
	}
	if m.EquipIdTwo != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EquipIdTwo)<<1)^uint32((*m.EquipIdTwo>>31))))
		i--
		dAtA[i] = 0x48
	}
	if m.EquipIdOne != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EquipIdOne)<<1)^uint32((*m.EquipIdOne>>31))))
		i--
		dAtA[i] = 0x40
	}
	if len(m.CaseTwoItemList) > 0 {
		for iNdEx := len(m.CaseTwoItemList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CaseTwoItemList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CaseOneItemList) > 0 {
		for iNdEx := len(m.CaseOneItemList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CaseOneItemList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Site != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Site)<<1)^uint32((*m.Site>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.Quality != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Quality)<<1)^uint32((*m.Quality>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.OpenLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.OpenLevel)<<1)^uint32((*m.OpenLevel>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaRoleSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaRoleSkill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaRoleSkill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Quality != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Quality)<<1)^uint32((*m.Quality>>31))))
		i--
		dAtA[i] = 0x70
	}
	if m.ShowType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ShowType)<<1)^uint32((*m.ShowType>>31))))
		i--
		dAtA[i] = 0x68
	}
	if len(m.UpItemList) > 0 {
		for iNdEx := len(m.UpItemList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UpItemList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.ProfiList) > 0 {
		for iNdEx := len(m.ProfiList) - 1; iNdEx >= 0; iNdEx-- {
			x82 := (uint32(m.ProfiList[iNdEx]) << 1) ^ uint32((m.ProfiList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x82))
			i--
			dAtA[i] = 0x58
		}
	}
	if len(m.RateList) > 0 {
		for iNdEx := len(m.RateList) - 1; iNdEx >= 0; iNdEx-- {
			x83 := (uint32(m.RateList[iNdEx]) << 1) ^ uint32((m.RateList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x83))
			i--
			dAtA[i] = 0x50
		}
	}
	if len(m.LearnItemList) > 0 {
		for iNdEx := len(m.LearnItemList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LearnItemList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.OpenLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.OpenLevel)<<1)^uint32((*m.OpenLevel>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.Icon != nil {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SpecialLevelList) > 0 {
		for iNdEx := len(m.SpecialLevelList) - 1; iNdEx >= 0; iNdEx-- {
			x84 := (uint32(m.SpecialLevelList[iNdEx]) << 1) ^ uint32((m.SpecialLevelList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x84))
			i--
			dAtA[i] = 0x28
		}
	}
	if len(m.SkillLevelList) > 0 {
		for iNdEx := len(m.SkillLevelList) - 1; iNdEx >= 0; iNdEx-- {
			x85 := (uint32(m.SkillLevelList[iNdEx]) << 1) ^ uint32((m.SkillLevelList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x85))
			i--
			dAtA[i] = 0x20
		}
	}
	if m.DesID != nil {
		i -= len(m.DesID)
		copy(dAtA[i:], m.DesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DesID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaDailyActivityGrowReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaDailyActivityGrowReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaDailyActivityGrowReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.BaseReward != nil {
		{
			size, err := m.BaseReward.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaEquipFix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaEquipFix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaEquipFix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FastFixCost != nil {
		{
			size, err := m.FastFixCost.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.EveryNeedTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EveryNeedTime)<<1)^uint32((*m.EveryNeedTime>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.EveryNeedNum != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EveryNeedNum)<<1)^uint32((*m.EveryNeedNum>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.FixNeedItemId != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FixNeedItemId)<<1)^uint32((*m.FixNeedItemId>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Quality != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Quality)<<1)^uint32((*m.Quality>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaNiudanPackage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaNiudanPackage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaNiudanPackage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PackageList) > 0 {
		for iNdEx := len(m.PackageList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PackageList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.LevelSection != nil {
		{
			size, err := m.LevelSection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaTransport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaTransport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaTransport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UnlockPos) > 0 {
		for iNdEx := len(m.UnlockPos) - 1; iNdEx >= 0; iNdEx-- {
			x89 := (uint32(m.UnlockPos[iNdEx]) << 1) ^ uint32((m.UnlockPos[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x89))
			i--
			dAtA[i] = 0x58
		}
	}
	if m.UnlockRes != nil {
		i -= len(m.UnlockRes)
		copy(dAtA[i:], m.UnlockRes)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.UnlockRes)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.TargetList) > 0 {
		for iNdEx := len(m.TargetList) - 1; iNdEx >= 0; iNdEx-- {
			x90 := (uint32(m.TargetList[iNdEx]) << 1) ^ uint32((m.TargetList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x90))
			i--
			dAtA[i] = 0x48
		}
	}
	if m.Rotate != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Rotate)<<1)^uint32((*m.Rotate>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.IsFlipY != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IsFlipY)<<1)^uint32((*m.IsFlipY>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.IsFlipX != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IsFlipX)<<1)^uint32((*m.IsFlipX>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Res != nil {
		i -= len(m.Res)
		copy(dAtA[i:], m.Res)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Res)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ResType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ResType)<<1)^uint32((*m.ResType>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Pos != nil {
		{
			size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaGuadraticBossSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaGuadraticBossSkill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaGuadraticBossSkill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SelfEffectRes != nil {
		i -= len(m.SelfEffectRes)
		copy(dAtA[i:], m.SelfEffectRes)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.SelfEffectRes)))
		i--
		dAtA[i] = 0x4a
	}
	if m.EffectRes != nil {
		i -= len(m.EffectRes)
		copy(dAtA[i:], m.EffectRes)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.EffectRes)))
		i--
		dAtA[i] = 0x42
	}
	if m.AnimName != nil {
		i -= len(m.AnimName)
		copy(dAtA[i:], m.AnimName)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.AnimName)))
		i--
		dAtA[i] = 0x3a
	}
	if m.PreTime != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.PreTime))))
		i--
		dAtA[i] = 0x35
	}
	if m.AtkSound != nil {
		i -= len(m.AtkSound)
		copy(dAtA[i:], m.AtkSound)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.AtkSound)))
		i--
		dAtA[i] = 0x2a
	}
	if m.HurtRect != nil {
		{
			size, err := m.HurtRect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Hurt != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Hurt)<<1)^uint32((*m.Hurt>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.AtkDistance != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.AtkDistance)<<1)^uint32((*m.AtkDistance>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaSkillHole) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaSkillHole) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaSkillHole) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UnlockVipLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.UnlockVipLevel)<<1)^uint32((*m.UnlockVipLevel>>31))))
		i--
		dAtA[i] = 0x18
	}
	if len(m.UnlockItemList) > 0 {
		for iNdEx := len(m.UnlockItemList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UnlockItemList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaRandomBox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaRandomBox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaRandomBox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RewardID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.RewardID)<<1)^uint32((*m.RewardID>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.MaxLevel)<<1)^uint32((*m.MaxLevel>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.MinLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.MinLevel)<<1)^uint32((*m.MinLevel>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaCommonShop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaCommonShop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaCommonShop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CellNum != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CellNum)<<1)^uint32((*m.CellNum>>31))))
		i--
		dAtA[i] = 0x78
	}
	if m.UpdateDesID != nil {
		i -= len(m.UpdateDesID)
		copy(dAtA[i:], m.UpdateDesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.UpdateDesID)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.PriceList) > 0 {
		for iNdEx := len(m.PriceList) - 1; iNdEx >= 0; iNdEx-- {
			x93 := (uint32(m.PriceList[iNdEx]) << 1) ^ uint32((m.PriceList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x93))
			i--
			dAtA[i] = 0x68
		}
	}
	if len(m.LimitTimeList) > 0 {
		for iNdEx := len(m.LimitTimeList) - 1; iNdEx >= 0; iNdEx-- {
			x94 := (uint32(m.LimitTimeList[iNdEx]) << 1) ^ uint32((m.LimitTimeList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x94))
			i--
			dAtA[i] = 0x60
		}
	}
	if len(m.FixTimeList) > 0 {
		for iNdEx := len(m.FixTimeList) - 1; iNdEx >= 0; iNdEx-- {
			x95 := (uint32(m.FixTimeList[iNdEx]) << 1) ^ uint32((m.FixTimeList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x95))
			i--
			dAtA[i] = 0x58
		}
	}
	if len(m.WeekdayList) > 0 {
		for iNdEx := len(m.WeekdayList) - 1; iNdEx >= 0; iNdEx-- {
			x96 := (uint32(m.WeekdayList[iNdEx]) << 1) ^ uint32((m.WeekdayList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x96))
			i--
			dAtA[i] = 0x50
		}
	}
	if m.Period != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Period)<<1)^uint32((*m.Period>>31))))
		i--
		dAtA[i] = 0x48
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.Pos != nil {
		{
			size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Scale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Scale))))
		i--
		dAtA[i] = 0x35
	}
	if m.Icon != nil {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ResType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ResType)<<1)^uint32((*m.ResType>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.TalkID != nil {
		i -= len(m.TalkID)
		copy(dAtA[i:], m.TalkID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.TalkID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaParkItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaParkItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaParkItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ValueList) > 0 {
		for iNdEx := len(m.ValueList) - 1; iNdEx >= 0; iNdEx-- {
			x98 := (uint32(m.ValueList[iNdEx]) << 1) ^ uint32((m.ValueList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x98))
			i--
			dAtA[i] = 0x20
		}
	}
	if m.EffectType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EffectType)<<1)^uint32((*m.EffectType>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.ItemID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ItemID)<<1)^uint32((*m.ItemID>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaDailySubtask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaDailySubtask) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaDailySubtask) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Activity != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Activity)<<1)^uint32((*m.Activity>>31))))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Reward) > 0 {
		for iNdEx := len(m.Reward) - 1; iNdEx >= 0; iNdEx-- {
			x99 := (uint32(m.Reward[iNdEx]) << 1) ^ uint32((m.Reward[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x99))
			i--
			dAtA[i] = 0x28
		}
	}
	if m.ConditionValue != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ConditionValue)<<1)^uint32((*m.ConditionValue>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.ConditionType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ConditionType)<<1)^uint32((*m.ConditionType>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.DesID != nil {
		i -= len(m.DesID)
		copy(dAtA[i:], m.DesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DesID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaInteraction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaInteraction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaInteraction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConsumerMusic != nil {
		i -= len(m.ConsumerMusic)
		copy(dAtA[i:], m.ConsumerMusic)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.ConsumerMusic)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.IsMusicLoop != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IsMusicLoop)<<1)^uint32((*m.IsMusicLoop>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.InitiatorMusic != nil {
		i -= len(m.InitiatorMusic)
		copy(dAtA[i:], m.InitiatorMusic)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.InitiatorMusic)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.InteractToolType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.InteractToolType)<<1)^uint32((*m.InteractToolType>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if len(m.EffectOtherList) > 0 {
		for iNdEx := len(m.EffectOtherList) - 1; iNdEx >= 0; iNdEx-- {
			x100 := (uint32(m.EffectOtherList[iNdEx]) << 1) ^ uint32((m.EffectOtherList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x100))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc0
		}
	}
	if len(m.EffectSelfList) > 0 {
		for iNdEx := len(m.EffectSelfList) - 1; iNdEx >= 0; iNdEx-- {
			x101 := (uint32(m.EffectSelfList[iNdEx]) << 1) ^ uint32((m.EffectSelfList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x101))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb8
		}
	}
	if m.CdTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CdTime)<<1)^uint32((*m.CdTime>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.Size_) > 0 {
		for iNdEx := len(m.Size_) - 1; iNdEx >= 0; iNdEx-- {
			x102 := (uint32(m.Size_[iNdEx]) << 1) ^ uint32((m.Size_[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x102))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa8
		}
	}
	if m.Radius != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Radius)<<1)^uint32((*m.Radius>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.EffectType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EffectType)<<1)^uint32((*m.EffectType>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.DeltaPos) > 0 {
		for iNdEx := len(m.DeltaPos) - 1; iNdEx >= 0; iNdEx-- {
			x103 := (uint32(m.DeltaPos[iNdEx]) << 1) ^ uint32((m.DeltaPos[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x103))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x90
		}
	}
	if m.ConsumerAction != nil {
		i -= len(m.ConsumerAction)
		copy(dAtA[i:], m.ConsumerAction)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.ConsumerAction)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.ConsumerCSB != nil {
		i -= len(m.ConsumerCSB)
		copy(dAtA[i:], m.ConsumerCSB)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.ConsumerCSB)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ConsumerEffect != nil {
		i -= len(m.ConsumerEffect)
		copy(dAtA[i:], m.ConsumerEffect)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.ConsumerEffect)))
		i--
		dAtA[i] = 0x7a
	}
	if m.ConsumerTime != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.ConsumerTime))))
		i--
		dAtA[i] = 0x75
	}
	if m.ConsumerType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ConsumerType)<<1)^uint32((*m.ConsumerType>>31))))
		i--
		dAtA[i] = 0x68
	}
	if m.LoopType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.LoopType)<<1)^uint32((*m.LoopType>>31))))
		i--
		dAtA[i] = 0x60
	}
	if m.InitiatorEffectFail != nil {
		i -= len(m.InitiatorEffectFail)
		copy(dAtA[i:], m.InitiatorEffectFail)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.InitiatorEffectFail)))
		i--
		dAtA[i] = 0x5a
	}
	if m.InitiatorEffect != nil {
		i -= len(m.InitiatorEffect)
		copy(dAtA[i:], m.InitiatorEffect)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.InitiatorEffect)))
		i--
		dAtA[i] = 0x52
	}
	if m.InitiatorAction2 != nil {
		i -= len(m.InitiatorAction2)
		copy(dAtA[i:], m.InitiatorAction2)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.InitiatorAction2)))
		i--
		dAtA[i] = 0x4a
	}
	if m.InitiatorAction != nil {
		i -= len(m.InitiatorAction)
		copy(dAtA[i:], m.InitiatorAction)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.InitiatorAction)))
		i--
		dAtA[i] = 0x42
	}
	if m.InitiatorCSB != nil {
		i -= len(m.InitiatorCSB)
		copy(dAtA[i:], m.InitiatorCSB)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.InitiatorCSB)))
		i--
		dAtA[i] = 0x3a
	}
	if m.IconID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IconID)<<1)^uint32((*m.IconID>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.UnlockDesID != nil {
		i -= len(m.UnlockDesID)
		copy(dAtA[i:], m.UnlockDesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.UnlockDesID)))
		i--
		dAtA[i] = 0x2a
	}
	if m.NameAct != nil {
		i -= len(m.NameAct)
		copy(dAtA[i:], m.NameAct)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameAct)))
		i--
		dAtA[i] = 0x22
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaGiftBag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaGiftBag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaGiftBag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.RandomCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.RandomCount)<<1)^uint32((*m.RandomCount>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaMinigameShopRandom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaMinigameShopRandom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaMinigameShopRandom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ItemIdList) > 0 {
		for iNdEx := len(m.ItemIdList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemIdList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaSwordResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaSwordResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaSwordResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ResultList) > 0 {
		for iNdEx := len(m.ResultList) - 1; iNdEx >= 0; iNdEx-- {
			x104 := (uint32(m.ResultList[iNdEx]) << 1) ^ uint32((m.ResultList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x104))
			i--
			dAtA[i] = 0x20
		}
	}
	if len(m.EventList) > 0 {
		for iNdEx := len(m.EventList) - 1; iNdEx >= 0; iNdEx-- {
			x105 := (uint32(m.EventList[iNdEx]) << 1) ^ uint32((m.EventList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x105))
			i--
			dAtA[i] = 0x18
		}
	}
	if len(m.RateList) > 0 {
		for iNdEx := len(m.RateList) - 1; iNdEx >= 0; iNdEx-- {
			x106 := (uint32(m.RateList[iNdEx]) << 1) ^ uint32((m.RateList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x106))
			i--
			dAtA[i] = 0x10
		}
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaNpcInteract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaNpcInteract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaNpcInteract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MutexIDList) > 0 {
		for iNdEx := len(m.MutexIDList) - 1; iNdEx >= 0; iNdEx-- {
			x107 := (uint32(m.MutexIDList[iNdEx]) << 1) ^ uint32((m.MutexIDList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x107))
			i--
			dAtA[i] = 0x48
		}
	}
	if m.IsAudioEffectAll != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IsAudioEffectAll)<<1)^uint32((*m.IsAudioEffectAll>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.IsMusic != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IsMusic)<<1)^uint32((*m.IsMusic>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.Sound != nil {
		i -= len(m.Sound)
		copy(dAtA[i:], m.Sound)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Sound)))
		i--
		dAtA[i] = 0x32
	}
	if m.Pos != nil {
		{
			size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ActionTime != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.ActionTime))))
		i--
		dAtA[i] = 0x25
	}
	if m.CdTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CdTime)<<1)^uint32((*m.CdTime>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.IsRepeat != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IsRepeat)<<1)^uint32((*m.IsRepeat>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.NpcID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.NpcID)<<1)^uint32((*m.NpcID>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaFaceLvl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaFaceLvl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaFaceLvl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LockLvl != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.LockLvl)<<1)^uint32((*m.LockLvl>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.DesID != nil {
		i -= len(m.DesID)
		copy(dAtA[i:], m.DesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DesID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Count != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Count)<<1)^uint32((*m.Count>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaEquipBag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaEquipBag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaEquipBag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cost) > 0 {
		for iNdEx := len(m.Cost) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cost[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.UpLimit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.UpLimit)<<1)^uint32((*m.UpLimit>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaMainTask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaMainTask) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaMainTask) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CanGiveUp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CanGiveUp)<<1)^uint32((*m.CanGiveUp>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.AcceptRewardList) > 0 {
		for iNdEx := len(m.AcceptRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AcceptRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.NpcID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.NpcID)<<1)^uint32((*m.NpcID>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.OnlineTotalTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.OnlineTotalTime)<<1)^uint32((*m.OnlineTotalTime>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.BathWashTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BathWashTime)<<1)^uint32((*m.BathWashTime>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.ArenaOkTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ArenaOkTime)<<1)^uint32((*m.ArenaOkTime>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.InteractNpcList) > 0 {
		for iNdEx := len(m.InteractNpcList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InteractNpcList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.InteractTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.InteractTime)<<1)^uint32((*m.InteractTime>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x78
	}
	if m.KillCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.KillCount)<<1)^uint32((*m.KillCount>>31))))
		i--
		dAtA[i] = 0x70
	}
	if m.FriendCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FriendCount)<<1)^uint32((*m.FriendCount>>31))))
		i--
		dAtA[i] = 0x68
	}
	if len(m.RiskID) > 0 {
		for iNdEx := len(m.RiskID) - 1; iNdEx >= 0; iNdEx-- {
			x109 := (uint32(m.RiskID[iNdEx]) << 1) ^ uint32((m.RiskID[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x109))
			i--
			dAtA[i] = 0x60
		}
	}
	if m.FuncID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FuncID)<<1)^uint32((*m.FuncID>>31))))
		i--
		dAtA[i] = 0x58
	}
	if len(m.NexIDList) > 0 {
		for iNdEx := len(m.NexIDList) - 1; iNdEx >= 0; iNdEx-- {
			x110 := (uint32(m.NexIDList[iNdEx]) << 1) ^ uint32((m.NexIDList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x110))
			i--
			dAtA[i] = 0x50
		}
	}
	if m.IsHasPreTask != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IsHasPreTask)<<1)^uint32((*m.IsHasPreTask>>31))))
		i--
		dAtA[i] = 0x48
	}
	if len(m.CompleteIf) > 0 {
		for iNdEx := len(m.CompleteIf) - 1; iNdEx >= 0; iNdEx-- {
			x111 := (uint32(m.CompleteIf[iNdEx]) << 1) ^ uint32((m.CompleteIf[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x111))
			i--
			dAtA[i] = 0x40
		}
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.DesID != nil {
		i -= len(m.DesID)
		copy(dAtA[i:], m.DesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DesID)))
		i--
		dAtA[i] = 0x32
	}
	if m.CompleteTalkID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CompleteTalkID)<<1)^uint32((*m.CompleteTalkID>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.NexTalkID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.NexTalkID)<<1)^uint32((*m.NexTalkID>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.PreTalkID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.PreTalkID)<<1)^uint32((*m.PreTalkID>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaExchangeGold) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaExchangeGold) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaExchangeGold) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GetGold) > 0 {
		for iNdEx := len(m.GetGold) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GetGold[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.CountDiamond != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CountDiamond)<<1)^uint32((*m.CountDiamond>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Time != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Time)<<1)^uint32((*m.Time>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaSuit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaSuit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaSuit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Speed != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Speed)<<1)^uint32((*m.Speed>>31))))
		i--
		dAtA[i] = 0x58
	}
	if m.Block != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Block)<<1)^uint32((*m.Block>>31))))
		i--
		dAtA[i] = 0x50
	}
	if m.Crit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Crit)<<1)^uint32((*m.Crit>>31))))
		i--
		dAtA[i] = 0x48
	}
	if m.Def != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Def)<<1)^uint32((*m.Def>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.Hp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Hp)<<1)^uint32((*m.Hp>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.Atk != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Atk)<<1)^uint32((*m.Atk>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.ResID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ResID)<<1)^uint32((*m.ResID>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.IsSpecial != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IsSpecial)<<1)^uint32((*m.IsSpecial>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.DesID != nil {
		i -= len(m.DesID)
		copy(dAtA[i:], m.DesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DesID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaGlobalConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaGlobalConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaGlobalConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DailyGameItemList) > 0 {
		for iNdEx := len(m.DailyGameItemList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DailyGameItemList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.FightParameter) > 0 {
		for iNdEx := len(m.FightParameter) - 1; iNdEx >= 0; iNdEx-- {
			x112 := (uint32(m.FightParameter[iNdEx]) << 1) ^ uint32((m.FightParameter[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x112))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xd8
		}
	}
	if len(m.PerLevelAttr) > 0 {
		for iNdEx := len(m.PerLevelAttr) - 1; iNdEx >= 0; iNdEx-- {
			x113 := (uint32(m.PerLevelAttr[iNdEx]) << 1) ^ uint32((m.PerLevelAttr[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x113))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xd0
		}
	}
	if len(m.InitRoleAttr) > 0 {
		for iNdEx := len(m.InitRoleAttr) - 1; iNdEx >= 0; iNdEx-- {
			x114 := (uint32(m.InitRoleAttr[iNdEx]) << 1) ^ uint32((m.InitRoleAttr[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x114))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xc8
		}
	}
	if m.GoldFaceNum != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.GoldFaceNum)<<1)^uint32((*m.GoldFaceNum>>31))))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc0
	}
	if m.DiamondFaceNum != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.DiamondFaceNum)<<1)^uint32((*m.DiamondFaceNum>>31))))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb8
	}
	if m.PvpDefRate != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.PvpDefRate))))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb5
	}
	if m.PvpAtkRate != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.PvpAtkRate))))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xad
	}
	if m.UnlockBattleSpeedLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.UnlockBattleSpeedLevel)<<1)^uint32((*m.UnlockBattleSpeedLevel>>31))))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.PianoTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.PianoTime)<<1)^uint32((*m.PianoTime>>31))))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x98
	}
	if m.FriendNumLimit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FriendNumLimit)<<1)^uint32((*m.FriendNumLimit>>31))))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x90
	}
	if len(m.PetEggReturnItemList) > 0 {
		for iNdEx := len(m.PetEggReturnItemList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PetEggReturnItemList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.RechargeLimit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint64(*m.RechargeLimit)<<1)^uint64((*m.RechargeLimit>>63))))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x80
	}
	if len(m.WeixinRewardList) > 0 {
		for iNdEx := len(m.WeixinRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WeixinRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xfa
		}
	}
	if len(m.FirstSaveMoneryRewardList) > 0 {
		for iNdEx := len(m.FirstSaveMoneryRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FirstSaveMoneryRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xf2
		}
	}
	if m.SellBagGridMaxNum != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SellBagGridMaxNum)<<1)^uint32((*m.SellBagGridMaxNum>>31))))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xe8
	}
	if m.FaceDupReturnItem != nil {
		{
			size, err := m.FaceDupReturnItem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xe2
	}
	if m.MinigameRankNum != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.MinigameRankNum)<<1)^uint32((*m.MinigameRankNum>>31))))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd8
	}
	if m.DiamondRankNum != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.DiamondRankNum)<<1)^uint32((*m.DiamondRankNum>>31))))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd0
	}
	if m.KillRankNum != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.KillRankNum)<<1)^uint32((*m.KillRankNum>>31))))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xc8
	}
	if m.LevelRankNum != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.LevelRankNum)<<1)^uint32((*m.LevelRankNum>>31))))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xc0
	}
	if m.GuadraticHurt != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.GuadraticHurt)<<1)^uint32((*m.GuadraticHurt>>31))))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xb8
	}
	if m.GuadraticHP != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.GuadraticHP)<<1)^uint32((*m.GuadraticHP>>31))))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xb0
	}
	if m.GuadraticUnderAtkCD != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.GuadraticUnderAtkCD)<<1)^uint32((*m.GuadraticUnderAtkCD>>31))))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xa8
	}
	if m.GuadraticAtkCD != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.GuadraticAtkCD)<<1)^uint32((*m.GuadraticAtkCD>>31))))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xa0
	}
	if m.GuadraticEndHurt != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.GuadraticEndHurt)<<1)^uint32((*m.GuadraticEndHurt>>31))))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x98
	}
	if m.GuadraticEndHurtCD != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.GuadraticEndHurtCD)<<1)^uint32((*m.GuadraticEndHurtCD>>31))))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x90
	}
	if m.GuadraticQuitCD != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.GuadraticQuitCD)<<1)^uint32((*m.GuadraticQuitCD>>31))))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x88
	}
	if m.GuadraticStartCDTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.GuadraticStartCDTime)<<1)^uint32((*m.GuadraticStartCDTime>>31))))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if len(m.GuadraticOpenTimeList) > 0 {
		for iNdEx := len(m.GuadraticOpenTimeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GuadraticOpenTimeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xfa
		}
	}
	if m.GuadraticCost != nil {
		{
			size, err := m.GuadraticCost.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf2
	}
	if m.GuadraticMaxCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.GuadraticMaxCount)<<1)^uint32((*m.GuadraticMaxCount>>31))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xe8
	}
	if m.GuadraticMaxRole != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.GuadraticMaxRole)<<1)^uint32((*m.GuadraticMaxRole>>31))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xe0
	}
	if m.GreenHatGap != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.GreenHatGap)<<1)^uint32((*m.GreenHatGap>>31))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xd8
	}
	if m.GreenHatLimit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.GreenHatLimit)<<1)^uint32((*m.GreenHatLimit>>31))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xd0
	}
	if m.FightFriendTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FightFriendTime)<<1)^uint32((*m.FightFriendTime>>31))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xc8
	}
	if len(m.CannonPosList) > 0 {
		for iNdEx := len(m.CannonPosList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CannonPosList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xc2
		}
	}
	if m.CaliburnCountLimit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CaliburnCountLimit)<<1)^uint32((*m.CaliburnCountLimit>>31))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb8
	}
	if m.HorseInterval != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.HorseInterval))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb5
	}
	if m.HorseSpeed != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.HorseSpeed)<<1)^uint32((*m.HorseSpeed>>31))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xa8
	}
	if len(m.ForeverUploadHeadImageCostList) > 0 {
		for iNdEx := len(m.ForeverUploadHeadImageCostList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForeverUploadHeadImageCostList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.UploadHeadImageCostList) > 0 {
		for iNdEx := len(m.UploadHeadImageCostList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UploadHeadImageCostList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.PetRefreshTimeList) > 0 {
		for iNdEx := len(m.PetRefreshTimeList) - 1; iNdEx >= 0; iNdEx-- {
			x117 := (uint32(m.PetRefreshTimeList[iNdEx]) << 1) ^ uint32((m.PetRefreshTimeList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x117))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x90
		}
	}
	if m.CostInterval != nil {
		{
			size, err := m.CostInterval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x8a
	}
	if len(m.PetTalentRebuildCostList) > 0 {
		for iNdEx := len(m.PetTalentRebuildCostList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PetTalentRebuildCostList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x82
		}
	}
	if m.ChargeSkillBookItemID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ChargeSkillBookItemID)<<1)^uint32((*m.ChargeSkillBookItemID>>31))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf8
	}
	if len(m.AddSwordItemList) > 0 {
		for iNdEx := len(m.AddSwordItemList) - 1; iNdEx >= 0; iNdEx-- {
			x119 := (uint32(m.AddSwordItemList[iNdEx]) << 1) ^ uint32((m.AddSwordItemList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x119))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xf0
		}
	}
	if len(m.BathOnceTimeList) > 0 {
		for iNdEx := len(m.BathOnceTimeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BathOnceTimeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xea
		}
	}
	if m.BathRecoveryInterval != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BathRecoveryInterval)<<1)^uint32((*m.BathRecoveryInterval>>31))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if m.BathRecoveryUpperLimit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BathRecoveryUpperLimit)<<1)^uint32((*m.BathRecoveryUpperLimit>>31))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd8
	}
	if len(m.HangupRestrictList) > 0 {
		for iNdEx := len(m.HangupRestrictList) - 1; iNdEx >= 0; iNdEx-- {
			x120 := (uint32(m.HangupRestrictList[iNdEx]) << 1) ^ uint32((m.HangupRestrictList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x120))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xd0
		}
	}
	if len(m.InteractNpcList) > 0 {
		for iNdEx := len(m.InteractNpcList) - 1; iNdEx >= 0; iNdEx-- {
			x121 := (uint32(m.InteractNpcList[iNdEx]) << 1) ^ uint32((m.InteractNpcList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x121))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xc8
		}
	}
	if m.CarPartID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CarPartID)<<1)^uint32((*m.CarPartID>>31))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	if m.ParkSayYesProb != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkSayYesProb)<<1)^uint32((*m.ParkSayYesProb>>31))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.ParkDetailMaxCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkDetailMaxCount)<<1)^uint32((*m.ParkDetailMaxCount>>31))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.ParkShopRefreshCarCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkShopRefreshCarCount)<<1)^uint32((*m.ParkShopRefreshCarCount>>31))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa8
	}
	if m.ParkStayTimeAfterFullTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkStayTimeAfterFullTime)<<1)^uint32((*m.ParkStayTimeAfterFullTime>>31))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if len(m.SystemParkRandomCaridList) > 0 {
		for iNdEx := len(m.SystemParkRandomCaridList) - 1; iNdEx >= 0; iNdEx-- {
			x122 := (uint32(m.SystemParkRandomCaridList[iNdEx]) << 1) ^ uint32((m.SystemParkRandomCaridList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x122))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x98
		}
	}
	if m.SystemParkByLeftCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SystemParkByLeftCount)<<1)^uint32((*m.SystemParkByLeftCount>>31))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.SystemParkMaxCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SystemParkMaxCount)<<1)^uint32((*m.SystemParkMaxCount>>31))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if m.SystemParkRefreshTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SystemParkRefreshTime)<<1)^uint32((*m.SystemParkRefreshTime>>31))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.ParkBreakGetRewardProb != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkBreakGetRewardProb)<<1)^uint32((*m.ParkBreakGetRewardProb>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.ParkSayYesGetRewardProb != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkSayYesGetRewardProb)<<1)^uint32((*m.ParkSayYesGetRewardProb>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.ParkGetRewardProb != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkGetRewardProb)<<1)^uint32((*m.ParkGetRewardProb>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.ParkBreakGetExp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkBreakGetExp)<<1)^uint32((*m.ParkBreakGetExp>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.ParkSayYesGetExp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkSayYesGetExp)<<1)^uint32((*m.ParkSayYesGetExp>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.ParkGetExpUnitTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkGetExpUnitTime)<<1)^uint32((*m.ParkGetExpUnitTime>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.ParkActRefreshTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkActRefreshTime)<<1)^uint32((*m.ParkActRefreshTime>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.ParkActCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkActCount)<<1)^uint32((*m.ParkActCount>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.ParkBreakGetBenefitRate != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.ParkBreakGetBenefitRate))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xbd
	}
	if m.FullParkRewardID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FullParkRewardID)<<1)^uint32((*m.FullParkRewardID>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.FullParkBenefitRate != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FullParkBenefitRate))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xad
	}
	if m.CarportProtectTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CarportProtectTime)<<1)^uint32((*m.CarportProtectTime>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.ParkBenefitUnitTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkBenefitUnitTime)<<1)^uint32((*m.ParkBenefitUnitTime>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.ParkSayYesLimitTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkSayYesLimitTime)<<1)^uint32((*m.ParkSayYesLimitTime>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.LastCarProtectTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.LastCarProtectTime)<<1)^uint32((*m.LastCarProtectTime>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.ItemReduceRepairCarTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ItemReduceRepairCarTime)<<1)^uint32((*m.ItemReduceRepairCarTime>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.FastRepairUseItemID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FastRepairUseItemID)<<1)^uint32((*m.FastRepairUseItemID>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.DiamondReduceRepairCarTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.DiamondReduceRepairCarTime)<<1)^uint32((*m.DiamondReduceRepairCarTime>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.ParkRepairUnitTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkRepairUnitTime)<<1)^uint32((*m.ParkRepairUnitTime>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.ParkBreakProtectCDTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkBreakProtectCDTime)<<1)^uint32((*m.ParkBreakProtectCDTime>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.ParkProtectCDTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkProtectCDTime)<<1)^uint32((*m.ParkProtectCDTime>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.ParkStopCDTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ParkStopCDTime)<<1)^uint32((*m.ParkStopCDTime>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.InitRepairCarCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.InitRepairCarCount)<<1)^uint32((*m.InitRepairCarCount>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.InitCarport != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.InitCarport)<<1)^uint32((*m.InitCarport>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.BathFullnessUpperlimit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BathFullnessUpperlimit)<<1)^uint32((*m.BathFullnessUpperlimit>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.RechargeExchangeScale != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.RechargeExchangeScale)<<1)^uint32((*m.RechargeExchangeScale>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.FriendAssistCdTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FriendAssistCdTime)<<1)^uint32((*m.FriendAssistCdTime>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.EquipDeclineParameter != nil {
		{
			size, err := m.EquipDeclineParameter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.EquipResolveReturnPercent != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EquipResolveReturnPercent)<<1)^uint32((*m.EquipResolveReturnPercent>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.EquipStrengthItemId != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EquipStrengthItemId)<<1)^uint32((*m.EquipStrengthItemId>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.ArenaDayRewardList) > 0 {
		for iNdEx := len(m.ArenaDayRewardList) - 1; iNdEx >= 0; iNdEx-- {
			x124 := (uint32(m.ArenaDayRewardList[iNdEx]) << 1) ^ uint32((m.ArenaDayRewardList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x124))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x88
		}
	}
	if m.FastTransItemID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FastTransItemID)<<1)^uint32((*m.FastTransItemID>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.ArenaClearCDCost != nil {
		{
			size, err := m.ArenaClearCDCost.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ArenaCD != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ArenaCD)<<1)^uint32((*m.ArenaCD>>31))))
		i--
		dAtA[i] = 0x70
	}
	if m.ArenaCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ArenaCount)<<1)^uint32((*m.ArenaCount>>31))))
		i--
		dAtA[i] = 0x68
	}
	if m.SwordCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SwordCount)<<1)^uint32((*m.SwordCount>>31))))
		i--
		dAtA[i] = 0x60
	}
	if len(m.SignShowList) > 0 {
		for iNdEx := len(m.SignShowList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SignShowList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.SignPakageID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SignPakageID)<<1)^uint32((*m.SignPakageID>>31))))
		i--
		dAtA[i] = 0x50
	}
	if m.SignDivisor != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SignDivisor)<<1)^uint32((*m.SignDivisor>>31))))
		i--
		dAtA[i] = 0x48
	}
	if m.SwordGodProb != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SwordGodProb)<<1)^uint32((*m.SwordGodProb>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.StaminaInterval != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.StaminaInterval)<<1)^uint32((*m.StaminaInterval>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.BuyGetStamina != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BuyGetStamina)<<1)^uint32((*m.BuyGetStamina>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.LevelUpStamina != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.LevelUpStamina)<<1)^uint32((*m.LevelUpStamina>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.SwordInterval != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SwordInterval)<<1)^uint32((*m.SwordInterval>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.ActArea != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ActArea)<<1)^uint32((*m.ActArea>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.SceneMoveSpeed != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SceneMoveSpeed)<<1)^uint32((*m.SceneMoveSpeed>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaInteractSystem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaInteractSystem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaInteractSystem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SortLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SortLevel)<<1)^uint32((*m.SortLevel>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.Size_) > 0 {
		for iNdEx := len(m.Size_) - 1; iNdEx >= 0; iNdEx-- {
			x126 := (uint32(m.Size_[iNdEx]) << 1) ^ uint32((m.Size_[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x126))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe8
		}
	}
	if m.Radius != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Radius)<<1)^uint32((*m.Radius>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.EffectType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EffectType)<<1)^uint32((*m.EffectType>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if len(m.DeltaPos) > 0 {
		for iNdEx := len(m.DeltaPos) - 1; iNdEx >= 0; iNdEx-- {
			x127 := (uint32(m.DeltaPos[iNdEx]) << 1) ^ uint32((m.DeltaPos[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x127))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd0
		}
	}
	if m.ConsumerSound != nil {
		i -= len(m.ConsumerSound)
		copy(dAtA[i:], m.ConsumerSound)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.ConsumerSound)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.ConsumerAction != nil {
		i -= len(m.ConsumerAction)
		copy(dAtA[i:], m.ConsumerAction)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.ConsumerAction)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.ConsumerCSB != nil {
		i -= len(m.ConsumerCSB)
		copy(dAtA[i:], m.ConsumerCSB)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.ConsumerCSB)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.ConsumerEffect != nil {
		i -= len(m.ConsumerEffect)
		copy(dAtA[i:], m.ConsumerEffect)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.ConsumerEffect)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.ColorRGB != nil {
		{
			size, err := m.ColorRGB.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.ColorDuration != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.ColorDuration))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa5
	}
	if m.ConsumerTime != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.ConsumerTime))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9d
	}
	if m.ConsumerType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ConsumerType)<<1)^uint32((*m.ConsumerType>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ConsumerHideEffect != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ConsumerHideEffect)<<1)^uint32((*m.ConsumerHideEffect>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.InitiatorHideEffect != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.InitiatorHideEffect)<<1)^uint32((*m.InitiatorHideEffect>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.LoopType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.LoopType)<<1)^uint32((*m.LoopType>>31))))
		i--
		dAtA[i] = 0x78
	}
	if m.InitiatorEffectFail != nil {
		i -= len(m.InitiatorEffectFail)
		copy(dAtA[i:], m.InitiatorEffectFail)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.InitiatorEffectFail)))
		i--
		dAtA[i] = 0x72
	}
	if m.InitiatorEffect != nil {
		i -= len(m.InitiatorEffect)
		copy(dAtA[i:], m.InitiatorEffect)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.InitiatorEffect)))
		i--
		dAtA[i] = 0x6a
	}
	if m.InitiatorAction2 != nil {
		i -= len(m.InitiatorAction2)
		copy(dAtA[i:], m.InitiatorAction2)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.InitiatorAction2)))
		i--
		dAtA[i] = 0x62
	}
	if m.InitiatorSound != nil {
		i -= len(m.InitiatorSound)
		copy(dAtA[i:], m.InitiatorSound)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.InitiatorSound)))
		i--
		dAtA[i] = 0x5a
	}
	if m.InitiatorAction != nil {
		i -= len(m.InitiatorAction)
		copy(dAtA[i:], m.InitiatorAction)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.InitiatorAction)))
		i--
		dAtA[i] = 0x52
	}
	if m.InitiatorCSB != nil {
		i -= len(m.InitiatorCSB)
		copy(dAtA[i:], m.InitiatorCSB)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.InitiatorCSB)))
		i--
		dAtA[i] = 0x4a
	}
	if m.IconID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IconID)<<1)^uint32((*m.IconID>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.EnergyPoint != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EnergyPoint)<<1)^uint32((*m.EnergyPoint>>31))))
		i--
		dAtA[i] = 0x38
	}
	if len(m.UnlockCondition) > 0 {
		for iNdEx := len(m.UnlockCondition) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UnlockCondition[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ActDesID != nil {
		i -= len(m.ActDesID)
		copy(dAtA[i:], m.ActDesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.ActDesID)))
		i--
		dAtA[i] = 0x2a
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ChildInteract) > 0 {
		for iNdEx := len(m.ChildInteract) - 1; iNdEx >= 0; iNdEx-- {
			x129 := (uint32(m.ChildInteract[iNdEx]) << 1) ^ uint32((m.ChildInteract[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x129))
			i--
			dAtA[i] = 0x18
		}
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaParkDriver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaParkDriver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaParkDriver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GetCarportCount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.GetCarportCount)<<1)^uint32((*m.GetCarportCount>>31))))
		i--
		dAtA[i] = 0x48
	}
	if len(m.RandomItemRange) > 0 {
		for iNdEx := len(m.RandomItemRange) - 1; iNdEx >= 0; iNdEx-- {
			x130 := (uint32(m.RandomItemRange[iNdEx]) << 1) ^ uint32((m.RandomItemRange[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x130))
			i--
			dAtA[i] = 0x40
		}
	}
	if len(m.SayYesExRewardItem) > 0 {
		for iNdEx := len(m.SayYesExRewardItem) - 1; iNdEx >= 0; iNdEx-- {
			x131 := (uint32(m.SayYesExRewardItem[iNdEx]) << 1) ^ uint32((m.SayYesExRewardItem[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x131))
			i--
			dAtA[i] = 0x38
		}
	}
	if len(m.SayYesGetRewardItem) > 0 {
		for iNdEx := len(m.SayYesGetRewardItem) - 1; iNdEx >= 0; iNdEx-- {
			x132 := (uint32(m.SayYesGetRewardItem[iNdEx]) << 1) ^ uint32((m.SayYesGetRewardItem[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x132))
			i--
			dAtA[i] = 0x30
		}
	}
	if len(m.SayYesProbList) > 0 {
		for iNdEx := len(m.SayYesProbList) - 1; iNdEx >= 0; iNdEx-- {
			x133 := (uint32(m.SayYesProbList[iNdEx]) << 1) ^ uint32((m.SayYesProbList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x133))
			i--
			dAtA[i] = 0x28
		}
	}
	if len(m.BreakGetRewardItem) > 0 {
		for iNdEx := len(m.BreakGetRewardItem) - 1; iNdEx >= 0; iNdEx-- {
			x134 := (uint32(m.BreakGetRewardItem[iNdEx]) << 1) ^ uint32((m.BreakGetRewardItem[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x134))
			i--
			dAtA[i] = 0x20
		}
	}
	if len(m.BreakProbList) > 0 {
		for iNdEx := len(m.BreakProbList) - 1; iNdEx >= 0; iNdEx-- {
			x135 := (uint32(m.BreakProbList[iNdEx]) << 1) ^ uint32((m.BreakProbList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x135))
			i--
			dAtA[i] = 0x18
		}
	}
	if m.Exp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Exp)<<1)^uint32((*m.Exp>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaHouseShop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaHouseShop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaHouseShop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsNew != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IsNew)<<1)^uint32((*m.IsNew>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.CostItem != nil {
		{
			size, err := m.CostItem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.NeedVipLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.NeedVipLevel)<<1)^uint32((*m.NeedVipLevel>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.NeedHouseLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.NeedHouseLevel)<<1)^uint32((*m.NeedHouseLevel>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.FurnitureID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FurnitureID)<<1)^uint32((*m.FurnitureID>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaFindwayGuid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaFindwayGuid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaFindwayGuid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LockRisk != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.LockRisk)<<1)^uint32((*m.LockRisk>>31))))
		i--
		dAtA[i] = 0x50
	}
	if m.FinishChapterRisk != nil {
		{
			size, err := m.FinishChapterRisk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.FinishTaskID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FinishTaskID)<<1)^uint32((*m.FinishTaskID>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.AccecpTaskID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.AccecpTaskID)<<1)^uint32((*m.AccecpTaskID>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.ReachLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ReachLevel)<<1)^uint32((*m.ReachLevel>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.SuggestLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SuggestLevel)<<1)^uint32((*m.SuggestLevel>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.NpcID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.NpcID)<<1)^uint32((*m.NpcID>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.SceneID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SceneID)<<1)^uint32((*m.SceneID>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.DescID != nil {
		i -= len(m.DescID)
		copy(dAtA[i:], m.DescID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DescID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaParkGaragePort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaParkGaragePort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaParkGaragePort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CostItemList) > 0 {
		for iNdEx := len(m.CostItemList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CostItemList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaInteractManual) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaInteractManual) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaInteractManual) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Energy != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Energy)<<1)^uint32((*m.Energy>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Num != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Num)<<1)^uint32((*m.Num>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaFaceDiscount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaFaceDiscount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaFaceDiscount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Discount != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Discount)<<1)^uint32((*m.Discount>>31))))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Price) > 0 {
		for iNdEx := len(m.Price) - 1; iNdEx >= 0; iNdEx-- {
			x138 := (uint32(m.Price[iNdEx]) << 1) ^ uint32((m.Price[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x138))
			i--
			dAtA[i] = 0x28
		}
	}
	if m.CostType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CostType)<<1)^uint32((*m.CostType>>31))))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Duration) > 0 {
		for iNdEx := len(m.Duration) - 1; iNdEx >= 0; iNdEx-- {
			x139 := (uint32(m.Duration[iNdEx]) << 1) ^ uint32((m.Duration[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x139))
			i--
			dAtA[i] = 0x18
		}
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Index)<<1)^uint32((*m.Index>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaParkEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaParkEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaParkEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExCarEffectList) > 0 {
		for iNdEx := len(m.ExCarEffectList) - 1; iNdEx >= 0; iNdEx-- {
			x140 := (uint32(m.ExCarEffectList[iNdEx]) << 1) ^ uint32((m.ExCarEffectList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x140))
			i--
			dAtA[i] = 0x40
		}
	}
	if len(m.SelectCarEffectList) > 0 {
		for iNdEx := len(m.SelectCarEffectList) - 1; iNdEx >= 0; iNdEx-- {
			x141 := (uint32(m.SelectCarEffectList[iNdEx]) << 1) ^ uint32((m.SelectCarEffectList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x141))
			i--
			dAtA[i] = 0x38
		}
	}
	if len(m.CondList) > 0 {
		for iNdEx := len(m.CondList) - 1; iNdEx >= 0; iNdEx-- {
			x142 := (uint32(m.CondList[iNdEx]) << 1) ^ uint32((m.CondList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x142))
			i--
			dAtA[i] = 0x30
		}
	}
	if m.CdTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CdTime)<<1)^uint32((*m.CdTime>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalTime != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.TotalTime)<<1)^uint32((*m.TotalTime>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.DescID != nil {
		i -= len(m.DescID)
		copy(dAtA[i:], m.DescID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DescID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaNpc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaNpc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaNpc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FindwayPos != nil {
		{
			size, err := m.FindwayPos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.NamePos != nil {
		{
			size, err := m.NamePos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.MarkPos != nil {
		{
			size, err := m.MarkPos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.TalkHeadScale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.TalkHeadScale))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x85
	}
	if m.TalkHeadPos != nil {
		{
			size, err := m.TalkHeadPos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.ClickRect) > 0 {
		for iNdEx := len(m.ClickRect) - 1; iNdEx >= 0; iNdEx-- {
			f147 := math.Float32bits(float32(m.ClickRect[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f147))
			i--
			dAtA[i] = 0x75
		}
	}
	if len(m.TalkIDList) > 0 {
		for iNdEx := len(m.TalkIDList) - 1; iNdEx >= 0; iNdEx-- {
			x148 := (uint32(m.TalkIDList[iNdEx]) << 1) ^ uint32((m.TalkIDList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x148))
			i--
			dAtA[i] = 0x68
		}
	}
	if len(m.TargetList) > 0 {
		for iNdEx := len(m.TargetList) - 1; iNdEx >= 0; iNdEx-- {
			x149 := (uint32(m.TargetList[iNdEx]) << 1) ^ uint32((m.TargetList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x149))
			i--
			dAtA[i] = 0x60
		}
	}
	if len(m.Pos) > 0 {
		for iNdEx := len(m.Pos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.EffectList) > 0 {
		for iNdEx := len(m.EffectList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EffectList[iNdEx])
			copy(dAtA[i:], m.EffectList[iNdEx])
			i = encodeVarintServerDef(dAtA, i, uint64(len(m.EffectList[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.FlipX != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FlipX)<<1)^uint32((*m.FlipX>>31))))
		i--
		dAtA[i] = 0x48
	}
	if m.Scale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Scale))))
		i--
		dAtA[i] = 0x45
	}
	if m.Res != nil {
		i -= len(m.Res)
		copy(dAtA[i:], m.Res)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Res)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ResType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ResType)<<1)^uint32((*m.ResType>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.ZOrder != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ZOrder)<<1)^uint32((*m.ZOrder>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.Head != nil {
		i -= len(m.Head)
		copy(dAtA[i:], m.Head)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Head)))
		i--
		dAtA[i] = 0x22
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaWingExtraEffect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaWingExtraEffect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaWingExtraEffect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExtraPerList) > 0 {
		for iNdEx := len(m.ExtraPerList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExtraPerList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.RandomNumList) > 0 {
		for iNdEx := len(m.RandomNumList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RandomNumList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaHouseExpand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaHouseExpand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaHouseExpand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CostItem != nil {
		{
			size, err := m.CostItem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.NeedVipLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.NeedVipLevel)<<1)^uint32((*m.NeedVipLevel>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.NeedHouseLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.NeedHouseLevel)<<1)^uint32((*m.NeedHouseLevel>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Icon != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Icon)<<1)^uint32((*m.Icon>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.Size_ != nil {
		{
			size, err := m.Size_.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UseforID != nil {
		i -= len(m.UseforID)
		copy(dAtA[i:], m.UseforID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.UseforID)))
		i--
		dAtA[i] = 0x7a
	}
	if m.FromID != nil {
		i -= len(m.FromID)
		copy(dAtA[i:], m.FromID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.FromID)))
		i--
		dAtA[i] = 0x72
	}
	if m.ItemSound != nil {
		i -= len(m.ItemSound)
		copy(dAtA[i:], m.ItemSound)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.ItemSound)))
		i--
		dAtA[i] = 0x6a
	}
	if m.SpID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SpID)<<1)^uint32((*m.SpID>>31))))
		i--
		dAtA[i] = 0x60
	}
	if len(m.EffectList) > 0 {
		for iNdEx := len(m.EffectList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EffectList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.TestWearList) > 0 {
		for iNdEx := len(m.TestWearList) - 1; iNdEx >= 0; iNdEx-- {
			x152 := (uint32(m.TestWearList[iNdEx]) << 1) ^ uint32((m.TestWearList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x152))
			i--
			dAtA[i] = 0x50
		}
	}
	if m.Price != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Price)<<1)^uint32((*m.Price>>31))))
		i--
		dAtA[i] = 0x48
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			x153 := (uint32(m.RewardList[iNdEx]) << 1) ^ uint32((m.RewardList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x153))
			i--
			dAtA[i] = 0x40
		}
	}
	if m.Quality != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Quality)<<1)^uint32((*m.Quality>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.UseLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.UseLevel)<<1)^uint32((*m.UseLevel>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.ResID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ResID)<<1)^uint32((*m.ResID>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.DesID != nil {
		i -= len(m.DesID)
		copy(dAtA[i:], m.DesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DesID)))
		i--
		dAtA[i] = 0x22
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaSkillShop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaSkillShop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaSkillShop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Price != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Price)<<1)^uint32((*m.Price>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.CostType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CostType)<<1)^uint32((*m.CostType>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Num != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Num)<<1)^uint32((*m.Num>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.ItemID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ItemID)<<1)^uint32((*m.ItemID>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaEquip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaEquip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaEquip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UseforID != nil {
		i -= len(m.UseforID)
		copy(dAtA[i:], m.UseforID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.UseforID)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if m.FromID != nil {
		i -= len(m.FromID)
		copy(dAtA[i:], m.FromID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.FromID)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	if m.RareDegree != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.RareDegree)<<1)^uint32((*m.RareDegree>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.CarSound != nil {
		i -= len(m.CarSound)
		copy(dAtA[i:], m.CarSound)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.CarSound)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if m.MoveSpeed != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.MoveSpeed)<<1)^uint32((*m.MoveSpeed>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if len(m.QualitySpeedList) > 0 {
		for iNdEx := len(m.QualitySpeedList) - 1; iNdEx >= 0; iNdEx-- {
			x154 := (uint32(m.QualitySpeedList[iNdEx]) << 1) ^ uint32((m.QualitySpeedList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x154))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb8
		}
	}
	if len(m.QualityBlockList) > 0 {
		for iNdEx := len(m.QualityBlockList) - 1; iNdEx >= 0; iNdEx-- {
			x155 := (uint32(m.QualityBlockList[iNdEx]) << 1) ^ uint32((m.QualityBlockList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x155))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb0
		}
	}
	if len(m.QualityCritList) > 0 {
		for iNdEx := len(m.QualityCritList) - 1; iNdEx >= 0; iNdEx-- {
			x156 := (uint32(m.QualityCritList[iNdEx]) << 1) ^ uint32((m.QualityCritList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x156))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xa8
		}
	}
	if len(m.QualityDefList) > 0 {
		for iNdEx := len(m.QualityDefList) - 1; iNdEx >= 0; iNdEx-- {
			x157 := (uint32(m.QualityDefList[iNdEx]) << 1) ^ uint32((m.QualityDefList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x157))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xa0
		}
	}
	if len(m.QualityHpList) > 0 {
		for iNdEx := len(m.QualityHpList) - 1; iNdEx >= 0; iNdEx-- {
			x158 := (uint32(m.QualityHpList[iNdEx]) << 1) ^ uint32((m.QualityHpList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x158))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x98
		}
	}
	if len(m.QualityAtkList) > 0 {
		for iNdEx := len(m.QualityAtkList) - 1; iNdEx >= 0; iNdEx-- {
			x159 := (uint32(m.QualityAtkList[iNdEx]) << 1) ^ uint32((m.QualityAtkList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x159))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x90
		}
	}
	if m.IsResoluble != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IsResoluble)<<1)^uint32((*m.IsResoluble>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.StarUpperLimit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.StarUpperLimit)<<1)^uint32((*m.StarUpperLimit>>31))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if len(m.ResolveExtraList) > 0 {
		for iNdEx := len(m.ResolveExtraList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResolveExtraList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xfa
		}
	}
	if len(m.ResolveBaseList) > 0 {
		for iNdEx := len(m.ResolveBaseList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResolveBaseList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf2
		}
	}
	if m.SpeedStarStepValue != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SpeedStarStepValue)<<1)^uint32((*m.SpeedStarStepValue>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.BlockStarStepValue != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BlockStarStepValue)<<1)^uint32((*m.BlockStarStepValue>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.CritStarStepValue != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.CritStarStepValue)<<1)^uint32((*m.CritStarStepValue>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.DefStarStepValue != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.DefStarStepValue)<<1)^uint32((*m.DefStarStepValue>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.HpStarStepValue != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.HpStarStepValue)<<1)^uint32((*m.HpStarStepValue>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.AtkStarStepValue != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.AtkStarStepValue)<<1)^uint32((*m.AtkStarStepValue>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.BasePrice != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BasePrice)<<1)^uint32((*m.BasePrice>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.WeaponEffect != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.WeaponEffect)<<1)^uint32((*m.WeaponEffect>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.Icon != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Icon)<<1)^uint32((*m.Icon>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Endurance != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Endurance)<<1)^uint32((*m.Endurance>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.FullAttr != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FullAttr)<<1)^uint32((*m.FullAttr>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Speed != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Speed)<<1)^uint32((*m.Speed>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Block != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Block)<<1)^uint32((*m.Block>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Crit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Crit)<<1)^uint32((*m.Crit>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Def != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Def)<<1)^uint32((*m.Def>>31))))
		i--
		dAtA[i] = 0x78
	}
	if m.Hp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Hp)<<1)^uint32((*m.Hp>>31))))
		i--
		dAtA[i] = 0x70
	}
	if m.AtkMax != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.AtkMax)<<1)^uint32((*m.AtkMax>>31))))
		i--
		dAtA[i] = 0x68
	}
	if m.AtkMin != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.AtkMin)<<1)^uint32((*m.AtkMin>>31))))
		i--
		dAtA[i] = 0x60
	}
	if m.WearLevel != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.WearLevel)<<1)^uint32((*m.WearLevel>>31))))
		i--
		dAtA[i] = 0x58
	}
	if m.Quality != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Quality)<<1)^uint32((*m.Quality>>31))))
		i--
		dAtA[i] = 0x50
	}
	if m.AnimSuffix != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.AnimSuffix)<<1)^uint32((*m.AnimSuffix>>31))))
		i--
		dAtA[i] = 0x48
	}
	if m.CsbName != nil {
		i -= len(m.CsbName)
		copy(dAtA[i:], m.CsbName)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.CsbName)))
		i--
		dAtA[i] = 0x42
	}
	if m.WingBindType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.WingBindType)<<1)^uint32((*m.WingBindType>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.WingSuffix != nil {
		i -= len(m.WingSuffix)
		copy(dAtA[i:], m.WingSuffix)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.WingSuffix)))
		i--
		dAtA[i] = 0x32
	}
	if m.WingCSB != nil {
		i -= len(m.WingCSB)
		copy(dAtA[i:], m.WingCSB)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.WingCSB)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.DesID != nil {
		i -= len(m.DesID)
		copy(dAtA[i:], m.DesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DesID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaPetActSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaPetActSkill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaPetActSkill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Icon != nil {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x22
	}
	if m.DesID != nil {
		i -= len(m.DesID)
		copy(dAtA[i:], m.DesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DesID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaVip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaVip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaVip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CarportCount) > 0 {
		for iNdEx := len(m.CarportCount) - 1; iNdEx >= 0; iNdEx-- {
			x160 := (uint32(m.CarportCount[iNdEx]) << 1) ^ uint32((m.CarportCount[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x160))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xc0
		}
	}
	if len(m.SelfDefVehicle) > 0 {
		for iNdEx := len(m.SelfDefVehicle) - 1; iNdEx >= 0; iNdEx-- {
			x161 := (uint32(m.SelfDefVehicle[iNdEx]) << 1) ^ uint32((m.SelfDefVehicle[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x161))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb8
		}
	}
	if len(m.VipFellow) > 0 {
		for iNdEx := len(m.VipFellow) - 1; iNdEx >= 0; iNdEx-- {
			x162 := (uint32(m.VipFellow[iNdEx]) << 1) ^ uint32((m.VipFellow[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x162))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb0
		}
	}
	if len(m.RiskDropRate) > 0 {
		for iNdEx := len(m.RiskDropRate) - 1; iNdEx >= 0; iNdEx-- {
			x163 := (uint32(m.RiskDropRate[iNdEx]) << 1) ^ uint32((m.RiskDropRate[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x163))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xa8
		}
	}
	if len(m.VipVechical) > 0 {
		for iNdEx := len(m.VipVechical) - 1; iNdEx >= 0; iNdEx-- {
			x164 := (uint32(m.VipVechical[iNdEx]) << 1) ^ uint32((m.VipVechical[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x164))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xa0
		}
	}
	if len(m.VipFurnitureShop) > 0 {
		for iNdEx := len(m.VipFurnitureShop) - 1; iNdEx >= 0; iNdEx-- {
			x165 := (uint32(m.VipFurnitureShop[iNdEx]) << 1) ^ uint32((m.VipFurnitureShop[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x165))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x98
		}
	}
	if len(m.VipAct) > 0 {
		for iNdEx := len(m.VipAct) - 1; iNdEx >= 0; iNdEx-- {
			x166 := (uint32(m.VipAct[iNdEx]) << 1) ^ uint32((m.VipAct[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x166))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x90
		}
	}
	if len(m.ParkNum) > 0 {
		for iNdEx := len(m.ParkNum) - 1; iNdEx >= 0; iNdEx-- {
			x167 := (uint32(m.ParkNum[iNdEx]) << 1) ^ uint32((m.ParkNum[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x167))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x88
		}
	}
	if len(m.DangerRiskResetCount) > 0 {
		for iNdEx := len(m.DangerRiskResetCount) - 1; iNdEx >= 0; iNdEx-- {
			x168 := (uint32(m.DangerRiskResetCount[iNdEx]) << 1) ^ uint32((m.DangerRiskResetCount[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x168))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x80
		}
	}
	if len(m.SignManualCount) > 0 {
		for iNdEx := len(m.SignManualCount) - 1; iNdEx >= 0; iNdEx-- {
			x169 := (uint32(m.SignManualCount[iNdEx]) << 1) ^ uint32((m.SignManualCount[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x169))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf8
		}
	}
	if len(m.UpdateDiamondShopCount) > 0 {
		for iNdEx := len(m.UpdateDiamondShopCount) - 1; iNdEx >= 0; iNdEx-- {
			x170 := (uint32(m.UpdateDiamondShopCount[iNdEx]) << 1) ^ uint32((m.UpdateDiamondShopCount[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x170))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf0
		}
	}
	if len(m.UpdateBlackShopCount) > 0 {
		for iNdEx := len(m.UpdateBlackShopCount) - 1; iNdEx >= 0; iNdEx-- {
			x171 := (uint32(m.UpdateBlackShopCount[iNdEx]) << 1) ^ uint32((m.UpdateBlackShopCount[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x171))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe8
		}
	}
	if len(m.UpdateArenaShopCount) > 0 {
		for iNdEx := len(m.UpdateArenaShopCount) - 1; iNdEx >= 0; iNdEx-- {
			x172 := (uint32(m.UpdateArenaShopCount[iNdEx]) << 1) ^ uint32((m.UpdateArenaShopCount[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x172))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe0
		}
	}
	if len(m.UpdateMinigameShopCount) > 0 {
		for iNdEx := len(m.UpdateMinigameShopCount) - 1; iNdEx >= 0; iNdEx-- {
			x173 := (uint32(m.UpdateMinigameShopCount[iNdEx]) << 1) ^ uint32((m.UpdateMinigameShopCount[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x173))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd8
		}
	}
	if len(m.UpdateSkillShopCount) > 0 {
		for iNdEx := len(m.UpdateSkillShopCount) - 1; iNdEx >= 0; iNdEx-- {
			x174 := (uint32(m.UpdateSkillShopCount[iNdEx]) << 1) ^ uint32((m.UpdateSkillShopCount[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x174))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd0
		}
	}
	if len(m.FaceRefreshCountUpperLimit) > 0 {
		for iNdEx := len(m.FaceRefreshCountUpperLimit) - 1; iNdEx >= 0; iNdEx-- {
			x175 := (uint32(m.FaceRefreshCountUpperLimit[iNdEx]) << 1) ^ uint32((m.FaceRefreshCountUpperLimit[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x175))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc8
		}
	}
	if len(m.BuyBitCoinCount) > 0 {
		for iNdEx := len(m.BuyBitCoinCount) - 1; iNdEx >= 0; iNdEx-- {
			x176 := (uint32(m.BuyBitCoinCount[iNdEx]) << 1) ^ uint32((m.BuyBitCoinCount[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x176))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc0
		}
	}
	if len(m.BuyStaminaCount) > 0 {
		for iNdEx := len(m.BuyStaminaCount) - 1; iNdEx >= 0; iNdEx-- {
			x177 := (uint32(m.BuyStaminaCount[iNdEx]) << 1) ^ uint32((m.BuyStaminaCount[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x177))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb8
		}
	}
	if len(m.BuyArenaCount) > 0 {
		for iNdEx := len(m.BuyArenaCount) - 1; iNdEx >= 0; iNdEx-- {
			x178 := (uint32(m.BuyArenaCount[iNdEx]) << 1) ^ uint32((m.BuyArenaCount[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x178))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb0
		}
	}
	if len(m.ExchangeGoldTime) > 0 {
		for iNdEx := len(m.ExchangeGoldTime) - 1; iNdEx >= 0; iNdEx-- {
			x179 := (uint32(m.ExchangeGoldTime[iNdEx]) << 1) ^ uint32((m.ExchangeGoldTime[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x179))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa8
		}
	}
	if len(m.FriendSkillCD) > 0 {
		for iNdEx := len(m.FriendSkillCD) - 1; iNdEx >= 0; iNdEx-- {
			x180 := (uint32(m.FriendSkillCD[iNdEx]) << 1) ^ uint32((m.FriendSkillCD[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x180))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa0
		}
	}
	if len(m.ExpPromoteRatio) > 0 {
		for iNdEx := len(m.ExpPromoteRatio) - 1; iNdEx >= 0; iNdEx-- {
			x181 := (uint32(m.ExpPromoteRatio[iNdEx]) << 1) ^ uint32((m.ExpPromoteRatio[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x181))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x98
		}
	}
	if len(m.VipBarrageFont) > 0 {
		for iNdEx := len(m.VipBarrageFont) - 1; iNdEx >= 0; iNdEx-- {
			x182 := (uint32(m.VipBarrageFont[iNdEx]) << 1) ^ uint32((m.VipBarrageFont[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x182))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x90
		}
	}
	if len(m.VipBMG) > 0 {
		for iNdEx := len(m.VipBMG) - 1; iNdEx >= 0; iNdEx-- {
			x183 := (uint32(m.VipBMG[iNdEx]) << 1) ^ uint32((m.VipBMG[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x183))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x88
		}
	}
	if len(m.SkilledSpeed) > 0 {
		for iNdEx := len(m.SkilledSpeed) - 1; iNdEx >= 0; iNdEx-- {
			x184 := (uint32(m.SkilledSpeed[iNdEx]) << 1) ^ uint32((m.SkilledSpeed[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x184))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x80
		}
	}
	if len(m.VipPet) > 0 {
		for iNdEx := len(m.VipPet) - 1; iNdEx >= 0; iNdEx-- {
			x185 := (uint32(m.VipPet[iNdEx]) << 1) ^ uint32((m.VipPet[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x185))
			i--
			dAtA[i] = 0x78
		}
	}
	if len(m.BathExpSpeedup) > 0 {
		for iNdEx := len(m.BathExpSpeedup) - 1; iNdEx >= 0; iNdEx-- {
			x186 := (uint32(m.BathExpSpeedup[iNdEx]) << 1) ^ uint32((m.BathExpSpeedup[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x186))
			i--
			dAtA[i] = 0x70
		}
	}
	if len(m.VipSkipFight) > 0 {
		for iNdEx := len(m.VipSkipFight) - 1; iNdEx >= 0; iNdEx-- {
			x187 := (uint32(m.VipSkipFight[iNdEx]) << 1) ^ uint32((m.VipSkipFight[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x187))
			i--
			dAtA[i] = 0x68
		}
	}
	if len(m.FixTimePlus) > 0 {
		for iNdEx := len(m.FixTimePlus) - 1; iNdEx >= 0; iNdEx-- {
			x188 := (uint32(m.FixTimePlus[iNdEx]) << 1) ^ uint32((m.FixTimePlus[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x188))
			i--
			dAtA[i] = 0x60
		}
	}
	if len(m.NoCdArenaFail) > 0 {
		for iNdEx := len(m.NoCdArenaFail) - 1; iNdEx >= 0; iNdEx-- {
			x189 := (uint32(m.NoCdArenaFail[iNdEx]) << 1) ^ uint32((m.NoCdArenaFail[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x189))
			i--
			dAtA[i] = 0x58
		}
	}
	if len(m.VipChatPP) > 0 {
		for iNdEx := len(m.VipChatPP) - 1; iNdEx >= 0; iNdEx-- {
			x190 := (uint32(m.VipChatPP[iNdEx]) << 1) ^ uint32((m.VipChatPP[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x190))
			i--
			dAtA[i] = 0x50
		}
	}
	if len(m.UnlockSkillPos) > 0 {
		for iNdEx := len(m.UnlockSkillPos) - 1; iNdEx >= 0; iNdEx-- {
			x191 := (uint32(m.UnlockSkillPos[iNdEx]) << 1) ^ uint32((m.UnlockSkillPos[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x191))
			i--
			dAtA[i] = 0x48
		}
	}
	if len(m.UploadFaceFlag) > 0 {
		for iNdEx := len(m.UploadFaceFlag) - 1; iNdEx >= 0; iNdEx-- {
			x192 := (uint32(m.UploadFaceFlag[iNdEx]) << 1) ^ uint32((m.UploadFaceFlag[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x192))
			i--
			dAtA[i] = 0x40
		}
	}
	if len(m.RiskAddSpeed) > 0 {
		for iNdEx := len(m.RiskAddSpeed) - 1; iNdEx >= 0; iNdEx-- {
			x193 := (uint32(m.RiskAddSpeed[iNdEx]) << 1) ^ uint32((m.RiskAddSpeed[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x193))
			i--
			dAtA[i] = 0x38
		}
	}
	if len(m.DailyRewardList) > 0 {
		for iNdEx := len(m.DailyRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DailyRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.RealPrice != nil {
		{
			size, err := m.RealPrice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ShowPrice != nil {
		{
			size, err := m.ShowPrice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.SpecialRewardList) > 0 {
		for iNdEx := len(m.SpecialRewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpecialRewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Exp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Exp)<<1)^uint32((*m.Exp>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaFurniture) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaFurniture) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaFurniture) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SalePrice != nil {
		{
			size, err := m.SalePrice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.OffsetPos != nil {
		{
			size, err := m.OffsetPos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.IsCanPass != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IsCanPass)<<1)^uint32((*m.IsCanPass>>31))))
		i--
		dAtA[i] = 0x60
	}
	if m.Res != nil {
		i -= len(m.Res)
		copy(dAtA[i:], m.Res)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Res)))
		i--
		dAtA[i] = 0x5a
	}
	if m.ResType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ResType)<<1)^uint32((*m.ResType>>31))))
		i--
		dAtA[i] = 0x50
	}
	if m.DirectIndex != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.DirectIndex)<<1)^uint32((*m.DirectIndex>>31))))
		i--
		dAtA[i] = 0x48
	}
	if m.DirType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.DirType)<<1)^uint32((*m.DirType>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.Size_ != nil {
		{
			size, err := m.Size_.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.SubType != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SubType)<<1)^uint32((*m.SubType>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.Icon != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Icon)<<1)^uint32((*m.Icon>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.DesID != nil {
		i -= len(m.DesID)
		copy(dAtA[i:], m.DesID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DesID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaArenaBuy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaArenaBuy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaArenaBuy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Diamond != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Diamond)<<1)^uint32((*m.Diamond>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Count != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Count)<<1)^uint32((*m.Count>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaBattleWave) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaBattleWave) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaBattleWave) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EventArgList != nil {
		{
			size, err := m.EventArgList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.EventConList) > 0 {
		for iNdEx := len(m.EventConList) - 1; iNdEx >= 0; iNdEx-- {
			x200 := (uint32(m.EventConList[iNdEx]) << 1) ^ uint32((m.EventConList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x200))
			i--
			dAtA[i] = 0x48
		}
	}
	if m.EventID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EventID)<<1)^uint32((*m.EventID>>31))))
		i--
		dAtA[i] = 0x40
	}
	if len(m.DiffList) > 0 {
		for iNdEx := len(m.DiffList) - 1; iNdEx >= 0; iNdEx-- {
			x201 := (uint32(m.DiffList[iNdEx]) << 1) ^ uint32((m.DiffList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x201))
			i--
			dAtA[i] = 0x38
		}
	}
	if len(m.LevelList) > 0 {
		for iNdEx := len(m.LevelList) - 1; iNdEx >= 0; iNdEx-- {
			x202 := (uint32(m.LevelList[iNdEx]) << 1) ^ uint32((m.LevelList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x202))
			i--
			dAtA[i] = 0x30
		}
	}
	if m.TalkID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.TalkID)<<1)^uint32((*m.TalkID>>31))))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PosList) > 0 {
		for iNdEx := len(m.PosList) - 1; iNdEx >= 0; iNdEx-- {
			x203 := (uint32(m.PosList[iNdEx]) << 1) ^ uint32((m.PosList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x203))
			i--
			dAtA[i] = 0x20
		}
	}
	if len(m.MonsterList) > 0 {
		for iNdEx := len(m.MonsterList) - 1; iNdEx >= 0; iNdEx-- {
			x204 := (uint32(m.MonsterList[iNdEx]) << 1) ^ uint32((m.MonsterList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x204))
			i--
			dAtA[i] = 0x18
		}
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaMiniWarrior) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaMiniWarrior) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaMiniWarrior) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MapSpeed != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.MapSpeed)<<1)^uint32((*m.MapSpeed>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.BossScore != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BossScore)<<1)^uint32((*m.BossScore>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.EnemyScore != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EnemyScore)<<1)^uint32((*m.EnemyScore>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.BossGatherEnergyAdd != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BossGatherEnergyAdd)<<1)^uint32((*m.BossGatherEnergyAdd>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.BossGatherEnergy != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BossGatherEnergy)<<1)^uint32((*m.BossGatherEnergy>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.BossChangeColorNumAdd != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BossChangeColorNumAdd)<<1)^uint32((*m.BossChangeColorNumAdd>>31))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.BossChangeColorNum != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BossChangeColorNum)<<1)^uint32((*m.BossChangeColorNum>>31))))
		i--
		dAtA[i] = 0x78
	}
	if m.BossAppearScoreAdd != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BossAppearScoreAdd)<<1)^uint32((*m.BossAppearScoreAdd>>31))))
		i--
		dAtA[i] = 0x70
	}
	if m.BossAppearScore != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.BossAppearScore)<<1)^uint32((*m.BossAppearScore>>31))))
		i--
		dAtA[i] = 0x68
	}
	if m.AttLimit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.AttLimit)<<1)^uint32((*m.AttLimit>>31))))
		i--
		dAtA[i] = 0x60
	}
	if m.SpeedMaxLimit != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.SpeedMaxLimit)<<1)^uint32((*m.SpeedMaxLimit>>31))))
		i--
		dAtA[i] = 0x58
	}
	if m.SpeedAddPerGroup != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.SpeedAddPerGroup))))
		i--
		dAtA[i] = 0x55
	}
	if m.AddSpeedGroup != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.AddSpeedGroup)<<1)^uint32((*m.AddSpeedGroup>>31))))
		i--
		dAtA[i] = 0x48
	}
	if m.FirstSpeed != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FirstSpeed)<<1)^uint32((*m.FirstSpeed>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.EnemyAddPerGroup != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EnemyAddPerGroup)<<1)^uint32((*m.EnemyAddPerGroup>>31))))
		i--
		dAtA[i] = 0x38
	}
	if m.AddEnemyGroup != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.AddEnemyGroup)<<1)^uint32((*m.AddEnemyGroup>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.EnemyNum != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EnemyNum)<<1)^uint32((*m.EnemyNum>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.Gap != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Gap))))
		i--
		dAtA[i] = 0x25
	}
	if m.EnemyNumMax != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EnemyNumMax)<<1)^uint32((*m.EnemyNumMax>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.NumPerGroup != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.NumPerGroup)<<1)^uint32((*m.NumPerGroup>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaParkCarport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaParkCarport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaParkCarport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BenefitRate != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.BenefitRate))))
		i--
		dAtA[i] = 0x15
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaParkSayyes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaParkSayyes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaParkSayyes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Sound != nil {
		i -= len(m.Sound)
		copy(dAtA[i:], m.Sound)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Sound)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ValueList) > 0 {
		for iNdEx := len(m.ValueList) - 1; iNdEx >= 0; iNdEx-- {
			x205 := (uint32(m.ValueList[iNdEx]) << 1) ^ uint32((m.ValueList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x205))
			i--
			dAtA[i] = 0x20
		}
	}
	if m.Effect != nil {
		i -= len(m.Effect)
		copy(dAtA[i:], m.Effect)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Effect)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Res != nil {
		i -= len(m.Res)
		copy(dAtA[i:], m.Res)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.Res)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaParkRepairPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaParkRepairPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaParkRepairPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CostItemList) > 0 {
		for iNdEx := len(m.CostItemList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CostItemList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaHouseLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaHouseLevel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaHouseLevel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Exp != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Exp)<<1)^uint32((*m.Exp>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Level != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaSevenDays) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaSevenDays) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaSevenDays) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Reward) > 0 {
		for iNdEx := len(m.Reward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Reward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ID)<<1)^uint32((*m.ID>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaPetPill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaPetPill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaPetPill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EffectValue != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.EffectValue)<<1)^uint32((*m.EffectValue>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.ItemId != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.ItemId)<<1)^uint32((*m.ItemId>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaScene) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaScene) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaScene) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PetRefreshPosList) > 0 {
		for iNdEx := len(m.PetRefreshPosList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PetRefreshPosList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.RoleScale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.RoleScale))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x85
	}
	if len(m.MusicList) > 0 {
		for iNdEx := len(m.MusicList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MusicList[iNdEx])
			copy(dAtA[i:], m.MusicList[iNdEx])
			i = encodeVarintServerDef(dAtA, i, uint64(len(m.MusicList[iNdEx])))
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.BornPosList) > 0 {
		for iNdEx := len(m.BornPosList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BornPosList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.NpcList) > 0 {
		for iNdEx := len(m.NpcList) - 1; iNdEx >= 0; iNdEx-- {
			x206 := (uint32(m.NpcList[iNdEx]) << 1) ^ uint32((m.NpcList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x206))
			i--
			dAtA[i] = 0x68
		}
	}
	if len(m.BuildingList) > 0 {
		for iNdEx := len(m.BuildingList) - 1; iNdEx >= 0; iNdEx-- {
			x207 := (uint32(m.BuildingList[iNdEx]) << 1) ^ uint32((m.BuildingList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x207))
			i--
			dAtA[i] = 0x60
		}
	}
	if m.OpenFuncID != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.OpenFuncID)<<1)^uint32((*m.OpenFuncID>>31))))
		i--
		dAtA[i] = 0x58
	}
	if m.FastTransEnable != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.FastTransEnable)<<1)^uint32((*m.FastTransEnable>>31))))
		i--
		dAtA[i] = 0x50
	}
	if len(m.TransportList) > 0 {
		for iNdEx := len(m.TransportList) - 1; iNdEx >= 0; iNdEx-- {
			x208 := (uint32(m.TransportList[iNdEx]) << 1) ^ uint32((m.TransportList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x208))
			i--
			dAtA[i] = 0x48
		}
	}
	if m.MapSize != nil {
		{
			size, err := m.MapSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServerDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.DataFile != nil {
		i -= len(m.DataFile)
		copy(dAtA[i:], m.DataFile)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.DataFile)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.MapList) > 0 {
		for iNdEx := len(m.MapList) - 1; iNdEx >= 0; iNdEx-- {
			x210 := (uint32(m.MapList[iNdEx]) << 1) ^ uint32((m.MapList[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x210))
			i--
			dAtA[i] = 0x30
		}
	}
	if m.IsCanMoreOpen != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.IsCanMoreOpen)<<1)^uint32((*m.IsCanMoreOpen>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxRole != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.MaxRole)<<1)^uint32((*m.MaxRole>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.NameID != nil {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintServerDef(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LuaArenaDayRank) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaArenaDayRank) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LuaArenaDayRank) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RewardList) > 0 {
		for iNdEx := len(m.RewardList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServerDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.RankRect) > 0 {
		for iNdEx := len(m.RankRect) - 1; iNdEx >= 0; iNdEx-- {
			x211 := (uint32(m.RankRect[iNdEx]) << 1) ^ uint32((m.RankRect[iNdEx] >> 31))
			i = encodeVarintServerDef(dAtA, i, uint64(x211))
			i--
			dAtA[i] = 0x10
		}
	}
	if m.Id != nil {
		i = encodeVarintServerDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintServerDef(dAtA []byte, offset int, v uint64) int {
	offset -= sovServerDef(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LuaSignReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		n += 1 + sozServerDef(uint64(*m.ID))
	}
	if len(m.Reward) > 0 {
		for _, e := range m.Reward {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaParkShop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemId != nil {
		n += 1 + sozServerDef(uint64(*m.ItemId))
	}
	if m.CarId != nil {
		n += 1 + sozServerDef(uint64(*m.CarId))
	}
	if m.Num != nil {
		n += 1 + sozServerDef(uint64(*m.Num))
	}
	if m.CostType != nil {
		n += 1 + sozServerDef(uint64(*m.CostType))
	}
	if m.Price != nil {
		n += 1 + sozServerDef(uint64(*m.Price))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaDailyActivity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.ActivityValue != nil {
		n += 1 + sozServerDef(uint64(*m.ActivityValue))
	}
	if len(m.Reward) > 0 {
		for _, e := range m.Reward {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaAchieve) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.TypeName != nil {
		l = len(m.TypeName)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Name != nil {
		l = len(m.Name)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if m.IsHide != nil {
		n += 1 + sozServerDef(uint64(*m.IsHide))
	}
	if m.Des != nil {
		l = len(m.Des)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.ConditionValue != nil {
		n += 1 + sozServerDef(uint64(*m.ConditionValue))
	}
	if m.AchievePoint != nil {
		n += 1 + sozServerDef(uint64(*m.AchievePoint))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.Quality != nil {
		n += 1 + sozServerDef(uint64(*m.Quality))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaFaceShop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != nil {
		n += 1 + sozServerDef(uint64(*m.Index))
	}
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if len(m.Duration) > 0 {
		for _, e := range m.Duration {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.CostType != nil {
		n += 1 + sozServerDef(uint64(*m.CostType))
	}
	if len(m.Price) > 0 {
		for _, e := range m.Price {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaBgm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.BgmNameID != nil {
		l = len(m.BgmNameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Sound != nil {
		l = len(m.Sound)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.NeedVipLevel != nil {
		n += 1 + sozServerDef(uint64(*m.NeedVipLevel))
	}
	if m.Time != nil {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaArenaReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if len(m.WinRewardList) > 0 {
		for _, e := range m.WinRewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.LoseRewardList) > 0 {
		for _, e := range m.LoseRewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaArenaSelectRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if len(m.RankRect) > 0 {
		for _, e := range m.RankRect {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.PosRectList) > 0 {
		for _, e := range m.PosRectList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaDangerChapter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.DupList) > 0 {
		for _, e := range m.DupList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.Icon != nil {
		l = len(m.Icon)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Title != nil {
		l = len(m.Title)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.LockIcon != nil {
		l = len(m.LockIcon)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.SharePic != nil {
		l = len(m.SharePic)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.EnemyPos != nil {
		l = m.EnemyPos.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaAssistantTip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.QuestionID != nil {
		l = len(m.QuestionID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.AnswerID != nil {
		l = len(m.AnswerID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Icon != nil {
		l = len(m.Icon)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Reward != nil {
		l = m.Reward.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaVehicleCompose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Quality != nil {
		n += 1 + sozServerDef(uint64(*m.Quality))
	}
	if len(m.NeedItemList) > 0 {
		for _, e := range m.NeedItemList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.NeedLevel != nil {
		n += 1 + sozServerDef(uint64(*m.NeedLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaChapter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.DupList) > 0 {
		for _, e := range m.DupList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.Icon != nil {
		l = len(m.Icon)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Title != nil {
		l = len(m.Title)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.LockIcon != nil {
		l = len(m.LockIcon)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.SharePic != nil {
		l = len(m.SharePic)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.EnemyPos != nil {
		l = m.EnemyPos.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaBuilding) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.ZOrder != nil {
		n += 1 + sozServerDef(uint64(*m.ZOrder))
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if m.ResType != nil {
		n += 1 + sozServerDef(uint64(*m.ResType))
	}
	if m.Res != nil {
		l = len(m.Res)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaDiamondShop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.ItemID != nil {
		n += 1 + sozServerDef(uint64(*m.ItemID))
	}
	if m.Num != nil {
		n += 1 + sozServerDef(uint64(*m.Num))
	}
	if m.CostType != nil {
		n += 1 + sozServerDef(uint64(*m.CostType))
	}
	if m.Price != nil {
		n += 1 + sozServerDef(uint64(*m.Price))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaParkBreak) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.DescID != nil {
		l = len(m.DescID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Res != nil {
		l = len(m.Res)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Effect != nil {
		l = len(m.Effect)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.ValueList) > 0 {
		for _, e := range m.ValueList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.Sound != nil {
		l = len(m.Sound)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaParkCar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Icon != nil {
		n += 1 + sozServerDef(uint64(*m.Icon))
	}
	if m.Quality != nil {
		n += 1 + sozServerDef(uint64(*m.Quality))
	}
	if m.MaxLevel != nil {
		n += 1 + sozServerDef(uint64(*m.MaxLevel))
	}
	if m.ParkTime != nil {
		n += 1 + sozServerDef(uint64(*m.ParkTime))
	}
	if m.ProtectValue != nil {
		n += 1 + sozServerDef(uint64(*m.ProtectValue))
	}
	if m.LastProtectValue != nil {
		n += 1 + sozServerDef(uint64(*m.LastProtectValue))
	}
	if m.RepairCostCount != nil {
		n += 1 + sozServerDef(uint64(*m.RepairCostCount))
	}
	if m.DecomposeGetCount != nil {
		n += 1 + sozServerDef(uint64(*m.DecomposeGetCount))
	}
	if m.ParkUnitBenefit != nil {
		l = m.ParkUnitBenefit.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.AddParkUnitBenefitRate != nil {
		n += 5
	}
	if m.SayYesReduceMaxParkTime != nil {
		n += 1 + sozServerDef(uint64(*m.SayYesReduceMaxParkTime))
	}
	if m.ParkOffset != nil {
		l = m.ParkOffset.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.ShowOffset != nil {
		l = m.ShowOffset.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaPetPassiveTalent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.TalentId != nil {
		l = len(m.TalentId)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.TalentDesId != nil {
		l = len(m.TalentDesId)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.IconId != nil {
		l = len(m.IconId)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Weight != nil {
		n += 1 + sozServerDef(uint64(*m.Weight))
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if len(m.ArgList) > 0 {
		for _, e := range m.ArgList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.ValueList) > 0 {
		for _, e := range m.ValueList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaEquipManual) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Num != nil {
		n += 1 + sozServerDef(uint64(*m.Num))
	}
	if m.Reward != nil {
		l = m.Reward.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaMinigameShop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.ItemID != nil {
		n += 1 + sozServerDef(uint64(*m.ItemID))
	}
	if m.Num != nil {
		n += 1 + sozServerDef(uint64(*m.Num))
	}
	if m.CostType != nil {
		n += 1 + sozServerDef(uint64(*m.CostType))
	}
	if m.Price != nil {
		n += 1 + sozServerDef(uint64(*m.Price))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaTransInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.TargetID != nil {
		n += 1 + sozServerDef(uint64(*m.TargetID))
	}
	if len(m.Rect) > 0 {
		for _, e := range m.Rect {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaSkill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.DescID != nil {
		l = len(m.DescID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.ArmaType != nil {
		n += 1 + sozServerDef(uint64(*m.ArmaType))
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if len(m.EventConList) > 0 {
		for _, e := range m.EventConList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.EventValList) > 0 {
		for _, e := range m.EventValList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.AtkEffList) > 0 {
		for _, e := range m.AtkEffList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.DefEffList) > 0 {
		for _, e := range m.DefEffList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.PreAtkEffList) > 0 {
		for _, e := range m.PreAtkEffList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.PreDefEffList) > 0 {
		for _, e := range m.PreDefEffList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.AtkSound != nil {
		l = len(m.AtkSound)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.FlyEffIDList) > 0 {
		for _, e := range m.FlyEffIDList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.HurtEffIDList) > 0 {
		for _, e := range m.HurtEffIDList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.ResIndex != nil {
		n += 1 + sozServerDef(uint64(*m.ResIndex))
	}
	if m.PreAnim != nil {
		l = len(m.PreAnim)
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.PreTime != nil {
		n += 6
	}
	if m.FlyAnim != nil {
		l = len(m.FlyAnim)
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.AtkAnim != nil {
		l = len(m.AtkAnim)
		n += 2 + l + sovServerDef(uint64(l))
	}
	if len(m.AtkTimeList) > 0 {
		n += 6 * len(m.AtkTimeList)
	}
	if len(m.AtkHurtPerList) > 0 {
		for _, e := range m.AtkHurtPerList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.AtkSoundList) > 0 {
		for _, b := range m.AtkSoundList {
			l = len(b)
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.ShakeTimeList) > 0 {
		for _, e := range m.ShakeTimeList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if m.AtkEndTime != nil {
		n += 6
	}
	if m.TargetType != nil {
		n += 2 + sozServerDef(uint64(*m.TargetType))
	}
	if m.DisType != nil {
		n += 2 + sozServerDef(uint64(*m.DisType))
	}
	if len(m.StartBuffTargetList) > 0 {
		for _, e := range m.StartBuffTargetList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.StartBuffList) > 0 {
		for _, e := range m.StartBuffList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.EndBuffTargetList) > 0 {
		for _, e := range m.EndBuffTargetList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.EndBuffList) > 0 {
		for _, e := range m.EndBuffList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.DamageType != nil {
		n += 2 + sozServerDef(uint64(*m.DamageType))
	}
	if len(m.PerHurtList) > 0 {
		for _, e := range m.PerHurtList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.FixHurtList) > 0 {
		for _, e := range m.FixHurtList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.HurtSound != nil {
		l = len(m.HurtSound)
		n += 2 + l + sovServerDef(uint64(l))
	}
	if len(m.HurtTypeData) > 0 {
		for _, e := range m.HurtTypeData {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaBuyStamina) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.Diamond != nil {
		n += 1 + sozServerDef(uint64(*m.Diamond))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaGuadraticBoss) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.EnterType != nil {
		n += 1 + sozServerDef(uint64(*m.EnterType))
	}
	if m.ExitType != nil {
		n += 1 + sozServerDef(uint64(*m.ExitType))
	}
	if m.MoveSpeed != nil {
		n += 1 + sozServerDef(uint64(*m.MoveSpeed))
	}
	if m.EnterTime != nil {
		n += 1 + sozServerDef(uint64(*m.EnterTime))
	}
	if m.EnterHurt != nil {
		n += 1 + sozServerDef(uint64(*m.EnterHurt))
	}
	if m.EnterHurtSize != nil {
		l = m.EnterHurtSize.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Res != nil {
		l = len(m.Res)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.EnterSound != nil {
		l = len(m.EnterSound)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.SkillList) > 0 {
		for _, e := range m.SkillList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaVipSale) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.Price != nil {
		n += 1 + sozServerDef(uint64(*m.Price))
	}
	if m.BaseDiamond != nil {
		n += 1 + sozServerDef(uint64(*m.BaseDiamond))
	}
	if m.ExtraDiamond != nil {
		n += 1 + sozServerDef(uint64(*m.ExtraDiamond))
	}
	if m.FirstFlag != nil {
		n += 1 + sozServerDef(uint64(*m.FirstFlag))
	}
	if m.FirstExtraDiamond != nil {
		n += 1 + sozServerDef(uint64(*m.FirstExtraDiamond))
	}
	if m.IapID != nil {
		l = len(m.IapID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.IapSuffix != nil {
		l = len(m.IapSuffix)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaZuipao) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if m.SkillID != nil {
		n += 1 + sozServerDef(uint64(*m.SkillID))
	}
	if m.FaceCount != nil {
		n += 1 + sozServerDef(uint64(*m.FaceCount))
	}
	if m.NeedLevel != nil {
		n += 1 + sozServerDef(uint64(*m.NeedLevel))
	}
	if m.AddEnergyPercent != nil {
		n += 5
	}
	if len(m.SkillLevelList) > 0 {
		for _, e := range m.SkillLevelList {
			n += 1 + sovServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaParkShopRandom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if len(m.ItemIdList) > 0 {
		for _, e := range m.ItemIdList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaNiudan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if len(m.PreviewReward) > 0 {
		for _, e := range m.PreviewReward {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.Showspeed != nil {
		n += 1 + sozServerDef(uint64(*m.Showspeed))
	}
	if m.Markshow != nil {
		n += 1 + sozServerDef(uint64(*m.Markshow))
	}
	if len(m.ButtonList) > 0 {
		for _, e := range m.ButtonList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.TextQuality) > 0 {
		for _, e := range m.TextQuality {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.TextProb) > 0 {
		for _, e := range m.TextProb {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.TextDesID != nil {
		l = len(m.TextDesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaPet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.DesID != nil {
		l = len(m.DesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.PaintID != nil {
		n += 1 + sozServerDef(uint64(*m.PaintID))
	}
	if m.IconID != nil {
		n += 1 + sozServerDef(uint64(*m.IconID))
	}
	if m.SkillIcon != nil {
		n += 1 + sozServerDef(uint64(*m.SkillIcon))
	}
	if m.EvolveLevel != nil {
		n += 1 + sozServerDef(uint64(*m.EvolveLevel))
	}
	if m.EvolvePetId != nil {
		n += 1 + sozServerDef(uint64(*m.EvolvePetId))
	}
	if len(m.EvolveCostList) > 0 {
		for _, e := range m.EvolveCostList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.Res != nil {
		l = len(m.Res)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.ActNormalList) > 0 {
		for _, e := range m.ActNormalList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.ActSkillList) > 0 {
		for _, e := range m.ActSkillList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.ActSkillProbList) > 0 {
		for _, e := range m.ActSkillProbList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.DiedSound != nil {
		l = len(m.DiedSound)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.HurtPauseFrame != nil {
		n += 1 + sozServerDef(uint64(*m.HurtPauseFrame))
	}
	if m.BoundingBox != nil {
		l = m.BoundingBox.Size()
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.HitPos != nil {
		l = m.HitPos.Size()
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.TopPos != nil {
		l = m.TopPos.Size()
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.MaxLevel != nil {
		n += 2 + sozServerDef(uint64(*m.MaxLevel))
	}
	if m.Weight != nil {
		n += 2 + sozServerDef(uint64(*m.Weight))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaParkPlace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.SceneID != nil {
		n += 1 + sozServerDef(uint64(*m.SceneID))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaRoleCreate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if len(m.HatList) > 0 {
		for _, e := range m.HatList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.FaceList) > 0 {
		for _, e := range m.FaceList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.WeaponList) > 0 {
		for _, e := range m.WeaponList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.WingList) > 0 {
		for _, e := range m.WingList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaNiudanShopRandom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if len(m.ItemIdList) > 0 {
		for _, e := range m.ItemIdList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaSkillShopRandom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if len(m.ItemIdList) > 0 {
		for _, e := range m.ItemIdList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.ItemID != nil {
		n += 1 + sozServerDef(uint64(*m.ItemID))
	}
	if m.Count != nil {
		n += 1 + sozServerDef(uint64(*m.Count))
	}
	if m.MiniRate != nil {
		n += 1 + sozServerDef(uint64(*m.MiniRate))
	}
	if m.MaxRate != nil {
		n += 1 + sozServerDef(uint64(*m.MaxRate))
	}
	if m.IsResetTime != nil {
		n += 1 + sozServerDef(uint64(*m.IsResetTime))
	}
	if m.GetTime != nil {
		n += 1 + sozServerDef(uint64(*m.GetTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaPetTalentLevel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if len(m.ActLevelList) > 0 {
		for _, e := range m.ActLevelList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.PassiveLevelList) > 0 {
		for _, e := range m.PassiveLevelList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaNotable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if len(m.ParameterList) > 0 {
		for _, e := range m.ParameterList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.DesID != nil {
		l = len(m.DesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaFace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.DesID != nil {
		l = len(m.DesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.ResID != nil {
		n += 1 + sozServerDef(uint64(*m.ResID))
	}
	if m.Atk != nil {
		n += 1 + sozServerDef(uint64(*m.Atk))
	}
	if m.Hp != nil {
		n += 1 + sozServerDef(uint64(*m.Hp))
	}
	if m.Def != nil {
		n += 1 + sozServerDef(uint64(*m.Def))
	}
	if m.Crit != nil {
		n += 1 + sozServerDef(uint64(*m.Crit))
	}
	if m.Block != nil {
		n += 1 + sozServerDef(uint64(*m.Block))
	}
	if m.Speed != nil {
		n += 1 + sozServerDef(uint64(*m.Speed))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaDailyTask) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if len(m.SubTaskList) > 0 {
		for _, e := range m.SubTaskList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaArenaNpc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rank != nil {
		n += 1 + sozServerDef(uint64(*m.Rank))
	}
	if m.Name != nil {
		l = len(m.Name)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Temp != nil {
		n += 1 + sozServerDef(uint64(*m.Temp))
	}
	if m.Pos != nil {
		n += 1 + sozServerDef(uint64(*m.Pos))
	}
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if m.Dif != nil {
		n += 1 + sozServerDef(uint64(*m.Dif))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaCard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.DescID != nil {
		l = len(m.DescID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if m.Quality != nil {
		n += 1 + sozServerDef(uint64(*m.Quality))
	}
	if m.NeedEnergy != nil {
		n += 1 + sozServerDef(uint64(*m.NeedEnergy))
	}
	if m.Icon != nil {
		l = len(m.Icon)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.GroupIcon != nil {
		l = len(m.GroupIcon)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.TargetType != nil {
		n += 1 + sozServerDef(uint64(*m.TargetType))
	}
	if m.TargetCount != nil {
		n += 1 + sozServerDef(uint64(*m.TargetCount))
	}
	if m.ReleaseEffID != nil {
		n += 1 + sozServerDef(uint64(*m.ReleaseEffID))
	}
	if m.ReleasePos != nil {
		n += 1 + sozServerDef(uint64(*m.ReleasePos))
	}
	if len(m.AtkTimeList) > 0 {
		n += 5 * len(m.AtkTimeList)
	}
	if len(m.AtkHurtPerList) > 0 {
		for _, e := range m.AtkHurtPerList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.AtkEndTime != nil {
		n += 5
	}
	if len(m.HurtEffList) > 0 {
		for _, e := range m.HurtEffList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.PerValue != nil {
		n += 2 + sozServerDef(uint64(*m.PerValue))
	}
	if m.FixValue != nil {
		n += 2 + sozServerDef(uint64(*m.FixValue))
	}
	if len(m.BuffTargetList) > 0 {
		for _, e := range m.BuffTargetList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.BuffList) > 0 {
		for _, e := range m.BuffList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaHangup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if m.TimeUplimit != nil {
		n += 1 + sozServerDef(uint64(*m.TimeUplimit))
	}
	if m.UnitTime != nil {
		n += 1 + sozServerDef(uint64(*m.UnitTime))
	}
	if m.UnitExp != nil {
		n += 1 + sozServerDef(uint64(*m.UnitExp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaDiamondShopRandom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if len(m.ItemIdList) > 0 {
		for _, e := range m.ItemIdList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaNiudanShop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.ItemID != nil {
		n += 1 + sozServerDef(uint64(*m.ItemID))
	}
	if m.Num != nil {
		n += 1 + sozServerDef(uint64(*m.Num))
	}
	if m.CostType != nil {
		n += 1 + sozServerDef(uint64(*m.CostType))
	}
	if m.Price != nil {
		n += 1 + sozServerDef(uint64(*m.Price))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaSuitShop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != nil {
		n += 1 + sozServerDef(uint64(*m.Index))
	}
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if len(m.Duration) > 0 {
		for _, e := range m.Duration {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.CostType != nil {
		n += 1 + sozServerDef(uint64(*m.CostType))
	}
	if len(m.Price) > 0 {
		for _, e := range m.Price {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaRisk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.DesID != nil {
		l = len(m.DesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.WaveList) > 0 {
		for _, e := range m.WaveList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.Boss != nil {
		n += 1 + sozServerDef(uint64(*m.Boss))
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if m.ShowType != nil {
		n += 1 + sozServerDef(uint64(*m.ShowType))
	}
	if m.WinCostStamina != nil {
		n += 1 + sozServerDef(uint64(*m.WinCostStamina))
	}
	if m.LoseCostStamina != nil {
		n += 1 + sozServerDef(uint64(*m.LoseCostStamina))
	}
	if m.OpenLevel != nil {
		n += 1 + sozServerDef(uint64(*m.OpenLevel))
	}
	if len(m.OpenDupList) > 0 {
		for _, e := range m.OpenDupList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.WinCondList) > 0 {
		for _, e := range m.WinCondList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.WinArgList) > 0 {
		for _, e := range m.WinArgList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.LoseCondType != nil {
		n += 1 + sozServerDef(uint64(*m.LoseCondType))
	}
	if m.LimitTime != nil {
		n += 1 + sozServerDef(uint64(*m.LimitTime))
	}
	if m.MapID != nil {
		n += 2 + sozServerDef(uint64(*m.MapID))
	}
	if m.StartScreen != nil {
		n += 2 + sozServerDef(uint64(*m.StartScreen))
	}
	if len(m.DropRang) > 0 {
		for _, e := range m.DropRang {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.MonsterBoxID != nil {
		n += 2 + sozServerDef(uint64(*m.MonsterBoxID))
	}
	if m.BossBoxID != nil {
		n += 2 + sozServerDef(uint64(*m.BossBoxID))
	}
	if len(m.ShowRewardList) > 0 {
		for _, e := range m.ShowRewardList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.GetRewardList) > 0 {
		for _, e := range m.GetRewardList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if m.Icon != nil {
		l = len(m.Icon)
		n += 2 + l + sovServerDef(uint64(l))
	}
	if len(m.FirstDropItemList) > 0 {
		for _, e := range m.FirstDropItemList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if m.SuggestFight != nil {
		n += 2 + sozServerDef(uint64(*m.SuggestFight))
	}
	if m.FightCount != nil {
		n += 2 + sozServerDef(uint64(*m.FightCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaGuadraticLevelReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaBlackShopRandom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if len(m.ItemIdList) > 0 {
		for _, e := range m.ItemIdList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaBlackShop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.ItemID != nil {
		n += 1 + sozServerDef(uint64(*m.ItemID))
	}
	if m.Num != nil {
		n += 1 + sozServerDef(uint64(*m.Num))
	}
	if m.CostType != nil {
		n += 1 + sozServerDef(uint64(*m.CostType))
	}
	if m.Price != nil {
		n += 1 + sozServerDef(uint64(*m.Price))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaSceneFail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.SrcSceneId != nil {
		n += 1 + sozServerDef(uint64(*m.SrcSceneId))
	}
	if m.TrySceneId != nil {
		n += 1 + sozServerDef(uint64(*m.TrySceneId))
	}
	if m.ReturnSceneId != nil {
		n += 1 + sozServerDef(uint64(*m.ReturnSceneId))
	}
	if len(m.ReturnBornPosList) > 0 {
		for _, e := range m.ReturnBornPosList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaBathFightStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Step != nil {
		n += 1 + sozServerDef(uint64(*m.Step))
	}
	if m.CdTime != nil {
		n += 1 + sozServerDef(uint64(*m.CdTime))
	}
	if m.NextStepCount != nil {
		l = m.NextStepCount.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.NewInteractToolList) > 0 {
		for _, e := range m.NewInteractToolList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.IsWatersplash != nil {
		n += 1 + sozServerDef(uint64(*m.IsWatersplash))
	}
	if m.BroadcastTimeStep != nil {
		n += 1 + sozServerDef(uint64(*m.BroadcastTimeStep))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaBathToolType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if m.UseCount != nil {
		n += 1 + sozServerDef(uint64(*m.UseCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaArenaTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.Atk != nil {
		n += 1 + sozServerDef(uint64(*m.Atk))
	}
	if m.Def != nil {
		n += 1 + sozServerDef(uint64(*m.Def))
	}
	if m.Hp != nil {
		n += 1 + sozServerDef(uint64(*m.Hp))
	}
	if m.Crit != nil {
		n += 1 + sozServerDef(uint64(*m.Crit))
	}
	if m.Block != nil {
		n += 1 + sozServerDef(uint64(*m.Block))
	}
	if m.Speed != nil {
		n += 1 + sozServerDef(uint64(*m.Speed))
	}
	if m.Act != nil {
		n += 1 + sozServerDef(uint64(*m.Act))
	}
	if m.SuitID != nil {
		n += 1 + sozServerDef(uint64(*m.SuitID))
	}
	if m.FaceID != nil {
		n += 1 + sozServerDef(uint64(*m.FaceID))
	}
	if m.WeaponID != nil {
		n += 1 + sozServerDef(uint64(*m.WeaponID))
	}
	if m.HatID != nil {
		n += 1 + sozServerDef(uint64(*m.HatID))
	}
	if m.WingID != nil {
		n += 1 + sozServerDef(uint64(*m.WingID))
	}
	if len(m.SkillList) > 0 {
		for _, e := range m.SkillList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.SkillLevelList) > 0 {
		for _, e := range m.SkillLevelList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.SkillPropLevelList) > 0 {
		for _, e := range m.SkillPropLevelList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.SuitSkillID != nil {
		n += 2 + sozServerDef(uint64(*m.SuitSkillID))
	}
	if m.SuitSkillLevel != nil {
		n += 2 + sozServerDef(uint64(*m.SuitSkillLevel))
	}
	if m.SuitSkillPropLevel != nil {
		n += 2 + sozServerDef(uint64(*m.SuitSkillPropLevel))
	}
	if len(m.CardList) > 0 {
		for _, e := range m.CardList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaBathFightEnd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.CdTime != nil {
		n += 1 + sozServerDef(uint64(*m.CdTime))
	}
	if len(m.EndConditionList) > 0 {
		for _, e := range m.EndConditionList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaBathStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if m.TypeRatio != nil {
		n += 1 + sozServerDef(uint64(*m.TypeRatio))
	}
	if m.Stamina != nil {
		n += 1 + sozServerDef(uint64(*m.Stamina))
	}
	if m.Exp != nil {
		n += 1 + sozServerDef(uint64(*m.Exp))
	}
	if m.Fullness != nil {
		n += 1 + sozServerDef(uint64(*m.Fullness))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaStoneExchange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemId != nil {
		n += 1 + sozServerDef(uint64(*m.ItemId))
	}
	if m.NeedItem != nil {
		l = m.NeedItem.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaMinigameRank) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if len(m.DisplayInfoList) > 0 {
		for _, e := range m.DisplayInfoList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaFriendLevel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lvl != nil {
		n += 1 + sozServerDef(uint64(*m.Lvl))
	}
	if m.Hp != nil {
		n += 1 + sozServerDef(uint64(*m.Hp))
	}
	if m.Atk != nil {
		n += 1 + sozServerDef(uint64(*m.Atk))
	}
	if m.Def != nil {
		n += 1 + sozServerDef(uint64(*m.Def))
	}
	if m.Crit != nil {
		n += 1 + sozServerDef(uint64(*m.Crit))
	}
	if m.Block != nil {
		n += 1 + sozServerDef(uint64(*m.Block))
	}
	if m.Speed != nil {
		n += 1 + sozServerDef(uint64(*m.Speed))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaMinigameLevel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaGuadraticDup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.Time != nil {
		n += 1 + sozServerDef(uint64(*m.Time))
	}
	if m.MapSize != nil {
		l = m.MapSize.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.BossEnterList) > 0 {
		for _, e := range m.BossEnterList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.BossEnterRect) > 0 {
		for _, e := range m.BossEnterRect {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.MapList) > 0 {
		for _, b := range m.MapList {
			l = len(b)
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.DataFile != nil {
		l = len(m.DataFile)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.BornPosList) > 0 {
		for _, e := range m.BornPosList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.Music != nil {
		l = len(m.Music)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaMinigameScore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Score != nil {
		n += 1 + sozServerDef(uint64(*m.Score))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaArenaShopRandom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if len(m.ItemIdList) > 0 {
		for _, e := range m.ItemIdList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaRoleLevel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lvl != nil {
		n += 1 + sozServerDef(uint64(*m.Lvl))
	}
	if m.Exp != nil {
		n += 1 + sozServerDef(uint64(*m.Exp))
	}
	if m.SkillPoint != nil {
		n += 1 + sozServerDef(uint64(*m.SkillPoint))
	}
	if m.Stamina != nil {
		n += 1 + sozServerDef(uint64(*m.Stamina))
	}
	if m.Hp != nil {
		n += 1 + sozServerDef(uint64(*m.Hp))
	}
	if m.Atk != nil {
		n += 1 + sozServerDef(uint64(*m.Atk))
	}
	if m.Def != nil {
		n += 1 + sozServerDef(uint64(*m.Def))
	}
	if m.Crit != nil {
		n += 1 + sozServerDef(uint64(*m.Crit))
	}
	if m.Block != nil {
		n += 1 + sozServerDef(uint64(*m.Block))
	}
	if m.Speed != nil {
		n += 1 + sozServerDef(uint64(*m.Speed))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaArenaShop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.ItemID != nil {
		n += 1 + sozServerDef(uint64(*m.ItemID))
	}
	if m.Num != nil {
		n += 1 + sozServerDef(uint64(*m.Num))
	}
	if m.CostType != nil {
		n += 1 + sozServerDef(uint64(*m.CostType))
	}
	if m.Price != nil {
		n += 1 + sozServerDef(uint64(*m.Price))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaAvatarConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShopID != nil {
		n += 1 + sozServerDef(uint64(*m.ShopID))
	}
	if m.Interval != nil {
		n += 1 + sozServerDef(uint64(*m.Interval))
	}
	if m.Cost != nil {
		n += 1 + sozServerDef(uint64(*m.Cost))
	}
	if m.Limit != nil {
		n += 1 + sozServerDef(uint64(*m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaPetLevel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if m.Exp != nil {
		n += 1 + sozServerDef(uint64(*m.Exp))
	}
	if m.CritProb != nil {
		n += 1 + sozServerDef(uint64(*m.CritProb))
	}
	if m.Atk != nil {
		n += 1 + sozServerDef(uint64(*m.Atk))
	}
	if m.Def != nil {
		n += 1 + sozServerDef(uint64(*m.Def))
	}
	if m.Hp != nil {
		n += 1 + sozServerDef(uint64(*m.Hp))
	}
	if m.Crit != nil {
		n += 1 + sozServerDef(uint64(*m.Crit))
	}
	if m.Block != nil {
		n += 1 + sozServerDef(uint64(*m.Block))
	}
	if m.Speed != nil {
		n += 1 + sozServerDef(uint64(*m.Speed))
	}
	if m.Act != nil {
		n += 1 + sozServerDef(uint64(*m.Act))
	}
	if m.AtkLimit != nil {
		n += 1 + sozServerDef(uint64(*m.AtkLimit))
	}
	if m.DefLimit != nil {
		n += 1 + sozServerDef(uint64(*m.DefLimit))
	}
	if m.HpLimit != nil {
		n += 1 + sozServerDef(uint64(*m.HpLimit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaFunctionOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.Index != nil {
		n += 1 + sozServerDef(uint64(*m.Index))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if m.Vip != nil {
		n += 1 + sozServerDef(uint64(*m.Vip))
	}
	if len(m.TaskList) > 0 {
		for _, e := range m.TaskList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.RiskList) > 0 {
		for _, e := range m.RiskList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.Icon != nil {
		l = len(m.Icon)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.TipPicList) > 0 {
		for _, b := range m.TipPicList {
			l = len(b)
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.TipTextID != nil {
		l = len(m.TipTextID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.TipTextList) > 0 {
		for _, b := range m.TipTextList {
			l = len(b)
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaMainTaskModule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.ModuleType != nil {
		n += 1 + sozServerDef(uint64(*m.ModuleType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaHouseStorage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.MaxCount != nil {
		n += 1 + sozServerDef(uint64(*m.MaxCount))
	}
	if m.CostItem != nil {
		l = m.CostItem.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaBuyBitcoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.BuyItem != nil {
		l = m.BuyItem.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.CostIem != nil {
		l = m.CostIem.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaSword) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.MinLevel != nil {
		n += 1 + sozServerDef(uint64(*m.MinLevel))
	}
	if m.MaxLevel != nil {
		n += 1 + sozServerDef(uint64(*m.MaxLevel))
	}
	if m.BaseBagID != nil {
		n += 1 + sozServerDef(uint64(*m.BaseBagID))
	}
	if m.GodBagID != nil {
		n += 1 + sozServerDef(uint64(*m.GodBagID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaArenaHistoryRank) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rank != nil {
		n += 1 + sozServerDef(uint64(*m.Rank))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaBorn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.SceneID != nil {
		n += 1 + sozServerDef(uint64(*m.SceneID))
	}
	if m.Gold != nil {
		n += 1 + sozServerDef(uint64(*m.Gold))
	}
	if m.Stamina != nil {
		n += 1 + sozServerDef(uint64(*m.Stamina))
	}
	if m.Diamond != nil {
		n += 1 + sozServerDef(uint64(*m.Diamond))
	}
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if m.SkillPoint != nil {
		n += 1 + sozServerDef(uint64(*m.SkillPoint))
	}
	if m.Vip != nil {
		n += 1 + sozServerDef(uint64(*m.Vip))
	}
	if len(m.ItemList) > 0 {
		for _, e := range m.ItemList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.FaceList) > 0 {
		for _, e := range m.FaceList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.SuitList) > 0 {
		for _, e := range m.SuitList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.CarList) > 0 {
		for _, e := range m.CarList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.InteractList) > 0 {
		for _, e := range m.InteractList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.LearnSkillList) > 0 {
		for _, e := range m.LearnSkillList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.DressSkillList) > 0 {
		for _, e := range m.DressSkillList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.PetIdList) > 0 {
		for _, e := range m.PetIdList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaSignCost) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != nil {
		n += 1 + sozServerDef(uint64(*m.Count))
	}
	if m.Cost != nil {
		n += 1 + sozServerDef(uint64(*m.Cost))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaMinigame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.SceneID != nil {
		n += 1 + sozServerDef(uint64(*m.SceneID))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.DesID != nil {
		l = len(m.DesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Icon != nil {
		n += 1 + sozServerDef(uint64(*m.Icon))
	}
	if m.Border != nil {
		n += 1 + sozServerDef(uint64(*m.Border))
	}
	if m.Hide != nil {
		n += 1 + sozServerDef(uint64(*m.Hide))
	}
	if m.CostCurrency != nil {
		l = m.CostCurrency.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Music != nil {
		l = len(m.Music)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaGuadraticReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		n += 1 + sozServerDef(uint64(*m.ID))
	}
	if len(m.SingleDayRewardList) > 0 {
		for _, e := range m.SingleDayRewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.DoubleDayRewardList) > 0 {
		for _, e := range m.DoubleDayRewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.SingleDayPercent) > 0 {
		for _, e := range m.SingleDayPercent {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.DoubleDayPercent) > 0 {
		for _, e := range m.DoubleDayPercent {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaRiskFightReset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.CostIem != nil {
		l = m.CostIem.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaEasterEgg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.SceneID != nil {
		n += 1 + sozServerDef(uint64(*m.SceneID))
	}
	if m.NpcID != nil {
		n += 1 + sozServerDef(uint64(*m.NpcID))
	}
	if m.NeedTouchCount != nil {
		n += 1 + sozServerDef(uint64(*m.NeedTouchCount))
	}
	if m.AffectCount != nil {
		n += 1 + sozServerDef(uint64(*m.AffectCount))
	}
	if m.Probability != nil {
		n += 1 + sozServerDef(uint64(*m.Probability))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.CdTime != nil {
		n += 1 + sozServerDef(uint64(*m.CdTime))
	}
	if m.DayGetCount != nil {
		n += 1 + sozServerDef(uint64(*m.DayGetCount))
	}
	if len(m.FirstRewardList) > 0 {
		for _, e := range m.FirstRewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.TouchAnimName != nil {
		l = len(m.TouchAnimName)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.TouchSound != nil {
		l = len(m.TouchSound)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.SuccessAnimName != nil {
		l = len(m.SuccessAnimName)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.SuccessSound != nil {
		l = len(m.SuccessSound)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.GlobalType != nil {
		n += 1 + sozServerDef(uint64(*m.GlobalType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaEquipMake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.OpenLevel != nil {
		n += 1 + sozServerDef(uint64(*m.OpenLevel))
	}
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if m.Quality != nil {
		n += 1 + sozServerDef(uint64(*m.Quality))
	}
	if m.Site != nil {
		n += 1 + sozServerDef(uint64(*m.Site))
	}
	if len(m.CaseOneItemList) > 0 {
		for _, e := range m.CaseOneItemList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.CaseTwoItemList) > 0 {
		for _, e := range m.CaseTwoItemList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.EquipIdOne != nil {
		n += 1 + sozServerDef(uint64(*m.EquipIdOne))
	}
	if m.EquipIdTwo != nil {
		n += 1 + sozServerDef(uint64(*m.EquipIdTwo))
	}
	if m.Prop != nil {
		n += 1 + sozServerDef(uint64(*m.Prop))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaRoleSkill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.DesID != nil {
		l = len(m.DesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.SkillLevelList) > 0 {
		for _, e := range m.SkillLevelList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.SpecialLevelList) > 0 {
		for _, e := range m.SpecialLevelList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if m.Icon != nil {
		l = len(m.Icon)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.OpenLevel != nil {
		n += 1 + sozServerDef(uint64(*m.OpenLevel))
	}
	if len(m.LearnItemList) > 0 {
		for _, e := range m.LearnItemList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.RateList) > 0 {
		for _, e := range m.RateList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.ProfiList) > 0 {
		for _, e := range m.ProfiList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.UpItemList) > 0 {
		for _, e := range m.UpItemList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.ShowType != nil {
		n += 1 + sozServerDef(uint64(*m.ShowType))
	}
	if m.Quality != nil {
		n += 1 + sozServerDef(uint64(*m.Quality))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaDailyActivityGrowReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.BaseReward != nil {
		l = m.BaseReward.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaEquipFix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Quality != nil {
		n += 1 + sozServerDef(uint64(*m.Quality))
	}
	if m.FixNeedItemId != nil {
		n += 1 + sozServerDef(uint64(*m.FixNeedItemId))
	}
	if m.EveryNeedNum != nil {
		n += 1 + sozServerDef(uint64(*m.EveryNeedNum))
	}
	if m.EveryNeedTime != nil {
		n += 1 + sozServerDef(uint64(*m.EveryNeedTime))
	}
	if m.FastFixCost != nil {
		l = m.FastFixCost.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaNiudanPackage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.LevelSection != nil {
		l = m.LevelSection.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.PackageList) > 0 {
		for _, e := range m.PackageList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaTransport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.ResType != nil {
		n += 1 + sozServerDef(uint64(*m.ResType))
	}
	if m.Res != nil {
		l = len(m.Res)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.IsFlipX != nil {
		n += 1 + sozServerDef(uint64(*m.IsFlipX))
	}
	if m.IsFlipY != nil {
		n += 1 + sozServerDef(uint64(*m.IsFlipY))
	}
	if m.Rotate != nil {
		n += 1 + sozServerDef(uint64(*m.Rotate))
	}
	if len(m.TargetList) > 0 {
		for _, e := range m.TargetList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.UnlockRes != nil {
		l = len(m.UnlockRes)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.UnlockPos) > 0 {
		for _, e := range m.UnlockPos {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaGuadraticBossSkill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.AtkDistance != nil {
		n += 1 + sozServerDef(uint64(*m.AtkDistance))
	}
	if m.Hurt != nil {
		n += 1 + sozServerDef(uint64(*m.Hurt))
	}
	if m.HurtRect != nil {
		l = m.HurtRect.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.AtkSound != nil {
		l = len(m.AtkSound)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.PreTime != nil {
		n += 5
	}
	if m.AnimName != nil {
		l = len(m.AnimName)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.EffectRes != nil {
		l = len(m.EffectRes)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.SelfEffectRes != nil {
		l = len(m.SelfEffectRes)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaSkillHole) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if len(m.UnlockItemList) > 0 {
		for _, e := range m.UnlockItemList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.UnlockVipLevel != nil {
		n += 1 + sozServerDef(uint64(*m.UnlockVipLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaRandomBox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.MinLevel != nil {
		n += 1 + sozServerDef(uint64(*m.MinLevel))
	}
	if m.MaxLevel != nil {
		n += 1 + sozServerDef(uint64(*m.MaxLevel))
	}
	if m.RewardID != nil {
		n += 1 + sozServerDef(uint64(*m.RewardID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaCommonShop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.TalkID != nil {
		l = len(m.TalkID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.ResType != nil {
		n += 1 + sozServerDef(uint64(*m.ResType))
	}
	if m.Icon != nil {
		l = len(m.Icon)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Scale != nil {
		n += 5
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if m.Period != nil {
		n += 1 + sozServerDef(uint64(*m.Period))
	}
	if len(m.WeekdayList) > 0 {
		for _, e := range m.WeekdayList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.FixTimeList) > 0 {
		for _, e := range m.FixTimeList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.LimitTimeList) > 0 {
		for _, e := range m.LimitTimeList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.PriceList) > 0 {
		for _, e := range m.PriceList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.UpdateDesID != nil {
		l = len(m.UpdateDesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.CellNum != nil {
		n += 1 + sozServerDef(uint64(*m.CellNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaParkItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.ItemID != nil {
		n += 1 + sozServerDef(uint64(*m.ItemID))
	}
	if m.EffectType != nil {
		n += 1 + sozServerDef(uint64(*m.EffectType))
	}
	if len(m.ValueList) > 0 {
		for _, e := range m.ValueList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaDailySubtask) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.DesID != nil {
		l = len(m.DesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.ConditionType != nil {
		n += 1 + sozServerDef(uint64(*m.ConditionType))
	}
	if m.ConditionValue != nil {
		n += 1 + sozServerDef(uint64(*m.ConditionValue))
	}
	if len(m.Reward) > 0 {
		for _, e := range m.Reward {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.Activity != nil {
		n += 1 + sozServerDef(uint64(*m.Activity))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaInteraction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.NameAct != nil {
		l = len(m.NameAct)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.UnlockDesID != nil {
		l = len(m.UnlockDesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.IconID != nil {
		n += 1 + sozServerDef(uint64(*m.IconID))
	}
	if m.InitiatorCSB != nil {
		l = len(m.InitiatorCSB)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.InitiatorAction != nil {
		l = len(m.InitiatorAction)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.InitiatorAction2 != nil {
		l = len(m.InitiatorAction2)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.InitiatorEffect != nil {
		l = len(m.InitiatorEffect)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.InitiatorEffectFail != nil {
		l = len(m.InitiatorEffectFail)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.LoopType != nil {
		n += 1 + sozServerDef(uint64(*m.LoopType))
	}
	if m.ConsumerType != nil {
		n += 1 + sozServerDef(uint64(*m.ConsumerType))
	}
	if m.ConsumerTime != nil {
		n += 5
	}
	if m.ConsumerEffect != nil {
		l = len(m.ConsumerEffect)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.ConsumerCSB != nil {
		l = len(m.ConsumerCSB)
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.ConsumerAction != nil {
		l = len(m.ConsumerAction)
		n += 2 + l + sovServerDef(uint64(l))
	}
	if len(m.DeltaPos) > 0 {
		for _, e := range m.DeltaPos {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.EffectType != nil {
		n += 2 + sozServerDef(uint64(*m.EffectType))
	}
	if m.Radius != nil {
		n += 2 + sozServerDef(uint64(*m.Radius))
	}
	if len(m.Size_) > 0 {
		for _, e := range m.Size_ {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.CdTime != nil {
		n += 2 + sozServerDef(uint64(*m.CdTime))
	}
	if len(m.EffectSelfList) > 0 {
		for _, e := range m.EffectSelfList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.EffectOtherList) > 0 {
		for _, e := range m.EffectOtherList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.InteractToolType != nil {
		n += 2 + sozServerDef(uint64(*m.InteractToolType))
	}
	if m.InitiatorMusic != nil {
		l = len(m.InitiatorMusic)
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.IsMusicLoop != nil {
		n += 2 + sozServerDef(uint64(*m.IsMusicLoop))
	}
	if m.ConsumerMusic != nil {
		l = len(m.ConsumerMusic)
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaGiftBag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.RandomCount != nil {
		n += 1 + sozServerDef(uint64(*m.RandomCount))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaMinigameShopRandom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if len(m.ItemIdList) > 0 {
		for _, e := range m.ItemIdList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaSwordResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if len(m.RateList) > 0 {
		for _, e := range m.RateList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.EventList) > 0 {
		for _, e := range m.EventList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.ResultList) > 0 {
		for _, e := range m.ResultList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaNpcInteract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NpcID != nil {
		n += 1 + sozServerDef(uint64(*m.NpcID))
	}
	if m.IsRepeat != nil {
		n += 1 + sozServerDef(uint64(*m.IsRepeat))
	}
	if m.CdTime != nil {
		n += 1 + sozServerDef(uint64(*m.CdTime))
	}
	if m.ActionTime != nil {
		n += 5
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Sound != nil {
		l = len(m.Sound)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.IsMusic != nil {
		n += 1 + sozServerDef(uint64(*m.IsMusic))
	}
	if m.IsAudioEffectAll != nil {
		n += 1 + sozServerDef(uint64(*m.IsAudioEffectAll))
	}
	if len(m.MutexIDList) > 0 {
		for _, e := range m.MutexIDList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaFaceLvl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if m.Count != nil {
		n += 1 + sozServerDef(uint64(*m.Count))
	}
	if m.DesID != nil {
		l = len(m.DesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.LockLvl != nil {
		n += 1 + sozServerDef(uint64(*m.LockLvl))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaEquipBag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.UpLimit != nil {
		n += 1 + sozServerDef(uint64(*m.UpLimit))
	}
	if len(m.Cost) > 0 {
		for _, e := range m.Cost {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaMainTask) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.PreTalkID != nil {
		n += 1 + sozServerDef(uint64(*m.PreTalkID))
	}
	if m.NexTalkID != nil {
		n += 1 + sozServerDef(uint64(*m.NexTalkID))
	}
	if m.CompleteTalkID != nil {
		n += 1 + sozServerDef(uint64(*m.CompleteTalkID))
	}
	if m.DesID != nil {
		l = len(m.DesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if len(m.CompleteIf) > 0 {
		for _, e := range m.CompleteIf {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.IsHasPreTask != nil {
		n += 1 + sozServerDef(uint64(*m.IsHasPreTask))
	}
	if len(m.NexIDList) > 0 {
		for _, e := range m.NexIDList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.FuncID != nil {
		n += 1 + sozServerDef(uint64(*m.FuncID))
	}
	if len(m.RiskID) > 0 {
		for _, e := range m.RiskID {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.FriendCount != nil {
		n += 1 + sozServerDef(uint64(*m.FriendCount))
	}
	if m.KillCount != nil {
		n += 1 + sozServerDef(uint64(*m.KillCount))
	}
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if m.InteractTime != nil {
		n += 2 + sozServerDef(uint64(*m.InteractTime))
	}
	if len(m.InteractNpcList) > 0 {
		for _, e := range m.InteractNpcList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if m.ArenaOkTime != nil {
		n += 2 + sozServerDef(uint64(*m.ArenaOkTime))
	}
	if m.BathWashTime != nil {
		n += 2 + sozServerDef(uint64(*m.BathWashTime))
	}
	if m.OnlineTotalTime != nil {
		n += 2 + sozServerDef(uint64(*m.OnlineTotalTime))
	}
	if m.NpcID != nil {
		n += 2 + sozServerDef(uint64(*m.NpcID))
	}
	if len(m.AcceptRewardList) > 0 {
		for _, e := range m.AcceptRewardList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if m.CanGiveUp != nil {
		n += 2 + sozServerDef(uint64(*m.CanGiveUp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaExchangeGold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != nil {
		n += 1 + sozServerDef(uint64(*m.Time))
	}
	if m.CountDiamond != nil {
		n += 1 + sozServerDef(uint64(*m.CountDiamond))
	}
	if len(m.GetGold) > 0 {
		for _, e := range m.GetGold {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaSuit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.DesID != nil {
		l = len(m.DesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.IsSpecial != nil {
		n += 1 + sozServerDef(uint64(*m.IsSpecial))
	}
	if m.ResID != nil {
		n += 1 + sozServerDef(uint64(*m.ResID))
	}
	if m.Atk != nil {
		n += 1 + sozServerDef(uint64(*m.Atk))
	}
	if m.Hp != nil {
		n += 1 + sozServerDef(uint64(*m.Hp))
	}
	if m.Def != nil {
		n += 1 + sozServerDef(uint64(*m.Def))
	}
	if m.Crit != nil {
		n += 1 + sozServerDef(uint64(*m.Crit))
	}
	if m.Block != nil {
		n += 1 + sozServerDef(uint64(*m.Block))
	}
	if m.Speed != nil {
		n += 1 + sozServerDef(uint64(*m.Speed))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaGlobalConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.SceneMoveSpeed != nil {
		n += 1 + sozServerDef(uint64(*m.SceneMoveSpeed))
	}
	if m.ActArea != nil {
		n += 1 + sozServerDef(uint64(*m.ActArea))
	}
	if m.SwordInterval != nil {
		n += 1 + sozServerDef(uint64(*m.SwordInterval))
	}
	if m.LevelUpStamina != nil {
		n += 1 + sozServerDef(uint64(*m.LevelUpStamina))
	}
	if m.BuyGetStamina != nil {
		n += 1 + sozServerDef(uint64(*m.BuyGetStamina))
	}
	if m.StaminaInterval != nil {
		n += 1 + sozServerDef(uint64(*m.StaminaInterval))
	}
	if m.SwordGodProb != nil {
		n += 1 + sozServerDef(uint64(*m.SwordGodProb))
	}
	if m.SignDivisor != nil {
		n += 1 + sozServerDef(uint64(*m.SignDivisor))
	}
	if m.SignPakageID != nil {
		n += 1 + sozServerDef(uint64(*m.SignPakageID))
	}
	if len(m.SignShowList) > 0 {
		for _, e := range m.SignShowList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.SwordCount != nil {
		n += 1 + sozServerDef(uint64(*m.SwordCount))
	}
	if m.ArenaCount != nil {
		n += 1 + sozServerDef(uint64(*m.ArenaCount))
	}
	if m.ArenaCD != nil {
		n += 1 + sozServerDef(uint64(*m.ArenaCD))
	}
	if m.ArenaClearCDCost != nil {
		l = m.ArenaClearCDCost.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.FastTransItemID != nil {
		n += 2 + sozServerDef(uint64(*m.FastTransItemID))
	}
	if len(m.ArenaDayRewardList) > 0 {
		for _, e := range m.ArenaDayRewardList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.EquipStrengthItemId != nil {
		n += 2 + sozServerDef(uint64(*m.EquipStrengthItemId))
	}
	if m.EquipResolveReturnPercent != nil {
		n += 2 + sozServerDef(uint64(*m.EquipResolveReturnPercent))
	}
	if m.EquipDeclineParameter != nil {
		l = m.EquipDeclineParameter.Size()
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.FriendAssistCdTime != nil {
		n += 2 + sozServerDef(uint64(*m.FriendAssistCdTime))
	}
	if m.RechargeExchangeScale != nil {
		n += 2 + sozServerDef(uint64(*m.RechargeExchangeScale))
	}
	if m.BathFullnessUpperlimit != nil {
		n += 2 + sozServerDef(uint64(*m.BathFullnessUpperlimit))
	}
	if m.InitCarport != nil {
		n += 2 + sozServerDef(uint64(*m.InitCarport))
	}
	if m.InitRepairCarCount != nil {
		n += 2 + sozServerDef(uint64(*m.InitRepairCarCount))
	}
	if m.ParkStopCDTime != nil {
		n += 2 + sozServerDef(uint64(*m.ParkStopCDTime))
	}
	if m.ParkProtectCDTime != nil {
		n += 2 + sozServerDef(uint64(*m.ParkProtectCDTime))
	}
	if m.ParkBreakProtectCDTime != nil {
		n += 2 + sozServerDef(uint64(*m.ParkBreakProtectCDTime))
	}
	if m.ParkRepairUnitTime != nil {
		n += 2 + sozServerDef(uint64(*m.ParkRepairUnitTime))
	}
	if m.DiamondReduceRepairCarTime != nil {
		n += 2 + sozServerDef(uint64(*m.DiamondReduceRepairCarTime))
	}
	if m.FastRepairUseItemID != nil {
		n += 2 + sozServerDef(uint64(*m.FastRepairUseItemID))
	}
	if m.ItemReduceRepairCarTime != nil {
		n += 2 + sozServerDef(uint64(*m.ItemReduceRepairCarTime))
	}
	if m.LastCarProtectTime != nil {
		n += 2 + sozServerDef(uint64(*m.LastCarProtectTime))
	}
	if m.ParkSayYesLimitTime != nil {
		n += 2 + sozServerDef(uint64(*m.ParkSayYesLimitTime))
	}
	if m.ParkBenefitUnitTime != nil {
		n += 2 + sozServerDef(uint64(*m.ParkBenefitUnitTime))
	}
	if m.CarportProtectTime != nil {
		n += 2 + sozServerDef(uint64(*m.CarportProtectTime))
	}
	if m.FullParkBenefitRate != nil {
		n += 6
	}
	if m.FullParkRewardID != nil {
		n += 2 + sozServerDef(uint64(*m.FullParkRewardID))
	}
	if m.ParkBreakGetBenefitRate != nil {
		n += 6
	}
	if m.ParkActCount != nil {
		n += 2 + sozServerDef(uint64(*m.ParkActCount))
	}
	if m.ParkActRefreshTime != nil {
		n += 2 + sozServerDef(uint64(*m.ParkActRefreshTime))
	}
	if m.ParkGetExpUnitTime != nil {
		n += 2 + sozServerDef(uint64(*m.ParkGetExpUnitTime))
	}
	if m.ParkSayYesGetExp != nil {
		n += 2 + sozServerDef(uint64(*m.ParkSayYesGetExp))
	}
	if m.ParkBreakGetExp != nil {
		n += 2 + sozServerDef(uint64(*m.ParkBreakGetExp))
	}
	if m.ParkGetRewardProb != nil {
		n += 2 + sozServerDef(uint64(*m.ParkGetRewardProb))
	}
	if m.ParkSayYesGetRewardProb != nil {
		n += 2 + sozServerDef(uint64(*m.ParkSayYesGetRewardProb))
	}
	if m.ParkBreakGetRewardProb != nil {
		n += 2 + sozServerDef(uint64(*m.ParkBreakGetRewardProb))
	}
	if m.SystemParkRefreshTime != nil {
		n += 2 + sozServerDef(uint64(*m.SystemParkRefreshTime))
	}
	if m.SystemParkMaxCount != nil {
		n += 2 + sozServerDef(uint64(*m.SystemParkMaxCount))
	}
	if m.SystemParkByLeftCount != nil {
		n += 2 + sozServerDef(uint64(*m.SystemParkByLeftCount))
	}
	if len(m.SystemParkRandomCaridList) > 0 {
		for _, e := range m.SystemParkRandomCaridList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.ParkStayTimeAfterFullTime != nil {
		n += 2 + sozServerDef(uint64(*m.ParkStayTimeAfterFullTime))
	}
	if m.ParkShopRefreshCarCount != nil {
		n += 2 + sozServerDef(uint64(*m.ParkShopRefreshCarCount))
	}
	if m.ParkDetailMaxCount != nil {
		n += 2 + sozServerDef(uint64(*m.ParkDetailMaxCount))
	}
	if m.ParkSayYesProb != nil {
		n += 2 + sozServerDef(uint64(*m.ParkSayYesProb))
	}
	if m.CarPartID != nil {
		n += 2 + sozServerDef(uint64(*m.CarPartID))
	}
	if len(m.InteractNpcList) > 0 {
		for _, e := range m.InteractNpcList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.HangupRestrictList) > 0 {
		for _, e := range m.HangupRestrictList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.BathRecoveryUpperLimit != nil {
		n += 2 + sozServerDef(uint64(*m.BathRecoveryUpperLimit))
	}
	if m.BathRecoveryInterval != nil {
		n += 2 + sozServerDef(uint64(*m.BathRecoveryInterval))
	}
	if len(m.BathOnceTimeList) > 0 {
		for _, e := range m.BathOnceTimeList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.AddSwordItemList) > 0 {
		for _, e := range m.AddSwordItemList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.ChargeSkillBookItemID != nil {
		n += 2 + sozServerDef(uint64(*m.ChargeSkillBookItemID))
	}
	if len(m.PetTalentRebuildCostList) > 0 {
		for _, e := range m.PetTalentRebuildCostList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if m.CostInterval != nil {
		l = m.CostInterval.Size()
		n += 2 + l + sovServerDef(uint64(l))
	}
	if len(m.PetRefreshTimeList) > 0 {
		for _, e := range m.PetRefreshTimeList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.UploadHeadImageCostList) > 0 {
		for _, e := range m.UploadHeadImageCostList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.ForeverUploadHeadImageCostList) > 0 {
		for _, e := range m.ForeverUploadHeadImageCostList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if m.HorseSpeed != nil {
		n += 2 + sozServerDef(uint64(*m.HorseSpeed))
	}
	if m.HorseInterval != nil {
		n += 6
	}
	if m.CaliburnCountLimit != nil {
		n += 2 + sozServerDef(uint64(*m.CaliburnCountLimit))
	}
	if len(m.CannonPosList) > 0 {
		for _, e := range m.CannonPosList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if m.FightFriendTime != nil {
		n += 2 + sozServerDef(uint64(*m.FightFriendTime))
	}
	if m.GreenHatLimit != nil {
		n += 2 + sozServerDef(uint64(*m.GreenHatLimit))
	}
	if m.GreenHatGap != nil {
		n += 2 + sozServerDef(uint64(*m.GreenHatGap))
	}
	if m.GuadraticMaxRole != nil {
		n += 2 + sozServerDef(uint64(*m.GuadraticMaxRole))
	}
	if m.GuadraticMaxCount != nil {
		n += 2 + sozServerDef(uint64(*m.GuadraticMaxCount))
	}
	if m.GuadraticCost != nil {
		l = m.GuadraticCost.Size()
		n += 2 + l + sovServerDef(uint64(l))
	}
	if len(m.GuadraticOpenTimeList) > 0 {
		for _, e := range m.GuadraticOpenTimeList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if m.GuadraticStartCDTime != nil {
		n += 2 + sozServerDef(uint64(*m.GuadraticStartCDTime))
	}
	if m.GuadraticQuitCD != nil {
		n += 2 + sozServerDef(uint64(*m.GuadraticQuitCD))
	}
	if m.GuadraticEndHurtCD != nil {
		n += 2 + sozServerDef(uint64(*m.GuadraticEndHurtCD))
	}
	if m.GuadraticEndHurt != nil {
		n += 2 + sozServerDef(uint64(*m.GuadraticEndHurt))
	}
	if m.GuadraticAtkCD != nil {
		n += 2 + sozServerDef(uint64(*m.GuadraticAtkCD))
	}
	if m.GuadraticUnderAtkCD != nil {
		n += 2 + sozServerDef(uint64(*m.GuadraticUnderAtkCD))
	}
	if m.GuadraticHP != nil {
		n += 2 + sozServerDef(uint64(*m.GuadraticHP))
	}
	if m.GuadraticHurt != nil {
		n += 2 + sozServerDef(uint64(*m.GuadraticHurt))
	}
	if m.LevelRankNum != nil {
		n += 2 + sozServerDef(uint64(*m.LevelRankNum))
	}
	if m.KillRankNum != nil {
		n += 2 + sozServerDef(uint64(*m.KillRankNum))
	}
	if m.DiamondRankNum != nil {
		n += 2 + sozServerDef(uint64(*m.DiamondRankNum))
	}
	if m.MinigameRankNum != nil {
		n += 2 + sozServerDef(uint64(*m.MinigameRankNum))
	}
	if m.FaceDupReturnItem != nil {
		l = m.FaceDupReturnItem.Size()
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.SellBagGridMaxNum != nil {
		n += 2 + sozServerDef(uint64(*m.SellBagGridMaxNum))
	}
	if len(m.FirstSaveMoneryRewardList) > 0 {
		for _, e := range m.FirstSaveMoneryRewardList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.WeixinRewardList) > 0 {
		for _, e := range m.WeixinRewardList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if m.RechargeLimit != nil {
		n += 2 + sozServerDef(uint64(*m.RechargeLimit))
	}
	if len(m.PetEggReturnItemList) > 0 {
		for _, e := range m.PetEggReturnItemList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if m.FriendNumLimit != nil {
		n += 2 + sozServerDef(uint64(*m.FriendNumLimit))
	}
	if m.PianoTime != nil {
		n += 2 + sozServerDef(uint64(*m.PianoTime))
	}
	if m.UnlockBattleSpeedLevel != nil {
		n += 2 + sozServerDef(uint64(*m.UnlockBattleSpeedLevel))
	}
	if m.PvpAtkRate != nil {
		n += 6
	}
	if m.PvpDefRate != nil {
		n += 6
	}
	if m.DiamondFaceNum != nil {
		n += 2 + sozServerDef(uint64(*m.DiamondFaceNum))
	}
	if m.GoldFaceNum != nil {
		n += 2 + sozServerDef(uint64(*m.GoldFaceNum))
	}
	if len(m.InitRoleAttr) > 0 {
		for _, e := range m.InitRoleAttr {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.PerLevelAttr) > 0 {
		for _, e := range m.PerLevelAttr {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.FightParameter) > 0 {
		for _, e := range m.FightParameter {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.DailyGameItemList) > 0 {
		for _, e := range m.DailyGameItemList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaInteractSystem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if len(m.ChildInteract) > 0 {
		for _, e := range m.ChildInteract {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.ActDesID != nil {
		l = len(m.ActDesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.UnlockCondition) > 0 {
		for _, e := range m.UnlockCondition {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.EnergyPoint != nil {
		n += 1 + sozServerDef(uint64(*m.EnergyPoint))
	}
	if m.IconID != nil {
		n += 1 + sozServerDef(uint64(*m.IconID))
	}
	if m.InitiatorCSB != nil {
		l = len(m.InitiatorCSB)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.InitiatorAction != nil {
		l = len(m.InitiatorAction)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.InitiatorSound != nil {
		l = len(m.InitiatorSound)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.InitiatorAction2 != nil {
		l = len(m.InitiatorAction2)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.InitiatorEffect != nil {
		l = len(m.InitiatorEffect)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.InitiatorEffectFail != nil {
		l = len(m.InitiatorEffectFail)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.LoopType != nil {
		n += 1 + sozServerDef(uint64(*m.LoopType))
	}
	if m.InitiatorHideEffect != nil {
		n += 2 + sozServerDef(uint64(*m.InitiatorHideEffect))
	}
	if m.ConsumerHideEffect != nil {
		n += 2 + sozServerDef(uint64(*m.ConsumerHideEffect))
	}
	if m.ConsumerType != nil {
		n += 2 + sozServerDef(uint64(*m.ConsumerType))
	}
	if m.ConsumerTime != nil {
		n += 6
	}
	if m.ColorDuration != nil {
		n += 6
	}
	if m.ColorRGB != nil {
		l = m.ColorRGB.Size()
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.ConsumerEffect != nil {
		l = len(m.ConsumerEffect)
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.ConsumerCSB != nil {
		l = len(m.ConsumerCSB)
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.ConsumerAction != nil {
		l = len(m.ConsumerAction)
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.ConsumerSound != nil {
		l = len(m.ConsumerSound)
		n += 2 + l + sovServerDef(uint64(l))
	}
	if len(m.DeltaPos) > 0 {
		for _, e := range m.DeltaPos {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.EffectType != nil {
		n += 2 + sozServerDef(uint64(*m.EffectType))
	}
	if m.Radius != nil {
		n += 2 + sozServerDef(uint64(*m.Radius))
	}
	if len(m.Size_) > 0 {
		for _, e := range m.Size_ {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.SortLevel != nil {
		n += 2 + sozServerDef(uint64(*m.SortLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaParkDriver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.Exp != nil {
		n += 1 + sozServerDef(uint64(*m.Exp))
	}
	if len(m.BreakProbList) > 0 {
		for _, e := range m.BreakProbList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.BreakGetRewardItem) > 0 {
		for _, e := range m.BreakGetRewardItem {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.SayYesProbList) > 0 {
		for _, e := range m.SayYesProbList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.SayYesGetRewardItem) > 0 {
		for _, e := range m.SayYesGetRewardItem {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.SayYesExRewardItem) > 0 {
		for _, e := range m.SayYesExRewardItem {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.RandomItemRange) > 0 {
		for _, e := range m.RandomItemRange {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.GetCarportCount != nil {
		n += 1 + sozServerDef(uint64(*m.GetCarportCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaHouseShop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.FurnitureID != nil {
		n += 1 + sozServerDef(uint64(*m.FurnitureID))
	}
	if m.NeedHouseLevel != nil {
		n += 1 + sozServerDef(uint64(*m.NeedHouseLevel))
	}
	if m.NeedVipLevel != nil {
		n += 1 + sozServerDef(uint64(*m.NeedVipLevel))
	}
	if m.CostItem != nil {
		l = m.CostItem.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.IsNew != nil {
		n += 1 + sozServerDef(uint64(*m.IsNew))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaFindwayGuid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.DescID != nil {
		l = len(m.DescID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.SceneID != nil {
		n += 1 + sozServerDef(uint64(*m.SceneID))
	}
	if m.NpcID != nil {
		n += 1 + sozServerDef(uint64(*m.NpcID))
	}
	if m.SuggestLevel != nil {
		n += 1 + sozServerDef(uint64(*m.SuggestLevel))
	}
	if m.ReachLevel != nil {
		n += 1 + sozServerDef(uint64(*m.ReachLevel))
	}
	if m.AccecpTaskID != nil {
		n += 1 + sozServerDef(uint64(*m.AccecpTaskID))
	}
	if m.FinishTaskID != nil {
		n += 1 + sozServerDef(uint64(*m.FinishTaskID))
	}
	if m.FinishChapterRisk != nil {
		l = m.FinishChapterRisk.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.LockRisk != nil {
		n += 1 + sozServerDef(uint64(*m.LockRisk))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaParkGaragePort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if len(m.CostItemList) > 0 {
		for _, e := range m.CostItemList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaInteractManual) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Num != nil {
		n += 1 + sozServerDef(uint64(*m.Num))
	}
	if m.Energy != nil {
		n += 1 + sozServerDef(uint64(*m.Energy))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaFaceDiscount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != nil {
		n += 1 + sozServerDef(uint64(*m.Index))
	}
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if len(m.Duration) > 0 {
		for _, e := range m.Duration {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.CostType != nil {
		n += 1 + sozServerDef(uint64(*m.CostType))
	}
	if len(m.Price) > 0 {
		for _, e := range m.Price {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.Discount != nil {
		n += 1 + sozServerDef(uint64(*m.Discount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaParkEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.DescID != nil {
		l = len(m.DescID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.TotalTime != nil {
		n += 1 + sozServerDef(uint64(*m.TotalTime))
	}
	if m.CdTime != nil {
		n += 1 + sozServerDef(uint64(*m.CdTime))
	}
	if len(m.CondList) > 0 {
		for _, e := range m.CondList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.SelectCarEffectList) > 0 {
		for _, e := range m.SelectCarEffectList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.ExCarEffectList) > 0 {
		for _, e := range m.ExCarEffectList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaNpc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if m.Head != nil {
		l = len(m.Head)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.ZOrder != nil {
		n += 1 + sozServerDef(uint64(*m.ZOrder))
	}
	if m.ResType != nil {
		n += 1 + sozServerDef(uint64(*m.ResType))
	}
	if m.Res != nil {
		l = len(m.Res)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Scale != nil {
		n += 5
	}
	if m.FlipX != nil {
		n += 1 + sozServerDef(uint64(*m.FlipX))
	}
	if len(m.EffectList) > 0 {
		for _, b := range m.EffectList {
			l = len(b)
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.Pos) > 0 {
		for _, e := range m.Pos {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.TargetList) > 0 {
		for _, e := range m.TargetList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.TalkIDList) > 0 {
		for _, e := range m.TalkIDList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.ClickRect) > 0 {
		n += 5 * len(m.ClickRect)
	}
	if m.TalkHeadPos != nil {
		l = m.TalkHeadPos.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.TalkHeadScale != nil {
		n += 6
	}
	if m.MarkPos != nil {
		l = m.MarkPos.Size()
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.NamePos != nil {
		l = m.NamePos.Size()
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.FindwayPos != nil {
		l = m.FindwayPos.Size()
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaWingExtraEffect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if len(m.RandomNumList) > 0 {
		for _, e := range m.RandomNumList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.ExtraPerList) > 0 {
		for _, e := range m.ExtraPerList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaHouseExpand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.Size_ != nil {
		l = m.Size_.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Icon != nil {
		n += 1 + sozServerDef(uint64(*m.Icon))
	}
	if m.NeedHouseLevel != nil {
		n += 1 + sozServerDef(uint64(*m.NeedHouseLevel))
	}
	if m.NeedVipLevel != nil {
		n += 1 + sozServerDef(uint64(*m.NeedVipLevel))
	}
	if m.CostItem != nil {
		l = m.CostItem.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.DesID != nil {
		l = len(m.DesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.ResID != nil {
		n += 1 + sozServerDef(uint64(*m.ResID))
	}
	if m.UseLevel != nil {
		n += 1 + sozServerDef(uint64(*m.UseLevel))
	}
	if m.Quality != nil {
		n += 1 + sozServerDef(uint64(*m.Quality))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.Price != nil {
		n += 1 + sozServerDef(uint64(*m.Price))
	}
	if len(m.TestWearList) > 0 {
		for _, e := range m.TestWearList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.EffectList) > 0 {
		for _, e := range m.EffectList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.SpID != nil {
		n += 1 + sozServerDef(uint64(*m.SpID))
	}
	if m.ItemSound != nil {
		l = len(m.ItemSound)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.FromID != nil {
		l = len(m.FromID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.UseforID != nil {
		l = len(m.UseforID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaSkillShop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.ItemID != nil {
		n += 1 + sozServerDef(uint64(*m.ItemID))
	}
	if m.Num != nil {
		n += 1 + sozServerDef(uint64(*m.Num))
	}
	if m.CostType != nil {
		n += 1 + sozServerDef(uint64(*m.CostType))
	}
	if m.Price != nil {
		n += 1 + sozServerDef(uint64(*m.Price))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaEquip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.DesID != nil {
		l = len(m.DesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if m.WingCSB != nil {
		l = len(m.WingCSB)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.WingSuffix != nil {
		l = len(m.WingSuffix)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.WingBindType != nil {
		n += 1 + sozServerDef(uint64(*m.WingBindType))
	}
	if m.CsbName != nil {
		l = len(m.CsbName)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.AnimSuffix != nil {
		n += 1 + sozServerDef(uint64(*m.AnimSuffix))
	}
	if m.Quality != nil {
		n += 1 + sozServerDef(uint64(*m.Quality))
	}
	if m.WearLevel != nil {
		n += 1 + sozServerDef(uint64(*m.WearLevel))
	}
	if m.AtkMin != nil {
		n += 1 + sozServerDef(uint64(*m.AtkMin))
	}
	if m.AtkMax != nil {
		n += 1 + sozServerDef(uint64(*m.AtkMax))
	}
	if m.Hp != nil {
		n += 1 + sozServerDef(uint64(*m.Hp))
	}
	if m.Def != nil {
		n += 1 + sozServerDef(uint64(*m.Def))
	}
	if m.Crit != nil {
		n += 2 + sozServerDef(uint64(*m.Crit))
	}
	if m.Block != nil {
		n += 2 + sozServerDef(uint64(*m.Block))
	}
	if m.Speed != nil {
		n += 2 + sozServerDef(uint64(*m.Speed))
	}
	if m.FullAttr != nil {
		n += 2 + sozServerDef(uint64(*m.FullAttr))
	}
	if m.Endurance != nil {
		n += 2 + sozServerDef(uint64(*m.Endurance))
	}
	if m.Icon != nil {
		n += 2 + sozServerDef(uint64(*m.Icon))
	}
	if m.WeaponEffect != nil {
		n += 2 + sozServerDef(uint64(*m.WeaponEffect))
	}
	if m.BasePrice != nil {
		n += 2 + sozServerDef(uint64(*m.BasePrice))
	}
	if m.AtkStarStepValue != nil {
		n += 2 + sozServerDef(uint64(*m.AtkStarStepValue))
	}
	if m.HpStarStepValue != nil {
		n += 2 + sozServerDef(uint64(*m.HpStarStepValue))
	}
	if m.DefStarStepValue != nil {
		n += 2 + sozServerDef(uint64(*m.DefStarStepValue))
	}
	if m.CritStarStepValue != nil {
		n += 2 + sozServerDef(uint64(*m.CritStarStepValue))
	}
	if m.BlockStarStepValue != nil {
		n += 2 + sozServerDef(uint64(*m.BlockStarStepValue))
	}
	if m.SpeedStarStepValue != nil {
		n += 2 + sozServerDef(uint64(*m.SpeedStarStepValue))
	}
	if len(m.ResolveBaseList) > 0 {
		for _, e := range m.ResolveBaseList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.ResolveExtraList) > 0 {
		for _, e := range m.ResolveExtraList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if m.StarUpperLimit != nil {
		n += 2 + sozServerDef(uint64(*m.StarUpperLimit))
	}
	if m.IsResoluble != nil {
		n += 2 + sozServerDef(uint64(*m.IsResoluble))
	}
	if len(m.QualityAtkList) > 0 {
		for _, e := range m.QualityAtkList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.QualityHpList) > 0 {
		for _, e := range m.QualityHpList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.QualityDefList) > 0 {
		for _, e := range m.QualityDefList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.QualityCritList) > 0 {
		for _, e := range m.QualityCritList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.QualityBlockList) > 0 {
		for _, e := range m.QualityBlockList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.QualitySpeedList) > 0 {
		for _, e := range m.QualitySpeedList {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.MoveSpeed != nil {
		n += 2 + sozServerDef(uint64(*m.MoveSpeed))
	}
	if m.CarSound != nil {
		l = len(m.CarSound)
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.RareDegree != nil {
		n += 2 + sozServerDef(uint64(*m.RareDegree))
	}
	if m.FromID != nil {
		l = len(m.FromID)
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.UseforID != nil {
		l = len(m.UseforID)
		n += 2 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaPetActSkill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.DesID != nil {
		l = len(m.DesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Icon != nil {
		l = len(m.Icon)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaVip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.Exp != nil {
		n += 1 + sozServerDef(uint64(*m.Exp))
	}
	if len(m.SpecialRewardList) > 0 {
		for _, e := range m.SpecialRewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.ShowPrice != nil {
		l = m.ShowPrice.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.RealPrice != nil {
		l = m.RealPrice.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.DailyRewardList) > 0 {
		for _, e := range m.DailyRewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.RiskAddSpeed) > 0 {
		for _, e := range m.RiskAddSpeed {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.UploadFaceFlag) > 0 {
		for _, e := range m.UploadFaceFlag {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.UnlockSkillPos) > 0 {
		for _, e := range m.UnlockSkillPos {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.VipChatPP) > 0 {
		for _, e := range m.VipChatPP {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.NoCdArenaFail) > 0 {
		for _, e := range m.NoCdArenaFail {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.FixTimePlus) > 0 {
		for _, e := range m.FixTimePlus {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.VipSkipFight) > 0 {
		for _, e := range m.VipSkipFight {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.BathExpSpeedup) > 0 {
		for _, e := range m.BathExpSpeedup {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.VipPet) > 0 {
		for _, e := range m.VipPet {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.SkilledSpeed) > 0 {
		for _, e := range m.SkilledSpeed {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.VipBMG) > 0 {
		for _, e := range m.VipBMG {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.VipBarrageFont) > 0 {
		for _, e := range m.VipBarrageFont {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.ExpPromoteRatio) > 0 {
		for _, e := range m.ExpPromoteRatio {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.FriendSkillCD) > 0 {
		for _, e := range m.FriendSkillCD {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.ExchangeGoldTime) > 0 {
		for _, e := range m.ExchangeGoldTime {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.BuyArenaCount) > 0 {
		for _, e := range m.BuyArenaCount {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.BuyStaminaCount) > 0 {
		for _, e := range m.BuyStaminaCount {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.BuyBitCoinCount) > 0 {
		for _, e := range m.BuyBitCoinCount {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.FaceRefreshCountUpperLimit) > 0 {
		for _, e := range m.FaceRefreshCountUpperLimit {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.UpdateSkillShopCount) > 0 {
		for _, e := range m.UpdateSkillShopCount {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.UpdateMinigameShopCount) > 0 {
		for _, e := range m.UpdateMinigameShopCount {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.UpdateArenaShopCount) > 0 {
		for _, e := range m.UpdateArenaShopCount {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.UpdateBlackShopCount) > 0 {
		for _, e := range m.UpdateBlackShopCount {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.UpdateDiamondShopCount) > 0 {
		for _, e := range m.UpdateDiamondShopCount {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.SignManualCount) > 0 {
		for _, e := range m.SignManualCount {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.DangerRiskResetCount) > 0 {
		for _, e := range m.DangerRiskResetCount {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.ParkNum) > 0 {
		for _, e := range m.ParkNum {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.VipAct) > 0 {
		for _, e := range m.VipAct {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.VipFurnitureShop) > 0 {
		for _, e := range m.VipFurnitureShop {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.VipVechical) > 0 {
		for _, e := range m.VipVechical {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.RiskDropRate) > 0 {
		for _, e := range m.RiskDropRate {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.VipFellow) > 0 {
		for _, e := range m.VipFellow {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.SelfDefVehicle) > 0 {
		for _, e := range m.SelfDefVehicle {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if len(m.CarportCount) > 0 {
		for _, e := range m.CarportCount {
			n += 2 + sozServerDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaFurniture) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.DesID != nil {
		l = len(m.DesID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Icon != nil {
		n += 1 + sozServerDef(uint64(*m.Icon))
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if m.SubType != nil {
		n += 1 + sozServerDef(uint64(*m.SubType))
	}
	if m.Size_ != nil {
		l = m.Size_.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.DirType != nil {
		n += 1 + sozServerDef(uint64(*m.DirType))
	}
	if m.DirectIndex != nil {
		n += 1 + sozServerDef(uint64(*m.DirectIndex))
	}
	if m.ResType != nil {
		n += 1 + sozServerDef(uint64(*m.ResType))
	}
	if m.Res != nil {
		l = len(m.Res)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.IsCanPass != nil {
		n += 1 + sozServerDef(uint64(*m.IsCanPass))
	}
	if m.OffsetPos != nil {
		l = m.OffsetPos.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.SalePrice != nil {
		l = m.SalePrice.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaArenaBuy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != nil {
		n += 1 + sozServerDef(uint64(*m.Count))
	}
	if m.Diamond != nil {
		n += 1 + sozServerDef(uint64(*m.Diamond))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaBattleWave) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.MonsterList) > 0 {
		for _, e := range m.MonsterList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.PosList) > 0 {
		for _, e := range m.PosList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.TalkID != nil {
		n += 1 + sozServerDef(uint64(*m.TalkID))
	}
	if len(m.LevelList) > 0 {
		for _, e := range m.LevelList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.DiffList) > 0 {
		for _, e := range m.DiffList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.EventID != nil {
		n += 1 + sozServerDef(uint64(*m.EventID))
	}
	if len(m.EventConList) > 0 {
		for _, e := range m.EventConList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.EventArgList != nil {
		l = m.EventArgList.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaMiniWarrior) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if m.NumPerGroup != nil {
		n += 1 + sozServerDef(uint64(*m.NumPerGroup))
	}
	if m.EnemyNumMax != nil {
		n += 1 + sozServerDef(uint64(*m.EnemyNumMax))
	}
	if m.Gap != nil {
		n += 5
	}
	if m.EnemyNum != nil {
		n += 1 + sozServerDef(uint64(*m.EnemyNum))
	}
	if m.AddEnemyGroup != nil {
		n += 1 + sozServerDef(uint64(*m.AddEnemyGroup))
	}
	if m.EnemyAddPerGroup != nil {
		n += 1 + sozServerDef(uint64(*m.EnemyAddPerGroup))
	}
	if m.FirstSpeed != nil {
		n += 1 + sozServerDef(uint64(*m.FirstSpeed))
	}
	if m.AddSpeedGroup != nil {
		n += 1 + sozServerDef(uint64(*m.AddSpeedGroup))
	}
	if m.SpeedAddPerGroup != nil {
		n += 5
	}
	if m.SpeedMaxLimit != nil {
		n += 1 + sozServerDef(uint64(*m.SpeedMaxLimit))
	}
	if m.AttLimit != nil {
		n += 1 + sozServerDef(uint64(*m.AttLimit))
	}
	if m.BossAppearScore != nil {
		n += 1 + sozServerDef(uint64(*m.BossAppearScore))
	}
	if m.BossAppearScoreAdd != nil {
		n += 1 + sozServerDef(uint64(*m.BossAppearScoreAdd))
	}
	if m.BossChangeColorNum != nil {
		n += 1 + sozServerDef(uint64(*m.BossChangeColorNum))
	}
	if m.BossChangeColorNumAdd != nil {
		n += 2 + sozServerDef(uint64(*m.BossChangeColorNumAdd))
	}
	if m.BossGatherEnergy != nil {
		n += 2 + sozServerDef(uint64(*m.BossGatherEnergy))
	}
	if m.BossGatherEnergyAdd != nil {
		n += 2 + sozServerDef(uint64(*m.BossGatherEnergyAdd))
	}
	if m.EnemyScore != nil {
		n += 2 + sozServerDef(uint64(*m.EnemyScore))
	}
	if m.BossScore != nil {
		n += 2 + sozServerDef(uint64(*m.BossScore))
	}
	if m.MapSpeed != nil {
		n += 2 + sozServerDef(uint64(*m.MapSpeed))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaParkCarport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.BenefitRate != nil {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaParkSayyes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.Res != nil {
		l = len(m.Res)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.Effect != nil {
		l = len(m.Effect)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.ValueList) > 0 {
		for _, e := range m.ValueList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.Sound != nil {
		l = len(m.Sound)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaParkRepairPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if len(m.CostItemList) > 0 {
		for _, e := range m.CostItemList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaHouseLevel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozServerDef(uint64(*m.Level))
	}
	if m.Exp != nil {
		n += 1 + sozServerDef(uint64(*m.Exp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaSevenDays) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		n += 1 + sozServerDef(uint64(*m.ID))
	}
	if len(m.Reward) > 0 {
		for _, e := range m.Reward {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaPetPill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemId != nil {
		n += 1 + sozServerDef(uint64(*m.ItemId))
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if m.EffectValue != nil {
		n += 1 + sozServerDef(uint64(*m.EffectValue))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaScene) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if m.Type != nil {
		n += 1 + sozServerDef(uint64(*m.Type))
	}
	if m.NameID != nil {
		l = len(m.NameID)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.MaxRole != nil {
		n += 1 + sozServerDef(uint64(*m.MaxRole))
	}
	if m.IsCanMoreOpen != nil {
		n += 1 + sozServerDef(uint64(*m.IsCanMoreOpen))
	}
	if len(m.MapList) > 0 {
		for _, e := range m.MapList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.DataFile != nil {
		l = len(m.DataFile)
		n += 1 + l + sovServerDef(uint64(l))
	}
	if m.MapSize != nil {
		l = m.MapSize.Size()
		n += 1 + l + sovServerDef(uint64(l))
	}
	if len(m.TransportList) > 0 {
		for _, e := range m.TransportList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if m.FastTransEnable != nil {
		n += 1 + sozServerDef(uint64(*m.FastTransEnable))
	}
	if m.OpenFuncID != nil {
		n += 1 + sozServerDef(uint64(*m.OpenFuncID))
	}
	if len(m.BuildingList) > 0 {
		for _, e := range m.BuildingList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.NpcList) > 0 {
		for _, e := range m.NpcList {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.BornPosList) > 0 {
		for _, e := range m.BornPosList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if len(m.MusicList) > 0 {
		for _, b := range m.MusicList {
			l = len(b)
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.RoleScale != nil {
		n += 6
	}
	if len(m.PetRefreshPosList) > 0 {
		for _, e := range m.PetRefreshPosList {
			l = e.Size()
			n += 2 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaArenaDayRank) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozServerDef(uint64(*m.Id))
	}
	if len(m.RankRect) > 0 {
		for _, e := range m.RankRect {
			n += 1 + sozServerDef(uint64(e))
		}
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovServerDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovServerDef(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozServerDef(x uint64) (n int) {
	return sovServerDef(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LuaSignReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_sign_reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_sign_reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ID = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reward = append(m.Reward, &SignDayReward{})
			if err := m.Reward[len(m.Reward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaParkShop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_park_shop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_park_shop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CarId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Num = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CostType = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Price = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaDailyActivity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_daily_activity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_daily_activity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityValue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ActivityValue = &v
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Reward = append(m.Reward, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Reward) == 0 {
					m.Reward = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Reward = append(m.Reward, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaAchieve) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_achieve: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_achieve: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeName = append(m.TypeName[:0], dAtA[iNdEx:postIndex]...)
			if m.TypeName == nil {
				m.TypeName = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHide", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IsHide = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Des", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Des = append(m.Des[:0], dAtA[iNdEx:postIndex]...)
			if m.Des == nil {
				m.Des = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.ConditionValue = &v2
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AchievePoint", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AchievePoint = &v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ItemConfig{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Quality = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaFaceShop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_face_shop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_face_shop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Index = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Duration = append(m.Duration, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Duration) == 0 {
					m.Duration = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Duration = append(m.Duration, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CostType = &v
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Price = append(m.Price, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Price) == 0 {
					m.Price = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Price = append(m.Price, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaBgm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_bgm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_bgm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgmNameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgmNameID = append(m.BgmNameID[:0], dAtA[iNdEx:postIndex]...)
			if m.BgmNameID == nil {
				m.BgmNameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sound = append(m.Sound[:0], dAtA[iNdEx:postIndex]...)
			if m.Sound == nil {
				m.Sound = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedVipLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NeedVipLevel = &v
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Time = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaArenaReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_arena_reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_arena_reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WinRewardList = append(m.WinRewardList, &ItemConfig{})
			if err := m.WinRewardList[len(m.WinRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoseRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoseRewardList = append(m.LoseRewardList, &ItemConfig{})
			if err := m.LoseRewardList[len(m.LoseRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaArenaSelectRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_arena_select_rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_arena_select_rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.RankRect = append(m.RankRect, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RankRect) == 0 {
					m.RankRect = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.RankRect = append(m.RankRect, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RankRect", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosRectList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PosRectList = append(m.PosRectList, &LuaArenaRect{})
			if err := m.PosRectList[len(m.PosRectList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaDangerChapter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_danger_chapter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_danger_chapter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.DupList = append(m.DupList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DupList) == 0 {
					m.DupList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.DupList = append(m.DupList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DupList", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = append(m.Icon[:0], dAtA[iNdEx:postIndex]...)
			if m.Icon == nil {
				m.Icon = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = append(m.Title[:0], dAtA[iNdEx:postIndex]...)
			if m.Title == nil {
				m.Title = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockIcon", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockIcon = append(m.LockIcon[:0], dAtA[iNdEx:postIndex]...)
			if m.LockIcon == nil {
				m.LockIcon = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ItemConfig{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePic", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SharePic = append(m.SharePic[:0], dAtA[iNdEx:postIndex]...)
			if m.SharePic == nil {
				m.SharePic = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnemyPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnemyPos == nil {
				m.EnemyPos = &LuaPos{}
			}
			if err := m.EnemyPos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaAssistantTip) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_assistant_tip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_assistant_tip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuestionID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuestionID = append(m.QuestionID[:0], dAtA[iNdEx:postIndex]...)
			if m.QuestionID == nil {
				m.QuestionID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnswerID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnswerID = append(m.AnswerID[:0], dAtA[iNdEx:postIndex]...)
			if m.AnswerID == nil {
				m.AnswerID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = append(m.Icon[:0], dAtA[iNdEx:postIndex]...)
			if m.Icon == nil {
				m.Icon = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reward == nil {
				m.Reward = &ItemConfig{}
			}
			if err := m.Reward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaVehicleCompose) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_vehicle_compose: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_vehicle_compose: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Quality = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedItemList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NeedItemList = append(m.NeedItemList, &ItemConfig{})
			if err := m.NeedItemList[len(m.NeedItemList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NeedLevel = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaChapter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_chapter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_chapter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.DupList = append(m.DupList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DupList) == 0 {
					m.DupList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.DupList = append(m.DupList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DupList", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = append(m.Icon[:0], dAtA[iNdEx:postIndex]...)
			if m.Icon == nil {
				m.Icon = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = append(m.Title[:0], dAtA[iNdEx:postIndex]...)
			if m.Title == nil {
				m.Title = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockIcon", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockIcon = append(m.LockIcon[:0], dAtA[iNdEx:postIndex]...)
			if m.LockIcon == nil {
				m.LockIcon = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ItemConfig{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePic", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SharePic = append(m.SharePic[:0], dAtA[iNdEx:postIndex]...)
			if m.SharePic == nil {
				m.SharePic = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnemyPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnemyPos == nil {
				m.EnemyPos = &LuaPos{}
			}
			if err := m.EnemyPos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaBuilding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_building: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_building: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZOrder", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ZOrder = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ResType = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = append(m.Res[:0], dAtA[iNdEx:postIndex]...)
			if m.Res == nil {
				m.Res = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &LuaPos{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaDiamondShop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_diamond_shop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_diamond_shop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemID = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Num = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CostType = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Price = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaParkBreak) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_park_break: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_park_break: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescID = append(m.DescID[:0], dAtA[iNdEx:postIndex]...)
			if m.DescID == nil {
				m.DescID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = append(m.Res[:0], dAtA[iNdEx:postIndex]...)
			if m.Res == nil {
				m.Res = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Effect", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Effect = append(m.Effect[:0], dAtA[iNdEx:postIndex]...)
			if m.Effect == nil {
				m.Effect = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ValueList = append(m.ValueList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ValueList) == 0 {
					m.ValueList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ValueList = append(m.ValueList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueList", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sound = append(m.Sound[:0], dAtA[iNdEx:postIndex]...)
			if m.Sound == nil {
				m.Sound = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaParkCar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_park_car: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_park_car: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Icon = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Quality = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MaxLevel = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkTime = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectValue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ProtectValue = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastProtectValue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.LastProtectValue = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairCostCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.RepairCostCount = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecomposeGetCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DecomposeGetCount = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkUnitBenefit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParkUnitBenefit == nil {
				m.ParkUnitBenefit = &ItemConfig{}
			}
			if err := m.ParkUnitBenefit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddParkUnitBenefitRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.AddParkUnitBenefitRate = &v2
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SayYesReduceMaxParkTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SayYesReduceMaxParkTime = &v
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkOffset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParkOffset == nil {
				m.ParkOffset = &LuaPos{}
			}
			if err := m.ParkOffset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowOffset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowOffset == nil {
				m.ShowOffset = &LuaPos{}
			}
			if err := m.ShowOffset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaPetPassiveTalent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_pet_passive_talent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_pet_passive_talent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TalentId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TalentId = append(m.TalentId[:0], dAtA[iNdEx:postIndex]...)
			if m.TalentId == nil {
				m.TalentId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TalentDesId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TalentDesId = append(m.TalentDesId[:0], dAtA[iNdEx:postIndex]...)
			if m.TalentDesId == nil {
				m.TalentDesId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconId = append(m.IconId[:0], dAtA[iNdEx:postIndex]...)
			if m.IconId == nil {
				m.IconId = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Weight = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ArgList = append(m.ArgList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ArgList) == 0 {
					m.ArgList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ArgList = append(m.ArgList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgList", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ValueList = append(m.ValueList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ValueList) == 0 {
					m.ValueList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ValueList = append(m.ValueList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaEquipManual) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_equip_manual: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_equip_manual: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Num = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reward == nil {
				m.Reward = &ItemConfig{}
			}
			if err := m.Reward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaMinigameShop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_minigame_shop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_minigame_shop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemID = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Num = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CostType = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Price = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaTransInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_trans_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_trans_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.TargetID = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rect = append(m.Rect, &LuaPos{})
			if err := m.Rect[len(m.Rect)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_skill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_skill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescID = append(m.DescID[:0], dAtA[iNdEx:postIndex]...)
			if m.DescID == nil {
				m.DescID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArmaType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ArmaType = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.EventConList = append(m.EventConList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EventConList) == 0 {
					m.EventConList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.EventConList = append(m.EventConList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EventConList", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.EventValList = append(m.EventValList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EventValList) == 0 {
					m.EventValList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.EventValList = append(m.EventValList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EventValList", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.AtkEffList = append(m.AtkEffList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AtkEffList) == 0 {
					m.AtkEffList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.AtkEffList = append(m.AtkEffList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkEffList", wireType)
			}
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.DefEffList = append(m.DefEffList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DefEffList) == 0 {
					m.DefEffList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.DefEffList = append(m.DefEffList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DefEffList", wireType)
			}
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.PreAtkEffList = append(m.PreAtkEffList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PreAtkEffList) == 0 {
					m.PreAtkEffList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.PreAtkEffList = append(m.PreAtkEffList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PreAtkEffList", wireType)
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.PreDefEffList = append(m.PreDefEffList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PreDefEffList) == 0 {
					m.PreDefEffList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.PreDefEffList = append(m.PreDefEffList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PreDefEffList", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkSound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AtkSound = append(m.AtkSound[:0], dAtA[iNdEx:postIndex]...)
			if m.AtkSound == nil {
				m.AtkSound = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.FlyEffIDList = append(m.FlyEffIDList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FlyEffIDList) == 0 {
					m.FlyEffIDList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.FlyEffIDList = append(m.FlyEffIDList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FlyEffIDList", wireType)
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.HurtEffIDList = append(m.HurtEffIDList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.HurtEffIDList) == 0 {
					m.HurtEffIDList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.HurtEffIDList = append(m.HurtEffIDList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtEffIDList", wireType)
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResIndex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ResIndex = &v
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreAnim", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreAnim = append(m.PreAnim[:0], dAtA[iNdEx:postIndex]...)
			if m.PreAnim == nil {
				m.PreAnim = []byte{}
			}
			iNdEx = postIndex
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.PreTime = &v2
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlyAnim", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlyAnim = append(m.FlyAnim[:0], dAtA[iNdEx:postIndex]...)
			if m.FlyAnim == nil {
				m.FlyAnim = []byte{}
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkAnim", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AtkAnim = append(m.AtkAnim[:0], dAtA[iNdEx:postIndex]...)
			if m.AtkAnim == nil {
				m.AtkAnim = []byte{}
			}
			iNdEx = postIndex
		case 20:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.AtkTimeList = append(m.AtkTimeList, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.AtkTimeList) == 0 {
					m.AtkTimeList = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.AtkTimeList = append(m.AtkTimeList, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkTimeList", wireType)
			}
		case 21:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.AtkHurtPerList = append(m.AtkHurtPerList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AtkHurtPerList) == 0 {
					m.AtkHurtPerList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.AtkHurtPerList = append(m.AtkHurtPerList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkHurtPerList", wireType)
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkSoundList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AtkSoundList = append(m.AtkSoundList, make([]byte, postIndex-iNdEx))
			copy(m.AtkSoundList[len(m.AtkSoundList)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShakeTimeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShakeTimeList = append(m.ShakeTimeList, &ShakeConfig{})
			if err := m.ShakeTimeList[len(m.ShakeTimeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkEndTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.AtkEndTime = &v2
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.TargetType = &v
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DisType = &v
		case 27:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.StartBuffTargetList = append(m.StartBuffTargetList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StartBuffTargetList) == 0 {
					m.StartBuffTargetList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.StartBuffTargetList = append(m.StartBuffTargetList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBuffTargetList", wireType)
			}
		case 28:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.StartBuffList = append(m.StartBuffList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StartBuffList) == 0 {
					m.StartBuffList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.StartBuffList = append(m.StartBuffList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBuffList", wireType)
			}
		case 29:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.EndBuffTargetList = append(m.EndBuffTargetList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EndBuffTargetList) == 0 {
					m.EndBuffTargetList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.EndBuffTargetList = append(m.EndBuffTargetList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EndBuffTargetList", wireType)
			}
		case 30:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.EndBuffList = append(m.EndBuffList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EndBuffList) == 0 {
					m.EndBuffList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.EndBuffList = append(m.EndBuffList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EndBuffList", wireType)
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DamageType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DamageType = &v
		case 32:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.PerHurtList = append(m.PerHurtList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PerHurtList) == 0 {
					m.PerHurtList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.PerHurtList = append(m.PerHurtList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PerHurtList", wireType)
			}
		case 33:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.FixHurtList = append(m.FixHurtList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FixHurtList) == 0 {
					m.FixHurtList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.FixHurtList = append(m.FixHurtList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FixHurtList", wireType)
			}
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtSound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HurtSound = append(m.HurtSound[:0], dAtA[iNdEx:postIndex]...)
			if m.HurtSound == nil {
				m.HurtSound = []byte{}
			}
			iNdEx = postIndex
		case 35:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.HurtTypeData = append(m.HurtTypeData, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.HurtTypeData) == 0 {
					m.HurtTypeData = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.HurtTypeData = append(m.HurtTypeData, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtTypeData", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaBuyStamina) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_buy_stamina: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_buy_stamina: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Diamond = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaGuadraticBoss) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_guadratic_boss: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_guadratic_boss: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EnterType = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ExitType = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveSpeed", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MoveSpeed = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EnterTime = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterHurt", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EnterHurt = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterHurtSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnterHurtSize == nil {
				m.EnterHurtSize = &LuaSize{}
			}
			if err := m.EnterHurtSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = append(m.Res[:0], dAtA[iNdEx:postIndex]...)
			if m.Res == nil {
				m.Res = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterSound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnterSound = append(m.EnterSound[:0], dAtA[iNdEx:postIndex]...)
			if m.EnterSound == nil {
				m.EnterSound = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.SkillList = append(m.SkillList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SkillList) == 0 {
					m.SkillList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.SkillList = append(m.SkillList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaVipSale) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_vip_sale: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_vip_sale: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Price = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDiamond", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BaseDiamond = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraDiamond", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ExtraDiamond = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstFlag", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FirstFlag = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstExtraDiamond", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FirstExtraDiamond = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IapID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IapID = append(m.IapID[:0], dAtA[iNdEx:postIndex]...)
			if m.IapID == nil {
				m.IapID = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IapSuffix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IapSuffix = append(m.IapSuffix[:0], dAtA[iNdEx:postIndex]...)
			if m.IapSuffix == nil {
				m.IapSuffix = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaZuipao) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_zuipao: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_zuipao: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SkillID = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FaceCount = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NeedLevel = &v
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddEnergyPercent", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.AddEnergyPercent = &v2
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SkillLevelList = append(m.SkillLevelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SkillLevelList) == 0 {
					m.SkillLevelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SkillLevelList = append(m.SkillLevelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillLevelList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaParkShopRandom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_park_shop_random: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_park_shop_random: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIdList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemIdList = append(m.ItemIdList, &ShopRandomSectionList{})
			if err := m.ItemIdList[len(m.ItemIdList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaNiudan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_niudan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_niudan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.PreviewReward = append(m.PreviewReward, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PreviewReward) == 0 {
					m.PreviewReward = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.PreviewReward = append(m.PreviewReward, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviewReward", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Showspeed", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Showspeed = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Markshow", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Markshow = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ButtonList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ButtonList = append(m.ButtonList, &NiudanButtonInfo{})
			if err := m.ButtonList[len(m.ButtonList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.TextQuality = append(m.TextQuality, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TextQuality) == 0 {
					m.TextQuality = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.TextQuality = append(m.TextQuality, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TextQuality", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.TextProb = append(m.TextProb, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TextProb) == 0 {
					m.TextProb = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.TextProb = append(m.TextProb, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TextProb", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextDesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TextDesID = append(m.TextDesID[:0], dAtA[iNdEx:postIndex]...)
			if m.TextDesID == nil {
				m.TextDesID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaPet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_pet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_pet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesID = append(m.DesID[:0], dAtA[iNdEx:postIndex]...)
			if m.DesID == nil {
				m.DesID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaintID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.PaintID = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IconID = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillIcon", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SkillIcon = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvolveLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EvolveLevel = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvolvePetId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EvolvePetId = &v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvolveCostList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvolveCostList = append(m.EvolveCostList, &ItemConfig{})
			if err := m.EvolveCostList[len(m.EvolveCostList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = append(m.Res[:0], dAtA[iNdEx:postIndex]...)
			if m.Res == nil {
				m.Res = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ActNormalList = append(m.ActNormalList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ActNormalList) == 0 {
					m.ActNormalList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ActNormalList = append(m.ActNormalList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActNormalList", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ActSkillList = append(m.ActSkillList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ActSkillList) == 0 {
					m.ActSkillList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ActSkillList = append(m.ActSkillList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActSkillList", wireType)
			}
		case 13:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ActSkillProbList = append(m.ActSkillProbList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ActSkillProbList) == 0 {
					m.ActSkillProbList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ActSkillProbList = append(m.ActSkillProbList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActSkillProbList", wireType)
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiedSound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiedSound = append(m.DiedSound[:0], dAtA[iNdEx:postIndex]...)
			if m.DiedSound == nil {
				m.DiedSound = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtPauseFrame", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.HurtPauseFrame = &v
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundingBox", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BoundingBox == nil {
				m.BoundingBox = &LuaRect{}
			}
			if err := m.BoundingBox.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HitPos == nil {
				m.HitPos = &LuaPos{}
			}
			if err := m.HitPos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopPos == nil {
				m.TopPos = &LuaPos{}
			}
			if err := m.TopPos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MaxLevel = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Weight = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaParkPlace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_park_place: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_park_place: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SceneID = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaRoleCreate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_role_create: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_role_create: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HatList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HatList = append(m.HatList, &ItemConfig{})
			if err := m.HatList[len(m.HatList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FaceList = append(m.FaceList, &FaceConfig{})
			if err := m.FaceList[len(m.FaceList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeaponList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WeaponList = append(m.WeaponList, &ItemConfig{})
			if err := m.WeaponList[len(m.WeaponList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WingList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WingList = append(m.WingList, &ItemConfig{})
			if err := m.WingList[len(m.WingList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaNiudanShopRandom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_niudan_shop_random: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_niudan_shop_random: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIdList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemIdList = append(m.ItemIdList, &ShopRandomSectionList{})
			if err := m.ItemIdList[len(m.ItemIdList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaSkillShopRandom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_skill_shop_random: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_skill_shop_random: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIdList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemIdList = append(m.ItemIdList, &ShopRandomSectionList{})
			if err := m.ItemIdList[len(m.ItemIdList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemID = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Count = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiniRate", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MiniRate = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRate", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MaxRate = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsResetTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IsResetTime = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GetTime = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaPetTalentLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_pet_talent_level: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_pet_talent_level: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ActLevelList = append(m.ActLevelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ActLevelList) == 0 {
					m.ActLevelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ActLevelList = append(m.ActLevelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActLevelList", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.PassiveLevelList = append(m.PassiveLevelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PassiveLevelList) == 0 {
					m.PassiveLevelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.PassiveLevelList = append(m.PassiveLevelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PassiveLevelList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaNotable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_notable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_notable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ParameterList = append(m.ParameterList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ParameterList) == 0 {
					m.ParameterList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ParameterList = append(m.ParameterList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterList", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesID = append(m.DesID[:0], dAtA[iNdEx:postIndex]...)
			if m.DesID == nil {
				m.DesID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaFace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_face: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_face: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesID = append(m.DesID[:0], dAtA[iNdEx:postIndex]...)
			if m.DesID == nil {
				m.DesID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ResID = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atk", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Atk = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Hp = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Def = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Crit = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Block = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Speed = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaDailyTask) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_daily_task: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_daily_task: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.SubTaskList = append(m.SubTaskList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SubTaskList) == 0 {
					m.SubTaskList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.SubTaskList = append(m.SubTaskList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SubTaskList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaArenaNpc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_arena_npc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_arena_npc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Rank = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Temp = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Pos = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dif", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Dif = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_card: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_card: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescID = append(m.DescID[:0], dAtA[iNdEx:postIndex]...)
			if m.DescID == nil {
				m.DescID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Quality = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedEnergy", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NeedEnergy = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = append(m.Icon[:0], dAtA[iNdEx:postIndex]...)
			if m.Icon == nil {
				m.Icon = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupIcon", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupIcon = append(m.GroupIcon[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupIcon == nil {
				m.GroupIcon = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.TargetType = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.TargetCount = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseEffID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ReleaseEffID = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleasePos", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ReleasePos = &v
		case 13:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.AtkTimeList = append(m.AtkTimeList, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.AtkTimeList) == 0 {
					m.AtkTimeList = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.AtkTimeList = append(m.AtkTimeList, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkTimeList", wireType)
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.AtkHurtPerList = append(m.AtkHurtPerList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AtkHurtPerList) == 0 {
					m.AtkHurtPerList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.AtkHurtPerList = append(m.AtkHurtPerList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkHurtPerList", wireType)
			}
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkEndTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.AtkEndTime = &v2
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.HurtEffList = append(m.HurtEffList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.HurtEffList) == 0 {
					m.HurtEffList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.HurtEffList = append(m.HurtEffList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtEffList", wireType)
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerValue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.PerValue = &v
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixValue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FixValue = &v
		case 19:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.BuffTargetList = append(m.BuffTargetList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BuffTargetList) == 0 {
					m.BuffTargetList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.BuffTargetList = append(m.BuffTargetList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffTargetList", wireType)
			}
		case 20:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.BuffList = append(m.BuffList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BuffList) == 0 {
					m.BuffList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.BuffList = append(m.BuffList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaHangup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_hangup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_hangup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeUplimit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.TimeUplimit = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.UnitTime = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitExp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.UnitExp = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaDiamondShopRandom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_diamond_shop_random: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_diamond_shop_random: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIdList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemIdList = append(m.ItemIdList, &ShopRandomSectionList{})
			if err := m.ItemIdList[len(m.ItemIdList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaNiudanShop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_niudan_shop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_niudan_shop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemID = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Num = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CostType = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Price = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaSuitShop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_suit_shop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_suit_shop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Index = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Duration = append(m.Duration, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Duration) == 0 {
					m.Duration = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Duration = append(m.Duration, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CostType = &v
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Price = append(m.Price, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Price) == 0 {
					m.Price = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Price = append(m.Price, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaRisk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_risk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_risk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesID = append(m.DesID[:0], dAtA[iNdEx:postIndex]...)
			if m.DesID == nil {
				m.DesID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.WaveList = append(m.WaveList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WaveList) == 0 {
					m.WaveList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.WaveList = append(m.WaveList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WaveList", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Boss", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Boss = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ShowType = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinCostStamina", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.WinCostStamina = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoseCostStamina", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.LoseCostStamina = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OpenLevel = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenDupList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenDupList = append(m.OpenDupList, &OpenDupConfig{})
			if err := m.OpenDupList[len(m.OpenDupList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.WinCondList = append(m.WinCondList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WinCondList) == 0 {
					m.WinCondList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.WinCondList = append(m.WinCondList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WinCondList", wireType)
			}
		case 13:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.WinArgList = append(m.WinArgList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WinArgList) == 0 {
					m.WinArgList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.WinArgList = append(m.WinArgList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WinArgList", wireType)
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoseCondType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.LoseCondType = &v
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.LimitTime = &v
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MapID = &v
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartScreen", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.StartScreen = &v
		case 18:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.DropRang = append(m.DropRang, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DropRang) == 0 {
					m.DropRang = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.DropRang = append(m.DropRang, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DropRang", wireType)
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterBoxID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MonsterBoxID = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossBoxID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BossBoxID = &v
		case 21:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ShowRewardList = append(m.ShowRewardList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ShowRewardList) == 0 {
					m.ShowRewardList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ShowRewardList = append(m.ShowRewardList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowRewardList", wireType)
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GetRewardList = append(m.GetRewardList, &ItemConfig{})
			if err := m.GetRewardList[len(m.GetRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = append(m.Icon[:0], dAtA[iNdEx:postIndex]...)
			if m.Icon == nil {
				m.Icon = []byte{}
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstDropItemList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstDropItemList = append(m.FirstDropItemList, &ItemConfig{})
			if err := m.FirstDropItemList[len(m.FirstDropItemList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuggestFight", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SuggestFight = &v
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FightCount = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaGuadraticLevelReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_guadratic_level_reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_guadratic_level_reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ItemConfig{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaBlackShopRandom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_black_shop_random: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_black_shop_random: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIdList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemIdList = append(m.ItemIdList, &ShopRandomSectionList{})
			if err := m.ItemIdList[len(m.ItemIdList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaBlackShop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_black_shop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_black_shop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemID = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Num = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CostType = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Price = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaSceneFail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_scene_fail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_scene_fail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcSceneId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SrcSceneId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrySceneId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.TrySceneId = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnSceneId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ReturnSceneId = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnBornPosList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReturnBornPosList = append(m.ReturnBornPosList, &LuaPos{})
			if err := m.ReturnBornPosList[len(m.ReturnBornPosList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaBathFightStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_bath_fight_step: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_bath_fight_step: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Step = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CdTime = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStepCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextStepCount == nil {
				m.NextStepCount = &BathInteractTool{}
			}
			if err := m.NextStepCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewInteractToolList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewInteractToolList = append(m.NewInteractToolList, &BathInteractTool{})
			if err := m.NewInteractToolList[len(m.NewInteractToolList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWatersplash", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IsWatersplash = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BroadcastTimeStep", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BroadcastTimeStep = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaBathToolType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_bath_tool_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_bath_tool_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.UseCount = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaArenaTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_arena_template: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_arena_template: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atk", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Atk = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Def = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Hp = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Crit = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Block = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Speed = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Act", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Act = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuitID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SuitID = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FaceID = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeaponID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.WeaponID = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HatID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.HatID = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WingID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.WingID = &v
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.SkillList = append(m.SkillList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SkillList) == 0 {
					m.SkillList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.SkillList = append(m.SkillList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillList", wireType)
			}
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.SkillLevelList = append(m.SkillLevelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SkillLevelList) == 0 {
					m.SkillLevelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.SkillLevelList = append(m.SkillLevelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillLevelList", wireType)
			}
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.SkillPropLevelList = append(m.SkillPropLevelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SkillPropLevelList) == 0 {
					m.SkillPropLevelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.SkillPropLevelList = append(m.SkillPropLevelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillPropLevelList", wireType)
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuitSkillID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SuitSkillID = &v
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuitSkillLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SuitSkillLevel = &v
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuitSkillPropLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SuitSkillPropLevel = &v
		case 20:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.CardList = append(m.CardList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CardList) == 0 {
					m.CardList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.CardList = append(m.CardList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CardList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaBathFightEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_bath_fight_end: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_bath_fight_end: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CdTime = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndConditionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndConditionList = append(m.EndConditionList, &BathInteractTool{})
			if err := m.EndConditionList[len(m.EndConditionList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.RewardList = append(m.RewardList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RewardList) == 0 {
					m.RewardList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.RewardList = append(m.RewardList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaBathStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_bath_status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_bath_status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeRatio", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.TypeRatio = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stamina", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Stamina = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Exp = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullness", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Fullness = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaStoneExchange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_stone_exchange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_stone_exchange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemId = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedItem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NeedItem == nil {
				m.NeedItem = &ItemConfig{}
			}
			if err := m.NeedItem.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaMinigameRank) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_minigame_rank: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_minigame_rank: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayInfoList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayInfoList = append(m.DisplayInfoList, &MinigameRankInfo{})
			if err := m.DisplayInfoList[len(m.DisplayInfoList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaFriendLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_friend_level: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_friend_level: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lvl", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Lvl = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Hp = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atk", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Atk = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Def = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Crit = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Block = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Speed = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaMinigameLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_minigame_level: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_minigame_level: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &MinigameLevelReward{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaGuadraticDup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_guadratic_dup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_guadratic_dup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Time = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSize == nil {
				m.MapSize = &LuaSize{}
			}
			if err := m.MapSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossEnterList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BossEnterList = append(m.BossEnterList, &BossEnter{})
			if err := m.BossEnterList[len(m.BossEnterList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossEnterRect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BossEnterRect = append(m.BossEnterRect, &LuaPosRect{})
			if err := m.BossEnterRect[len(m.BossEnterRect)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapList = append(m.MapList, make([]byte, postIndex-iNdEx))
			copy(m.MapList[len(m.MapList)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFile", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataFile = append(m.DataFile[:0], dAtA[iNdEx:postIndex]...)
			if m.DataFile == nil {
				m.DataFile = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BornPosList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BornPosList = append(m.BornPosList, &LuaPos{})
			if err := m.BornPosList[len(m.BornPosList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Music", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Music = append(m.Music[:0], dAtA[iNdEx:postIndex]...)
			if m.Music == nil {
				m.Music = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaMinigameScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_minigame_score: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_minigame_score: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Score = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &MinigameScoreReward{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaArenaShopRandom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_arena_shop_random: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_arena_shop_random: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIdList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemIdList = append(m.ItemIdList, &ShopRandomSectionList{})
			if err := m.ItemIdList[len(m.ItemIdList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaRoleLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_role_level: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_role_level: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lvl", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Lvl = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Exp = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillPoint", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SkillPoint = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stamina", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Stamina = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Hp = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atk", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Atk = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Def = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Crit = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Block = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Speed = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaArenaShop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_arena_shop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_arena_shop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemID = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Num = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CostType = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Price = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaAvatarConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_avatar_config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_avatar_config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ShopID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Interval = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Cost = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Limit = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaPetLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_pet_level: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_pet_level: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Exp = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CritProb", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CritProb = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atk", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Atk = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Def = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Hp = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Crit = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Block = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Speed = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Act", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Act = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkLimit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AtkLimit = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefLimit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DefLimit = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpLimit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.HpLimit = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaFunctionOpen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_function_open: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_function_open: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Index = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Vip = &v
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.TaskList = append(m.TaskList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TaskList) == 0 {
					m.TaskList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.TaskList = append(m.TaskList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskList", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RiskList = append(m.RiskList, &FunctionopenRiskInfo{})
			if err := m.RiskList[len(m.RiskList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = append(m.Icon[:0], dAtA[iNdEx:postIndex]...)
			if m.Icon == nil {
				m.Icon = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TipPicList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TipPicList = append(m.TipPicList, make([]byte, postIndex-iNdEx))
			copy(m.TipPicList[len(m.TipPicList)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TipTextID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TipTextID = append(m.TipTextID[:0], dAtA[iNdEx:postIndex]...)
			if m.TipTextID == nil {
				m.TipTextID = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TipTextList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TipTextList = append(m.TipTextList, make([]byte, postIndex-iNdEx))
			copy(m.TipTextList[len(m.TipTextList)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaMainTaskModule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_main_task_module: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_main_task_module: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ModuleType = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaHouseStorage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_house_storage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_house_storage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MaxCount = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostItem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CostItem == nil {
				m.CostItem = &ItemConfig{}
			}
			if err := m.CostItem.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaBuyBitcoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_buy_bitcoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_buy_bitcoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyItem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuyItem == nil {
				m.BuyItem = &ItemConfig{}
			}
			if err := m.BuyItem.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostIem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CostIem == nil {
				m.CostIem = &ItemConfig{}
			}
			if err := m.CostIem.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaSword) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_sword: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_sword: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MinLevel = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MaxLevel = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseBagID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BaseBagID = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GodBagID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GodBagID = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaArenaHistoryRank) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_arena_history_rank: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_arena_history_rank: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Rank = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ItemConfig{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaBorn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_born: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_born: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SceneID = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Gold = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stamina", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Stamina = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Diamond = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillPoint", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SkillPoint = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Vip = &v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemList = append(m.ItemList, &ItemConfig{})
			if err := m.ItemList[len(m.ItemList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FaceList = append(m.FaceList, &FaceConfig{})
			if err := m.FaceList[len(m.FaceList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuitList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuitList = append(m.SuitList, &SuitConfig{})
			if err := m.SuitList[len(m.SuitList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarList = append(m.CarList, &ItemConfig{})
			if err := m.CarList[len(m.CarList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.InteractList = append(m.InteractList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.InteractList) == 0 {
					m.InteractList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.InteractList = append(m.InteractList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InteractList", wireType)
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.LearnSkillList = append(m.LearnSkillList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LearnSkillList) == 0 {
					m.LearnSkillList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.LearnSkillList = append(m.LearnSkillList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnSkillList", wireType)
			}
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.DressSkillList = append(m.DressSkillList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DressSkillList) == 0 {
					m.DressSkillList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.DressSkillList = append(m.DressSkillList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DressSkillList", wireType)
			}
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.PetIdList = append(m.PetIdList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PetIdList) == 0 {
					m.PetIdList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.PetIdList = append(m.PetIdList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PetIdList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaSignCost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_sign_cost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_sign_cost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Count = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Cost = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaMinigame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_minigame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_minigame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SceneID = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesID = append(m.DesID[:0], dAtA[iNdEx:postIndex]...)
			if m.DesID == nil {
				m.DesID = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Icon = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Border", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Border = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hide", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Hide = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostCurrency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CostCurrency == nil {
				m.CostCurrency = &ItemConfig{}
			}
			if err := m.CostCurrency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Music", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Music = append(m.Music[:0], dAtA[iNdEx:postIndex]...)
			if m.Music == nil {
				m.Music = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaGuadraticReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_guadratic_reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_guadratic_reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ID = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleDayRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SingleDayRewardList = append(m.SingleDayRewardList, &ItemListConfig{})
			if err := m.SingleDayRewardList[len(m.SingleDayRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleDayRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoubleDayRewardList = append(m.DoubleDayRewardList, &ItemListConfig{})
			if err := m.DoubleDayRewardList[len(m.DoubleDayRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.SingleDayPercent = append(m.SingleDayPercent, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SingleDayPercent) == 0 {
					m.SingleDayPercent = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.SingleDayPercent = append(m.SingleDayPercent, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleDayPercent", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.DoubleDayPercent = append(m.DoubleDayPercent, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DoubleDayPercent) == 0 {
					m.DoubleDayPercent = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.DoubleDayPercent = append(m.DoubleDayPercent, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleDayPercent", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaRiskFightReset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_risk_fight_reset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_risk_fight_reset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostIem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CostIem == nil {
				m.CostIem = &ItemConfig{}
			}
			if err := m.CostIem.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaEasterEgg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_easter_egg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_easter_egg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SceneID = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NpcID = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedTouchCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NeedTouchCount = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffectCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AffectCount = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Probability", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Probability = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ItemConfig{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CdTime = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayGetCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DayGetCount = &v
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstRewardList = append(m.FirstRewardList, &ItemConfig{})
			if err := m.FirstRewardList[len(m.FirstRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouchAnimName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TouchAnimName = append(m.TouchAnimName[:0], dAtA[iNdEx:postIndex]...)
			if m.TouchAnimName == nil {
				m.TouchAnimName = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouchSound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TouchSound = append(m.TouchSound[:0], dAtA[iNdEx:postIndex]...)
			if m.TouchSound == nil {
				m.TouchSound = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessAnimName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuccessAnimName = append(m.SuccessAnimName[:0], dAtA[iNdEx:postIndex]...)
			if m.SuccessAnimName == nil {
				m.SuccessAnimName = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessSound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuccessSound = append(m.SuccessSound[:0], dAtA[iNdEx:postIndex]...)
			if m.SuccessSound == nil {
				m.SuccessSound = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GlobalType = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaEquipMake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_equip_make: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_equip_make: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OpenLevel = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Quality = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Site = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaseOneItemList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaseOneItemList = append(m.CaseOneItemList, &ItemConfig{})
			if err := m.CaseOneItemList[len(m.CaseOneItemList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaseTwoItemList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaseTwoItemList = append(m.CaseTwoItemList, &ItemConfig{})
			if err := m.CaseTwoItemList[len(m.CaseTwoItemList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipIdOne", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EquipIdOne = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipIdTwo", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EquipIdTwo = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prop", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Prop = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaRoleSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_role_skill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_role_skill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesID = append(m.DesID[:0], dAtA[iNdEx:postIndex]...)
			if m.DesID == nil {
				m.DesID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.SkillLevelList = append(m.SkillLevelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SkillLevelList) == 0 {
					m.SkillLevelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.SkillLevelList = append(m.SkillLevelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillLevelList", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.SpecialLevelList = append(m.SpecialLevelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SpecialLevelList) == 0 {
					m.SpecialLevelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.SpecialLevelList = append(m.SpecialLevelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialLevelList", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = append(m.Icon[:0], dAtA[iNdEx:postIndex]...)
			if m.Icon == nil {
				m.Icon = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OpenLevel = &v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnItemList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LearnItemList = append(m.LearnItemList, &ItemConfig{})
			if err := m.LearnItemList[len(m.LearnItemList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.RateList = append(m.RateList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RateList) == 0 {
					m.RateList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.RateList = append(m.RateList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RateList", wireType)
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ProfiList = append(m.ProfiList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ProfiList) == 0 {
					m.ProfiList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ProfiList = append(m.ProfiList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfiList", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpItemList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpItemList = append(m.UpItemList, &ItemListConfig{})
			if err := m.UpItemList[len(m.UpItemList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ShowType = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Quality = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaDailyActivityGrowReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_daily_activity_growReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_daily_activity_growReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseReward == nil {
				m.BaseReward = &ItemConfig{}
			}
			if err := m.BaseReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ItemConfig{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaEquipFix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_equip_fix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_equip_fix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Quality = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixNeedItemId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FixNeedItemId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EveryNeedNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EveryNeedNum = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EveryNeedTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EveryNeedTime = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FastFixCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FastFixCost == nil {
				m.FastFixCost = &ItemConfig{}
			}
			if err := m.FastFixCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaNiudanPackage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_niudan_package: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_niudan_package: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelSection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LevelSection == nil {
				m.LevelSection = &RandomSection{}
			}
			if err := m.LevelSection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageList = append(m.PackageList, &ItemConfig{})
			if err := m.PackageList[len(m.PackageList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaTransport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_transport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_transport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &LuaPos{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ResType = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = append(m.Res[:0], dAtA[iNdEx:postIndex]...)
			if m.Res == nil {
				m.Res = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFlipX", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IsFlipX = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFlipY", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IsFlipY = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Rotate = &v
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.TargetList = append(m.TargetList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TargetList) == 0 {
					m.TargetList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.TargetList = append(m.TargetList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetList", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockRes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnlockRes = append(m.UnlockRes[:0], dAtA[iNdEx:postIndex]...)
			if m.UnlockRes == nil {
				m.UnlockRes = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UnlockPos = append(m.UnlockPos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnlockPos) == 0 {
					m.UnlockPos = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UnlockPos = append(m.UnlockPos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockPos", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaGuadraticBossSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_guadratic_boss_skill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_guadratic_boss_skill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkDistance", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AtkDistance = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hurt", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Hurt = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtRect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HurtRect == nil {
				m.HurtRect = &LuaRect{}
			}
			if err := m.HurtRect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkSound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AtkSound = append(m.AtkSound[:0], dAtA[iNdEx:postIndex]...)
			if m.AtkSound == nil {
				m.AtkSound = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.PreTime = &v2
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnimName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnimName = append(m.AnimName[:0], dAtA[iNdEx:postIndex]...)
			if m.AnimName == nil {
				m.AnimName = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectRes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EffectRes = append(m.EffectRes[:0], dAtA[iNdEx:postIndex]...)
			if m.EffectRes == nil {
				m.EffectRes = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfEffectRes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelfEffectRes = append(m.SelfEffectRes[:0], dAtA[iNdEx:postIndex]...)
			if m.SelfEffectRes == nil {
				m.SelfEffectRes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaSkillHole) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_skill_hole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_skill_hole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockItemList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnlockItemList = append(m.UnlockItemList, &ItemConfig{})
			if err := m.UnlockItemList[len(m.UnlockItemList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockVipLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.UnlockVipLevel = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaRandomBox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_random_box: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_random_box: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MinLevel = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MaxLevel = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.RewardID = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaCommonShop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_common_shop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_common_shop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TalkID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TalkID = append(m.TalkID[:0], dAtA[iNdEx:postIndex]...)
			if m.TalkID == nil {
				m.TalkID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ResType = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = append(m.Icon[:0], dAtA[iNdEx:postIndex]...)
			if m.Icon == nil {
				m.Icon = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Scale = &v2
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &LuaPos{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Period = &v
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.WeekdayList = append(m.WeekdayList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WeekdayList) == 0 {
					m.WeekdayList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.WeekdayList = append(m.WeekdayList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekdayList", wireType)
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.FixTimeList = append(m.FixTimeList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FixTimeList) == 0 {
					m.FixTimeList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.FixTimeList = append(m.FixTimeList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FixTimeList", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.LimitTimeList = append(m.LimitTimeList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LimitTimeList) == 0 {
					m.LimitTimeList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.LimitTimeList = append(m.LimitTimeList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitTimeList", wireType)
			}
		case 13:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.PriceList = append(m.PriceList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PriceList) == 0 {
					m.PriceList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.PriceList = append(m.PriceList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceList", wireType)
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateDesID = append(m.UpdateDesID[:0], dAtA[iNdEx:postIndex]...)
			if m.UpdateDesID == nil {
				m.UpdateDesID = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CellNum = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaParkItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_park_item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_park_item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemID = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EffectType = &v
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ValueList = append(m.ValueList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ValueList) == 0 {
					m.ValueList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ValueList = append(m.ValueList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaDailySubtask) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_daily_subtask: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_daily_subtask: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesID = append(m.DesID[:0], dAtA[iNdEx:postIndex]...)
			if m.DesID == nil {
				m.DesID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ConditionType = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionValue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ConditionValue = &v
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Reward = append(m.Reward, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Reward) == 0 {
					m.Reward = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Reward = append(m.Reward, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Activity", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Activity = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaInteraction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_interaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_interaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameAct", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameAct = append(m.NameAct[:0], dAtA[iNdEx:postIndex]...)
			if m.NameAct == nil {
				m.NameAct = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockDesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnlockDesID = append(m.UnlockDesID[:0], dAtA[iNdEx:postIndex]...)
			if m.UnlockDesID == nil {
				m.UnlockDesID = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IconID = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorCSB", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatorCSB = append(m.InitiatorCSB[:0], dAtA[iNdEx:postIndex]...)
			if m.InitiatorCSB == nil {
				m.InitiatorCSB = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorAction", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatorAction = append(m.InitiatorAction[:0], dAtA[iNdEx:postIndex]...)
			if m.InitiatorAction == nil {
				m.InitiatorAction = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorAction2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatorAction2 = append(m.InitiatorAction2[:0], dAtA[iNdEx:postIndex]...)
			if m.InitiatorAction2 == nil {
				m.InitiatorAction2 = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorEffect", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatorEffect = append(m.InitiatorEffect[:0], dAtA[iNdEx:postIndex]...)
			if m.InitiatorEffect == nil {
				m.InitiatorEffect = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorEffectFail", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatorEffectFail = append(m.InitiatorEffectFail[:0], dAtA[iNdEx:postIndex]...)
			if m.InitiatorEffectFail == nil {
				m.InitiatorEffectFail = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.LoopType = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ConsumerType = &v
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.ConsumerTime = &v2
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerEffect", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerEffect = append(m.ConsumerEffect[:0], dAtA[iNdEx:postIndex]...)
			if m.ConsumerEffect == nil {
				m.ConsumerEffect = []byte{}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerCSB", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerCSB = append(m.ConsumerCSB[:0], dAtA[iNdEx:postIndex]...)
			if m.ConsumerCSB == nil {
				m.ConsumerCSB = []byte{}
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerAction", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerAction = append(m.ConsumerAction[:0], dAtA[iNdEx:postIndex]...)
			if m.ConsumerAction == nil {
				m.ConsumerAction = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.DeltaPos = append(m.DeltaPos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DeltaPos) == 0 {
					m.DeltaPos = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.DeltaPos = append(m.DeltaPos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaPos", wireType)
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EffectType = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Radius = &v
		case 21:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Size_ = append(m.Size_, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Size_) == 0 {
					m.Size_ = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Size_ = append(m.Size_, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CdTime = &v
		case 23:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.EffectSelfList = append(m.EffectSelfList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EffectSelfList) == 0 {
					m.EffectSelfList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.EffectSelfList = append(m.EffectSelfList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectSelfList", wireType)
			}
		case 24:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.EffectOtherList = append(m.EffectOtherList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EffectOtherList) == 0 {
					m.EffectOtherList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.EffectOtherList = append(m.EffectOtherList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectOtherList", wireType)
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InteractToolType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.InteractToolType = &v
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorMusic", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatorMusic = append(m.InitiatorMusic[:0], dAtA[iNdEx:postIndex]...)
			if m.InitiatorMusic == nil {
				m.InitiatorMusic = []byte{}
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMusicLoop", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IsMusicLoop = &v
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerMusic", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerMusic = append(m.ConsumerMusic[:0], dAtA[iNdEx:postIndex]...)
			if m.ConsumerMusic == nil {
				m.ConsumerMusic = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaGiftBag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_gift_bag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_gift_bag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.RandomCount = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &LuaPackageItemWeight{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaMinigameShopRandom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_minigame_shop_random: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_minigame_shop_random: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIdList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemIdList = append(m.ItemIdList, &ShopRandomSectionList{})
			if err := m.ItemIdList[len(m.ItemIdList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaSwordResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_sword_result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_sword_result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.RateList = append(m.RateList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RateList) == 0 {
					m.RateList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.RateList = append(m.RateList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RateList", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.EventList = append(m.EventList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EventList) == 0 {
					m.EventList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.EventList = append(m.EventList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EventList", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ResultList = append(m.ResultList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ResultList) == 0 {
					m.ResultList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ResultList = append(m.ResultList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaNpcInteract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_npc_interact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_npc_interact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NpcID = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRepeat", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IsRepeat = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CdTime = &v
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.ActionTime = &v2
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &LuaPos{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sound = append(m.Sound[:0], dAtA[iNdEx:postIndex]...)
			if m.Sound == nil {
				m.Sound = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMusic", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IsMusic = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAudioEffectAll", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IsAudioEffectAll = &v
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.MutexIDList = append(m.MutexIDList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MutexIDList) == 0 {
					m.MutexIDList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.MutexIDList = append(m.MutexIDList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MutexIDList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaFaceLvl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_face_lvl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_face_lvl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Count = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesID = append(m.DesID[:0], dAtA[iNdEx:postIndex]...)
			if m.DesID == nil {
				m.DesID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockLvl", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.LockLvl = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaEquipBag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_equip_bag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_equip_bag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpLimit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.UpLimit = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cost = append(m.Cost, &ItemConfig{})
			if err := m.Cost[len(m.Cost)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaMainTask) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_main_task: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_main_task: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreTalkID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.PreTalkID = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexTalkID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NexTalkID = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompleteTalkID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CompleteTalkID = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesID = append(m.DesID[:0], dAtA[iNdEx:postIndex]...)
			if m.DesID == nil {
				m.DesID = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.CompleteIf = append(m.CompleteIf, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CompleteIf) == 0 {
					m.CompleteIf = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.CompleteIf = append(m.CompleteIf, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CompleteIf", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHasPreTask", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IsHasPreTask = &v
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.NexIDList = append(m.NexIDList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NexIDList) == 0 {
					m.NexIDList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.NexIDList = append(m.NexIDList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NexIDList", wireType)
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FuncID = &v
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.RiskID = append(m.RiskID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RiskID) == 0 {
					m.RiskID = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.RiskID = append(m.RiskID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskID", wireType)
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FriendCount = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.KillCount = &v
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InteractTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.InteractTime = &v
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InteractNpcList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InteractNpcList = append(m.InteractNpcList, &InteractNpc{})
			if err := m.InteractNpcList[len(m.InteractNpcList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaOkTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ArenaOkTime = &v
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BathWashTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BathWashTime = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineTotalTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OnlineTotalTime = &v
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NpcID = &v
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptRewardList = append(m.AcceptRewardList, &ItemConfig{})
			if err := m.AcceptRewardList[len(m.AcceptRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ItemConfig{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanGiveUp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CanGiveUp = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaExchangeGold) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_exchange_gold: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_exchange_gold: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Time = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountDiamond", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CountDiamond = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetGold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GetGold = append(m.GetGold, &ExchangeGoldItem{})
			if err := m.GetGold[len(m.GetGold)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaSuit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_suit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_suit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesID = append(m.DesID[:0], dAtA[iNdEx:postIndex]...)
			if m.DesID == nil {
				m.DesID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSpecial", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IsSpecial = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ResID = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atk", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Atk = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Hp = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Def = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Crit = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Block = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Speed = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaGlobalConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_global_config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_global_config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneMoveSpeed", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SceneMoveSpeed = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActArea", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ActArea = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwordInterval", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SwordInterval = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelUpStamina", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.LevelUpStamina = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyGetStamina", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BuyGetStamina = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaminaInterval", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.StaminaInterval = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwordGodProb", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SwordGodProb = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignDivisor", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SignDivisor = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignPakageID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SignPakageID = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignShowList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignShowList = append(m.SignShowList, &ItemConfig{})
			if err := m.SignShowList[len(m.SignShowList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwordCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SwordCount = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ArenaCount = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaCD", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ArenaCD = &v
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaClearCDCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ArenaClearCDCost == nil {
				m.ArenaClearCDCost = &ItemConfig{}
			}
			if err := m.ArenaClearCDCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FastTransItemID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FastTransItemID = &v
		case 17:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ArenaDayRewardList = append(m.ArenaDayRewardList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ArenaDayRewardList) == 0 {
					m.ArenaDayRewardList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ArenaDayRewardList = append(m.ArenaDayRewardList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArenaDayRewardList", wireType)
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipStrengthItemId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EquipStrengthItemId = &v
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipResolveReturnPercent", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EquipResolveReturnPercent = &v
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipDeclineParameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EquipDeclineParameter == nil {
				m.EquipDeclineParameter = &EquipLastingDecline{}
			}
			if err := m.EquipDeclineParameter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendAssistCdTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FriendAssistCdTime = &v
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RechargeExchangeScale", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.RechargeExchangeScale = &v
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BathFullnessUpperlimit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BathFullnessUpperlimit = &v
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitCarport", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.InitCarport = &v
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitRepairCarCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.InitRepairCarCount = &v
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkStopCDTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkStopCDTime = &v
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkProtectCDTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkProtectCDTime = &v
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkBreakProtectCDTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkBreakProtectCDTime = &v
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkRepairUnitTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkRepairUnitTime = &v
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiamondReduceRepairCarTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DiamondReduceRepairCarTime = &v
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FastRepairUseItemID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FastRepairUseItemID = &v
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemReduceRepairCarTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemReduceRepairCarTime = &v
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCarProtectTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.LastCarProtectTime = &v
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkSayYesLimitTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkSayYesLimitTime = &v
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkBenefitUnitTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkBenefitUnitTime = &v
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarportProtectTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CarportProtectTime = &v
		case 37:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullParkBenefitRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FullParkBenefitRate = &v2
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullParkRewardID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FullParkRewardID = &v
		case 39:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkBreakGetBenefitRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.ParkBreakGetBenefitRate = &v2
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkActCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkActCount = &v
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkActRefreshTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkActRefreshTime = &v
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkGetExpUnitTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkGetExpUnitTime = &v
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkSayYesGetExp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkSayYesGetExp = &v
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkBreakGetExp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkBreakGetExp = &v
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkGetRewardProb", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkGetRewardProb = &v
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkSayYesGetRewardProb", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkSayYesGetRewardProb = &v
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkBreakGetRewardProb", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkBreakGetRewardProb = &v
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemParkRefreshTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SystemParkRefreshTime = &v
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemParkMaxCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SystemParkMaxCount = &v
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemParkByLeftCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SystemParkByLeftCount = &v
		case 51:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.SystemParkRandomCaridList = append(m.SystemParkRandomCaridList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SystemParkRandomCaridList) == 0 {
					m.SystemParkRandomCaridList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.SystemParkRandomCaridList = append(m.SystemParkRandomCaridList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemParkRandomCaridList", wireType)
			}
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkStayTimeAfterFullTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkStayTimeAfterFullTime = &v
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkShopRefreshCarCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkShopRefreshCarCount = &v
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkDetailMaxCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkDetailMaxCount = &v
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkSayYesProb", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ParkSayYesProb = &v
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarPartID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CarPartID = &v
		case 57:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.InteractNpcList = append(m.InteractNpcList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.InteractNpcList) == 0 {
					m.InteractNpcList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.InteractNpcList = append(m.InteractNpcList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InteractNpcList", wireType)
			}
		case 58:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.HangupRestrictList = append(m.HangupRestrictList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.HangupRestrictList) == 0 {
					m.HangupRestrictList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.HangupRestrictList = append(m.HangupRestrictList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HangupRestrictList", wireType)
			}
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BathRecoveryUpperLimit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BathRecoveryUpperLimit = &v
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BathRecoveryInterval", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BathRecoveryInterval = &v
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BathOnceTimeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BathOnceTimeList = append(m.BathOnceTimeList, &BathOnceStimina{})
			if err := m.BathOnceTimeList[len(m.BathOnceTimeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 62:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.AddSwordItemList = append(m.AddSwordItemList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AddSwordItemList) == 0 {
					m.AddSwordItemList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.AddSwordItemList = append(m.AddSwordItemList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AddSwordItemList", wireType)
			}
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargeSkillBookItemID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ChargeSkillBookItemID = &v
		case 64:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PetTalentRebuildCostList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PetTalentRebuildCostList = append(m.PetTalentRebuildCostList, &ItemConfig{})
			if err := m.PetTalentRebuildCostList[len(m.PetTalentRebuildCostList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 65:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CostInterval == nil {
				m.CostInterval = &EquipEnduranceCost{}
			}
			if err := m.CostInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 66:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.PetRefreshTimeList = append(m.PetRefreshTimeList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PetRefreshTimeList) == 0 {
					m.PetRefreshTimeList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.PetRefreshTimeList = append(m.PetRefreshTimeList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PetRefreshTimeList", wireType)
			}
		case 67:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadHeadImageCostList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadHeadImageCostList = append(m.UploadHeadImageCostList, &ItemConfig{})
			if err := m.UploadHeadImageCostList[len(m.UploadHeadImageCostList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 68:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeverUploadHeadImageCostList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForeverUploadHeadImageCostList = append(m.ForeverUploadHeadImageCostList, &ItemConfig{})
			if err := m.ForeverUploadHeadImageCostList[len(m.ForeverUploadHeadImageCostList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 69:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HorseSpeed", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.HorseSpeed = &v
		case 70:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HorseInterval", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.HorseInterval = &v2
		case 71:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaliburnCountLimit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CaliburnCountLimit = &v
		case 72:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CannonPosList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CannonPosList = append(m.CannonPosList, &LuaPos{})
			if err := m.CannonPosList[len(m.CannonPosList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 73:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightFriendTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FightFriendTime = &v
		case 74:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GreenHatLimit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GreenHatLimit = &v
		case 75:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GreenHatGap", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GreenHatGap = &v
		case 76:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuadraticMaxRole", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GuadraticMaxRole = &v
		case 77:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuadraticMaxCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GuadraticMaxCount = &v
		case 78:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuadraticCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GuadraticCost == nil {
				m.GuadraticCost = &ItemConfig{}
			}
			if err := m.GuadraticCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 79:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuadraticOpenTimeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuadraticOpenTimeList = append(m.GuadraticOpenTimeList, &TimeRange{})
			if err := m.GuadraticOpenTimeList[len(m.GuadraticOpenTimeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuadraticStartCDTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GuadraticStartCDTime = &v
		case 81:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuadraticQuitCD", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GuadraticQuitCD = &v
		case 82:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuadraticEndHurtCD", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GuadraticEndHurtCD = &v
		case 83:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuadraticEndHurt", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GuadraticEndHurt = &v
		case 84:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuadraticAtkCD", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GuadraticAtkCD = &v
		case 85:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuadraticUnderAtkCD", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GuadraticUnderAtkCD = &v
		case 86:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuadraticHP", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GuadraticHP = &v
		case 87:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuadraticHurt", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GuadraticHurt = &v
		case 88:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelRankNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.LevelRankNum = &v
		case 89:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillRankNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.KillRankNum = &v
		case 90:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiamondRankNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DiamondRankNum = &v
		case 91:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinigameRankNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MinigameRankNum = &v
		case 92:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceDupReturnItem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FaceDupReturnItem == nil {
				m.FaceDupReturnItem = &ItemConfig{}
			}
			if err := m.FaceDupReturnItem.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 93:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellBagGridMaxNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SellBagGridMaxNum = &v
		case 94:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstSaveMoneryRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstSaveMoneryRewardList = append(m.FirstSaveMoneryRewardList, &ItemConfig{})
			if err := m.FirstSaveMoneryRewardList[len(m.FirstSaveMoneryRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 95:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeixinRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WeixinRewardList = append(m.WeixinRewardList, &ItemConfig{})
			if err := m.WeixinRewardList[len(m.WeixinRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 96:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RechargeLimit", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.RechargeLimit = &v2
		case 97:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PetEggReturnItemList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PetEggReturnItemList = append(m.PetEggReturnItemList, &ItemConfig{})
			if err := m.PetEggReturnItemList[len(m.PetEggReturnItemList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 98:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendNumLimit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FriendNumLimit = &v
		case 99:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PianoTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.PianoTime = &v
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockBattleSpeedLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.UnlockBattleSpeedLevel = &v
		case 101:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PvpAtkRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.PvpAtkRate = &v2
		case 102:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PvpDefRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.PvpDefRate = &v2
		case 103:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiamondFaceNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DiamondFaceNum = &v
		case 104:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldFaceNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GoldFaceNum = &v
		case 105:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.InitRoleAttr = append(m.InitRoleAttr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.InitRoleAttr) == 0 {
					m.InitRoleAttr = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.InitRoleAttr = append(m.InitRoleAttr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InitRoleAttr", wireType)
			}
		case 106:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.PerLevelAttr = append(m.PerLevelAttr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PerLevelAttr) == 0 {
					m.PerLevelAttr = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.PerLevelAttr = append(m.PerLevelAttr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PerLevelAttr", wireType)
			}
		case 107:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.FightParameter = append(m.FightParameter, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FightParameter) == 0 {
					m.FightParameter = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.FightParameter = append(m.FightParameter, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FightParameter", wireType)
			}
		case 108:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyGameItemList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DailyGameItemList = append(m.DailyGameItemList, &ItemConfig{})
			if err := m.DailyGameItemList[len(m.DailyGameItemList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaInteractSystem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_interact_system: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_interact_system: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ChildInteract = append(m.ChildInteract, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ChildInteract) == 0 {
					m.ChildInteract = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ChildInteract = append(m.ChildInteract, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildInteract", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActDesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActDesID = append(m.ActDesID[:0], dAtA[iNdEx:postIndex]...)
			if m.ActDesID == nil {
				m.ActDesID = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnlockCondition = append(m.UnlockCondition, &InteractUnlock{})
			if err := m.UnlockCondition[len(m.UnlockCondition)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergyPoint", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EnergyPoint = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IconID = &v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorCSB", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatorCSB = append(m.InitiatorCSB[:0], dAtA[iNdEx:postIndex]...)
			if m.InitiatorCSB == nil {
				m.InitiatorCSB = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorAction", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatorAction = append(m.InitiatorAction[:0], dAtA[iNdEx:postIndex]...)
			if m.InitiatorAction == nil {
				m.InitiatorAction = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorSound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatorSound = append(m.InitiatorSound[:0], dAtA[iNdEx:postIndex]...)
			if m.InitiatorSound == nil {
				m.InitiatorSound = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorAction2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatorAction2 = append(m.InitiatorAction2[:0], dAtA[iNdEx:postIndex]...)
			if m.InitiatorAction2 == nil {
				m.InitiatorAction2 = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorEffect", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatorEffect = append(m.InitiatorEffect[:0], dAtA[iNdEx:postIndex]...)
			if m.InitiatorEffect == nil {
				m.InitiatorEffect = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorEffectFail", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatorEffectFail = append(m.InitiatorEffectFail[:0], dAtA[iNdEx:postIndex]...)
			if m.InitiatorEffectFail == nil {
				m.InitiatorEffectFail = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.LoopType = &v
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorHideEffect", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.InitiatorHideEffect = &v
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerHideEffect", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ConsumerHideEffect = &v
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ConsumerType = &v
		case 19:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.ConsumerTime = &v2
		case 20:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorDuration", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.ColorDuration = &v2
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorRGB", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColorRGB == nil {
				m.ColorRGB = &LuaRgba{}
			}
			if err := m.ColorRGB.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerEffect", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerEffect = append(m.ConsumerEffect[:0], dAtA[iNdEx:postIndex]...)
			if m.ConsumerEffect == nil {
				m.ConsumerEffect = []byte{}
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerCSB", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerCSB = append(m.ConsumerCSB[:0], dAtA[iNdEx:postIndex]...)
			if m.ConsumerCSB == nil {
				m.ConsumerCSB = []byte{}
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerAction", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerAction = append(m.ConsumerAction[:0], dAtA[iNdEx:postIndex]...)
			if m.ConsumerAction == nil {
				m.ConsumerAction = []byte{}
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerSound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerSound = append(m.ConsumerSound[:0], dAtA[iNdEx:postIndex]...)
			if m.ConsumerSound == nil {
				m.ConsumerSound = []byte{}
			}
			iNdEx = postIndex
		case 26:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.DeltaPos = append(m.DeltaPos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DeltaPos) == 0 {
					m.DeltaPos = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.DeltaPos = append(m.DeltaPos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaPos", wireType)
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EffectType = &v
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Radius = &v
		case 29:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Size_ = append(m.Size_, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Size_) == 0 {
					m.Size_ = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Size_ = append(m.Size_, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SortLevel = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaParkDriver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_park_driver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_park_driver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Exp = &v
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.BreakProbList = append(m.BreakProbList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BreakProbList) == 0 {
					m.BreakProbList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.BreakProbList = append(m.BreakProbList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BreakProbList", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.BreakGetRewardItem = append(m.BreakGetRewardItem, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BreakGetRewardItem) == 0 {
					m.BreakGetRewardItem = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.BreakGetRewardItem = append(m.BreakGetRewardItem, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BreakGetRewardItem", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.SayYesProbList = append(m.SayYesProbList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SayYesProbList) == 0 {
					m.SayYesProbList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.SayYesProbList = append(m.SayYesProbList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SayYesProbList", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.SayYesGetRewardItem = append(m.SayYesGetRewardItem, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SayYesGetRewardItem) == 0 {
					m.SayYesGetRewardItem = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.SayYesGetRewardItem = append(m.SayYesGetRewardItem, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SayYesGetRewardItem", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.SayYesExRewardItem = append(m.SayYesExRewardItem, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SayYesExRewardItem) == 0 {
					m.SayYesExRewardItem = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.SayYesExRewardItem = append(m.SayYesExRewardItem, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SayYesExRewardItem", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.RandomItemRange = append(m.RandomItemRange, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RandomItemRange) == 0 {
					m.RandomItemRange = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.RandomItemRange = append(m.RandomItemRange, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomItemRange", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetCarportCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GetCarportCount = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaHouseShop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_house_shop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_house_shop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FurnitureID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FurnitureID = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedHouseLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NeedHouseLevel = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedVipLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NeedVipLevel = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostItem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CostItem == nil {
				m.CostItem = &ItemConfig{}
			}
			if err := m.CostItem.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNew", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IsNew = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaFindwayGuid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_findway_guid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_findway_guid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescID = append(m.DescID[:0], dAtA[iNdEx:postIndex]...)
			if m.DescID == nil {
				m.DescID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SceneID = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NpcID = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuggestLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SuggestLevel = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReachLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ReachLevel = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccecpTaskID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AccecpTaskID = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishTaskID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FinishTaskID = &v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishChapterRisk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinishChapterRisk == nil {
				m.FinishChapterRisk = &ChapterRisk{}
			}
			if err := m.FinishChapterRisk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockRisk", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.LockRisk = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaParkGaragePort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_park_garage_port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_park_garage_port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostItemList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CostItemList = append(m.CostItemList, &ItemConfig{})
			if err := m.CostItemList[len(m.CostItemList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaInteractManual) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_interact_manual: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_interact_manual: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Num = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Energy = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ItemConfig{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaFaceDiscount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_face_discount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_face_discount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Index = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Duration = append(m.Duration, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Duration) == 0 {
					m.Duration = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Duration = append(m.Duration, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CostType = &v
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Price = append(m.Price, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Price) == 0 {
					m.Price = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Price = append(m.Price, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Discount = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaParkEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_park_event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_park_event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescID = append(m.DescID[:0], dAtA[iNdEx:postIndex]...)
			if m.DescID == nil {
				m.DescID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.TotalTime = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CdTime = &v
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.CondList = append(m.CondList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CondList) == 0 {
					m.CondList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.CondList = append(m.CondList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CondList", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.SelectCarEffectList = append(m.SelectCarEffectList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SelectCarEffectList) == 0 {
					m.SelectCarEffectList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.SelectCarEffectList = append(m.SelectCarEffectList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectCarEffectList", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ExCarEffectList = append(m.ExCarEffectList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ExCarEffectList) == 0 {
					m.ExCarEffectList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ExCarEffectList = append(m.ExCarEffectList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExCarEffectList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaNpc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_npc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_npc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = append(m.Head[:0], dAtA[iNdEx:postIndex]...)
			if m.Head == nil {
				m.Head = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZOrder", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ZOrder = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ResType = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = append(m.Res[:0], dAtA[iNdEx:postIndex]...)
			if m.Res == nil {
				m.Res = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Scale = &v2
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlipX", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FlipX = &v
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EffectList = append(m.EffectList, make([]byte, postIndex-iNdEx))
			copy(m.EffectList[len(m.EffectList)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pos = append(m.Pos, &LuaPos{})
			if err := m.Pos[len(m.Pos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.TargetList = append(m.TargetList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TargetList) == 0 {
					m.TargetList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.TargetList = append(m.TargetList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetList", wireType)
			}
		case 13:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.TalkIDList = append(m.TalkIDList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TalkIDList) == 0 {
					m.TalkIDList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.TalkIDList = append(m.TalkIDList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TalkIDList", wireType)
			}
		case 14:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.ClickRect = append(m.ClickRect, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.ClickRect) == 0 {
					m.ClickRect = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.ClickRect = append(m.ClickRect, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ClickRect", wireType)
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TalkHeadPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TalkHeadPos == nil {
				m.TalkHeadPos = &LuaPos{}
			}
			if err := m.TalkHeadPos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TalkHeadScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.TalkHeadScale = &v2
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarkPos == nil {
				m.MarkPos = &LuaPos{}
			}
			if err := m.MarkPos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamePos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NamePos == nil {
				m.NamePos = &LuaPos{}
			}
			if err := m.NamePos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FindwayPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FindwayPos == nil {
				m.FindwayPos = &LuaPos{}
			}
			if err := m.FindwayPos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaWingExtraEffect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_wing_extra_effect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_wing_extra_effect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomNumList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RandomNumList = append(m.RandomNumList, &RandomSection{})
			if err := m.RandomNumList[len(m.RandomNumList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraPerList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraPerList = append(m.ExtraPerList, &ExtraPerSection{})
			if err := m.ExtraPerList[len(m.ExtraPerList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaHouseExpand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_house_expand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_house_expand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Size_ == nil {
				m.Size_ = &LuaSize{}
			}
			if err := m.Size_.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Icon = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedHouseLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NeedHouseLevel = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedVipLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NeedVipLevel = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostItem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CostItem == nil {
				m.CostItem = &ItemConfig{}
			}
			if err := m.CostItem.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesID = append(m.DesID[:0], dAtA[iNdEx:postIndex]...)
			if m.DesID == nil {
				m.DesID = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ResID = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.UseLevel = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Quality = &v
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.RewardList = append(m.RewardList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RewardList) == 0 {
					m.RewardList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.RewardList = append(m.RewardList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Price = &v
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.TestWearList = append(m.TestWearList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TestWearList) == 0 {
					m.TestWearList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.TestWearList = append(m.TestWearList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TestWearList", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EffectList = append(m.EffectList, &ItemConfig{})
			if err := m.EffectList[len(m.EffectList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SpID = &v
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemSound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemSound = append(m.ItemSound[:0], dAtA[iNdEx:postIndex]...)
			if m.ItemSound == nil {
				m.ItemSound = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromID = append(m.FromID[:0], dAtA[iNdEx:postIndex]...)
			if m.FromID == nil {
				m.FromID = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseforID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UseforID = append(m.UseforID[:0], dAtA[iNdEx:postIndex]...)
			if m.UseforID == nil {
				m.UseforID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaSkillShop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_skill_shop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_skill_shop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemID = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Num = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CostType = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Price = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaEquip) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_equip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_equip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesID = append(m.DesID[:0], dAtA[iNdEx:postIndex]...)
			if m.DesID == nil {
				m.DesID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WingCSB", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WingCSB = append(m.WingCSB[:0], dAtA[iNdEx:postIndex]...)
			if m.WingCSB == nil {
				m.WingCSB = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WingSuffix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WingSuffix = append(m.WingSuffix[:0], dAtA[iNdEx:postIndex]...)
			if m.WingSuffix == nil {
				m.WingSuffix = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WingBindType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.WingBindType = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CsbName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CsbName = append(m.CsbName[:0], dAtA[iNdEx:postIndex]...)
			if m.CsbName == nil {
				m.CsbName = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnimSuffix", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AnimSuffix = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Quality = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WearLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.WearLevel = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkMin", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AtkMin = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkMax", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AtkMax = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Hp = &v
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Def = &v
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Crit = &v
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Block = &v
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Speed = &v
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullAttr", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FullAttr = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endurance", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Endurance = &v
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Icon = &v
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeaponEffect", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.WeaponEffect = &v
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePrice", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BasePrice = &v
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtkStarStepValue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AtkStarStepValue = &v
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpStarStepValue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.HpStarStepValue = &v
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefStarStepValue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DefStarStepValue = &v
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CritStarStepValue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CritStarStepValue = &v
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockStarStepValue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BlockStarStepValue = &v
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedStarStepValue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SpeedStarStepValue = &v
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveBaseList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolveBaseList = append(m.ResolveBaseList, &ItemConfig{})
			if err := m.ResolveBaseList[len(m.ResolveBaseList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveExtraList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolveExtraList = append(m.ResolveExtraList, &EquipResolveItem{})
			if err := m.ResolveExtraList[len(m.ResolveExtraList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarUpperLimit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.StarUpperLimit = &v
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsResoluble", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IsResoluble = &v
		case 34:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.QualityAtkList = append(m.QualityAtkList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.QualityAtkList) == 0 {
					m.QualityAtkList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.QualityAtkList = append(m.QualityAtkList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field QualityAtkList", wireType)
			}
		case 35:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.QualityHpList = append(m.QualityHpList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.QualityHpList) == 0 {
					m.QualityHpList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.QualityHpList = append(m.QualityHpList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field QualityHpList", wireType)
			}
		case 36:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.QualityDefList = append(m.QualityDefList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.QualityDefList) == 0 {
					m.QualityDefList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.QualityDefList = append(m.QualityDefList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field QualityDefList", wireType)
			}
		case 37:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.QualityCritList = append(m.QualityCritList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.QualityCritList) == 0 {
					m.QualityCritList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.QualityCritList = append(m.QualityCritList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field QualityCritList", wireType)
			}
		case 38:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.QualityBlockList = append(m.QualityBlockList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.QualityBlockList) == 0 {
					m.QualityBlockList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.QualityBlockList = append(m.QualityBlockList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field QualityBlockList", wireType)
			}
		case 39:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.QualitySpeedList = append(m.QualitySpeedList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.QualitySpeedList) == 0 {
					m.QualitySpeedList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.QualitySpeedList = append(m.QualitySpeedList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field QualitySpeedList", wireType)
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveSpeed", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MoveSpeed = &v
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarSound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CarSound = append(m.CarSound[:0], dAtA[iNdEx:postIndex]...)
			if m.CarSound == nil {
				m.CarSound = []byte{}
			}
			iNdEx = postIndex
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RareDegree", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.RareDegree = &v
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromID = append(m.FromID[:0], dAtA[iNdEx:postIndex]...)
			if m.FromID == nil {
				m.FromID = []byte{}
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseforID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UseforID = append(m.UseforID[:0], dAtA[iNdEx:postIndex]...)
			if m.UseforID == nil {
				m.UseforID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaPetActSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_pet_act_skill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_pet_act_skill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesID = append(m.DesID[:0], dAtA[iNdEx:postIndex]...)
			if m.DesID == nil {
				m.DesID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = append(m.Icon[:0], dAtA[iNdEx:postIndex]...)
			if m.Icon == nil {
				m.Icon = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaVip) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_vip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_vip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Exp = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpecialRewardList = append(m.SpecialRewardList, &ItemConfig{})
			if err := m.SpecialRewardList[len(m.SpecialRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowPrice == nil {
				m.ShowPrice = &ItemConfig{}
			}
			if err := m.ShowPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RealPrice == nil {
				m.RealPrice = &ItemConfig{}
			}
			if err := m.RealPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyRewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DailyRewardList = append(m.DailyRewardList, &ItemConfig{})
			if err := m.DailyRewardList[len(m.DailyRewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.RiskAddSpeed = append(m.RiskAddSpeed, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RiskAddSpeed) == 0 {
					m.RiskAddSpeed = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.RiskAddSpeed = append(m.RiskAddSpeed, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskAddSpeed", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UploadFaceFlag = append(m.UploadFaceFlag, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UploadFaceFlag) == 0 {
					m.UploadFaceFlag = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UploadFaceFlag = append(m.UploadFaceFlag, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadFaceFlag", wireType)
			}
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UnlockSkillPos = append(m.UnlockSkillPos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnlockSkillPos) == 0 {
					m.UnlockSkillPos = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UnlockSkillPos = append(m.UnlockSkillPos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockSkillPos", wireType)
			}
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.VipChatPP = append(m.VipChatPP, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.VipChatPP) == 0 {
					m.VipChatPP = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.VipChatPP = append(m.VipChatPP, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VipChatPP", wireType)
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.NoCdArenaFail = append(m.NoCdArenaFail, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NoCdArenaFail) == 0 {
					m.NoCdArenaFail = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.NoCdArenaFail = append(m.NoCdArenaFail, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCdArenaFail", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.FixTimePlus = append(m.FixTimePlus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FixTimePlus) == 0 {
					m.FixTimePlus = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.FixTimePlus = append(m.FixTimePlus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FixTimePlus", wireType)
			}
		case 13:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.VipSkipFight = append(m.VipSkipFight, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.VipSkipFight) == 0 {
					m.VipSkipFight = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.VipSkipFight = append(m.VipSkipFight, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VipSkipFight", wireType)
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.BathExpSpeedup = append(m.BathExpSpeedup, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BathExpSpeedup) == 0 {
					m.BathExpSpeedup = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.BathExpSpeedup = append(m.BathExpSpeedup, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BathExpSpeedup", wireType)
			}
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.VipPet = append(m.VipPet, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.VipPet) == 0 {
					m.VipPet = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.VipPet = append(m.VipPet, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VipPet", wireType)
			}
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.SkilledSpeed = append(m.SkilledSpeed, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SkilledSpeed) == 0 {
					m.SkilledSpeed = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.SkilledSpeed = append(m.SkilledSpeed, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SkilledSpeed", wireType)
			}
		case 17:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.VipBMG = append(m.VipBMG, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.VipBMG) == 0 {
					m.VipBMG = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.VipBMG = append(m.VipBMG, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VipBMG", wireType)
			}
		case 18:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.VipBarrageFont = append(m.VipBarrageFont, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.VipBarrageFont) == 0 {
					m.VipBarrageFont = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.VipBarrageFont = append(m.VipBarrageFont, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VipBarrageFont", wireType)
			}
		case 19:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ExpPromoteRatio = append(m.ExpPromoteRatio, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ExpPromoteRatio) == 0 {
					m.ExpPromoteRatio = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ExpPromoteRatio = append(m.ExpPromoteRatio, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpPromoteRatio", wireType)
			}
		case 20:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.FriendSkillCD = append(m.FriendSkillCD, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FriendSkillCD) == 0 {
					m.FriendSkillCD = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.FriendSkillCD = append(m.FriendSkillCD, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendSkillCD", wireType)
			}
		case 21:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ExchangeGoldTime = append(m.ExchangeGoldTime, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ExchangeGoldTime) == 0 {
					m.ExchangeGoldTime = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ExchangeGoldTime = append(m.ExchangeGoldTime, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeGoldTime", wireType)
			}
		case 22:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.BuyArenaCount = append(m.BuyArenaCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BuyArenaCount) == 0 {
					m.BuyArenaCount = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.BuyArenaCount = append(m.BuyArenaCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyArenaCount", wireType)
			}
		case 23:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.BuyStaminaCount = append(m.BuyStaminaCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BuyStaminaCount) == 0 {
					m.BuyStaminaCount = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.BuyStaminaCount = append(m.BuyStaminaCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyStaminaCount", wireType)
			}
		case 24:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.BuyBitCoinCount = append(m.BuyBitCoinCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BuyBitCoinCount) == 0 {
					m.BuyBitCoinCount = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.BuyBitCoinCount = append(m.BuyBitCoinCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyBitCoinCount", wireType)
			}
		case 25:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.FaceRefreshCountUpperLimit = append(m.FaceRefreshCountUpperLimit, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FaceRefreshCountUpperLimit) == 0 {
					m.FaceRefreshCountUpperLimit = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.FaceRefreshCountUpperLimit = append(m.FaceRefreshCountUpperLimit, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceRefreshCountUpperLimit", wireType)
			}
		case 26:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UpdateSkillShopCount = append(m.UpdateSkillShopCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UpdateSkillShopCount) == 0 {
					m.UpdateSkillShopCount = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UpdateSkillShopCount = append(m.UpdateSkillShopCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateSkillShopCount", wireType)
			}
		case 27:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UpdateMinigameShopCount = append(m.UpdateMinigameShopCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UpdateMinigameShopCount) == 0 {
					m.UpdateMinigameShopCount = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UpdateMinigameShopCount = append(m.UpdateMinigameShopCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateMinigameShopCount", wireType)
			}
		case 28:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UpdateArenaShopCount = append(m.UpdateArenaShopCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UpdateArenaShopCount) == 0 {
					m.UpdateArenaShopCount = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UpdateArenaShopCount = append(m.UpdateArenaShopCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateArenaShopCount", wireType)
			}
		case 29:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UpdateBlackShopCount = append(m.UpdateBlackShopCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UpdateBlackShopCount) == 0 {
					m.UpdateBlackShopCount = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UpdateBlackShopCount = append(m.UpdateBlackShopCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateBlackShopCount", wireType)
			}
		case 30:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UpdateDiamondShopCount = append(m.UpdateDiamondShopCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UpdateDiamondShopCount) == 0 {
					m.UpdateDiamondShopCount = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UpdateDiamondShopCount = append(m.UpdateDiamondShopCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDiamondShopCount", wireType)
			}
		case 31:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.SignManualCount = append(m.SignManualCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SignManualCount) == 0 {
					m.SignManualCount = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.SignManualCount = append(m.SignManualCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SignManualCount", wireType)
			}
		case 32:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.DangerRiskResetCount = append(m.DangerRiskResetCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DangerRiskResetCount) == 0 {
					m.DangerRiskResetCount = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.DangerRiskResetCount = append(m.DangerRiskResetCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DangerRiskResetCount", wireType)
			}
		case 33:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ParkNum = append(m.ParkNum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ParkNum) == 0 {
					m.ParkNum = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ParkNum = append(m.ParkNum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ParkNum", wireType)
			}
		case 34:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.VipAct = append(m.VipAct, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.VipAct) == 0 {
					m.VipAct = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.VipAct = append(m.VipAct, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VipAct", wireType)
			}
		case 35:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.VipFurnitureShop = append(m.VipFurnitureShop, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.VipFurnitureShop) == 0 {
					m.VipFurnitureShop = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.VipFurnitureShop = append(m.VipFurnitureShop, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VipFurnitureShop", wireType)
			}
		case 36:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.VipVechical = append(m.VipVechical, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.VipVechical) == 0 {
					m.VipVechical = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.VipVechical = append(m.VipVechical, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VipVechical", wireType)
			}
		case 37:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.RiskDropRate = append(m.RiskDropRate, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RiskDropRate) == 0 {
					m.RiskDropRate = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.RiskDropRate = append(m.RiskDropRate, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskDropRate", wireType)
			}
		case 38:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.VipFellow = append(m.VipFellow, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.VipFellow) == 0 {
					m.VipFellow = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.VipFellow = append(m.VipFellow, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VipFellow", wireType)
			}
		case 39:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.SelfDefVehicle = append(m.SelfDefVehicle, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SelfDefVehicle) == 0 {
					m.SelfDefVehicle = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.SelfDefVehicle = append(m.SelfDefVehicle, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfDefVehicle", wireType)
			}
		case 40:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.CarportCount = append(m.CarportCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CarportCount) == 0 {
					m.CarportCount = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.CarportCount = append(m.CarportCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CarportCount", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaFurniture) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_furniture: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_furniture: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesID = append(m.DesID[:0], dAtA[iNdEx:postIndex]...)
			if m.DesID == nil {
				m.DesID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Icon = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SubType = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Size_ == nil {
				m.Size_ = &LuaSize{}
			}
			if err := m.Size_.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DirType = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectIndex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DirectIndex = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ResType = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = append(m.Res[:0], dAtA[iNdEx:postIndex]...)
			if m.Res == nil {
				m.Res = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCanPass", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IsCanPass = &v
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OffsetPos == nil {
				m.OffsetPos = &LuaPos{}
			}
			if err := m.OffsetPos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SalePrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SalePrice == nil {
				m.SalePrice = &ItemConfig{}
			}
			if err := m.SalePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaArenaBuy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_arena_buy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_arena_buy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Count = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Diamond = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaBattleWave) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_battle_wave: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_battle_wave: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.MonsterList = append(m.MonsterList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MonsterList) == 0 {
					m.MonsterList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.MonsterList = append(m.MonsterList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MonsterList", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.PosList = append(m.PosList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PosList) == 0 {
					m.PosList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.PosList = append(m.PosList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PosList", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TalkID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.TalkID = &v
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.LevelList = append(m.LevelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LevelList) == 0 {
					m.LevelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.LevelList = append(m.LevelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelList", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.DiffList = append(m.DiffList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DiffList) == 0 {
					m.DiffList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.DiffList = append(m.DiffList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DiffList", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EventID = &v
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.EventConList = append(m.EventConList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EventConList) == 0 {
					m.EventConList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.EventConList = append(m.EventConList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EventConList", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventArgList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EventArgList == nil {
				m.EventArgList = &LuaEventArgList{}
			}
			if err := m.EventArgList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaMiniWarrior) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_mini_warrior: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_mini_warrior: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPerGroup", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NumPerGroup = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnemyNumMax", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EnemyNumMax = &v
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gap", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Gap = &v2
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnemyNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EnemyNum = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddEnemyGroup", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AddEnemyGroup = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnemyAddPerGroup", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EnemyAddPerGroup = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstSpeed", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FirstSpeed = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddSpeedGroup", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AddSpeedGroup = &v
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedAddPerGroup", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.SpeedAddPerGroup = &v2
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedMaxLimit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SpeedMaxLimit = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttLimit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AttLimit = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossAppearScore", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BossAppearScore = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossAppearScoreAdd", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BossAppearScoreAdd = &v
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossChangeColorNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BossChangeColorNum = &v
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossChangeColorNumAdd", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BossChangeColorNumAdd = &v
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossGatherEnergy", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BossGatherEnergy = &v
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossGatherEnergyAdd", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BossGatherEnergyAdd = &v
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnemyScore", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EnemyScore = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossScore", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BossScore = &v
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSpeed", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MapSpeed = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaParkCarport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_park_carport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_park_carport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BenefitRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.BenefitRate = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaParkSayyes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_park_sayyes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_park_sayyes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = append(m.Res[:0], dAtA[iNdEx:postIndex]...)
			if m.Res == nil {
				m.Res = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Effect", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Effect = append(m.Effect[:0], dAtA[iNdEx:postIndex]...)
			if m.Effect == nil {
				m.Effect = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ValueList = append(m.ValueList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ValueList) == 0 {
					m.ValueList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ValueList = append(m.ValueList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueList", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sound = append(m.Sound[:0], dAtA[iNdEx:postIndex]...)
			if m.Sound == nil {
				m.Sound = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaParkRepairPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_park_repair_port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_park_repair_port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostItemList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CostItemList = append(m.CostItemList, &ItemConfig{})
			if err := m.CostItemList[len(m.CostItemList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaHouseLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_house_level: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_house_level: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Exp = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaSevenDays) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_seven_days: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_seven_days: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ID = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reward = append(m.Reward, &ItemConfig{})
			if err := m.Reward[len(m.Reward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaPetPill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_pet_pill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_pet_pill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectValue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EffectValue = &v
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaScene) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_scene: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_scene: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = append(m.NameID[:0], dAtA[iNdEx:postIndex]...)
			if m.NameID == nil {
				m.NameID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRole", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MaxRole = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCanMoreOpen", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.IsCanMoreOpen = &v
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.MapList = append(m.MapList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MapList) == 0 {
					m.MapList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.MapList = append(m.MapList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MapList", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFile", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataFile = append(m.DataFile[:0], dAtA[iNdEx:postIndex]...)
			if m.DataFile == nil {
				m.DataFile = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSize == nil {
				m.MapSize = &LuaSize{}
			}
			if err := m.MapSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.TransportList = append(m.TransportList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TransportList) == 0 {
					m.TransportList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.TransportList = append(m.TransportList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportList", wireType)
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FastTransEnable", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FastTransEnable = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenFuncID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OpenFuncID = &v
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.BuildingList = append(m.BuildingList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BuildingList) == 0 {
					m.BuildingList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.BuildingList = append(m.BuildingList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingList", wireType)
			}
		case 13:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.NpcList = append(m.NpcList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NpcList) == 0 {
					m.NpcList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.NpcList = append(m.NpcList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcList", wireType)
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BornPosList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BornPosList = append(m.BornPosList, &LuaPos{})
			if err := m.BornPosList[len(m.BornPosList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MusicList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MusicList = append(m.MusicList, make([]byte, postIndex-iNdEx))
			copy(m.MusicList[len(m.MusicList)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.RoleScale = &v2
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PetRefreshPosList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PetRefreshPosList = append(m.PetRefreshPosList, &LuaPos{})
			if err := m.PetRefreshPosList[len(m.PetRefreshPosList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaArenaDayRank) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_arena_day_rank: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_arena_day_rank: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.RankRect = append(m.RankRect, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServerDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServerDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServerDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RankRect) == 0 {
					m.RankRect = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServerDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.RankRect = append(m.RankRect, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RankRect", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServerDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServerDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ItemConfig{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServerDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServerDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipServerDef(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowServerDef
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServerDef
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthServerDef
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupServerDef
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthServerDef
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthServerDef        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowServerDef          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupServerDef = fmt.Errorf("proto: unexpected end of group")
)
