// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ProtoBaseDef.proto

package pbd

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// rgba
type LuaRgba struct {
	R                    *int32   `protobuf:"zigzag32,1,req,name=r" json:"r,omitempty"`
	G                    *int32   `protobuf:"zigzag32,2,req,name=g" json:"g,omitempty"`
	B                    *int32   `protobuf:"zigzag32,3,req,name=b" json:"b,omitempty"`
	A                    *float32 `protobuf:"fixed32,4,req,name=a" json:"a,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaRgba) Reset()         { *m = LuaRgba{} }
func (m *LuaRgba) String() string { return proto.CompactTextString(m) }
func (*LuaRgba) ProtoMessage()    {}
func (*LuaRgba) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{0}
}
func (m *LuaRgba) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaRgba) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaRgba.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaRgba) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaRgba.Merge(m, src)
}
func (m *LuaRgba) XXX_Size() int {
	return m.Size()
}
func (m *LuaRgba) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaRgba.DiscardUnknown(m)
}

var xxx_messageInfo_LuaRgba proto.InternalMessageInfo

func (m *LuaRgba) GetR() int32 {
	if m != nil && m.R != nil {
		return *m.R
	}
	return 0
}

func (m *LuaRgba) GetG() int32 {
	if m != nil && m.G != nil {
		return *m.G
	}
	return 0
}

func (m *LuaRgba) GetB() int32 {
	if m != nil && m.B != nil {
		return *m.B
	}
	return 0
}

func (m *LuaRgba) GetA() float32 {
	if m != nil && m.A != nil {
		return *m.A
	}
	return 0
}

// 范围大小
type LuaSize struct {
	Width                *int32   `protobuf:"zigzag32,1,req,name=width" json:"width,omitempty"`
	Height               *int32   `protobuf:"zigzag32,2,req,name=height" json:"height,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaSize) Reset()         { *m = LuaSize{} }
func (m *LuaSize) String() string { return proto.CompactTextString(m) }
func (*LuaSize) ProtoMessage()    {}
func (*LuaSize) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{1}
}
func (m *LuaSize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaSize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaSize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaSize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaSize.Merge(m, src)
}
func (m *LuaSize) XXX_Size() int {
	return m.Size()
}
func (m *LuaSize) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaSize.DiscardUnknown(m)
}

var xxx_messageInfo_LuaSize proto.InternalMessageInfo

func (m *LuaSize) GetWidth() int32 {
	if m != nil && m.Width != nil {
		return *m.Width
	}
	return 0
}

func (m *LuaSize) GetHeight() int32 {
	if m != nil && m.Height != nil {
		return *m.Height
	}
	return 0
}

type LuaArenaRect struct {
	Low                  *int32   `protobuf:"zigzag32,1,req,name=low" json:"low,omitempty"`
	Hig                  *int32   `protobuf:"zigzag32,2,req,name=hig" json:"hig,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaArenaRect) Reset()         { *m = LuaArenaRect{} }
func (m *LuaArenaRect) String() string { return proto.CompactTextString(m) }
func (*LuaArenaRect) ProtoMessage()    {}
func (*LuaArenaRect) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{2}
}
func (m *LuaArenaRect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaArenaRect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaArenaRect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaArenaRect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaArenaRect.Merge(m, src)
}
func (m *LuaArenaRect) XXX_Size() int {
	return m.Size()
}
func (m *LuaArenaRect) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaArenaRect.DiscardUnknown(m)
}

var xxx_messageInfo_LuaArenaRect proto.InternalMessageInfo

func (m *LuaArenaRect) GetLow() int32 {
	if m != nil && m.Low != nil {
		return *m.Low
	}
	return 0
}

func (m *LuaArenaRect) GetHig() int32 {
	if m != nil && m.Hig != nil {
		return *m.Hig
	}
	return 0
}

//通关关卡
type OpenDupConfig struct {
	ChapID               *int32   `protobuf:"zigzag32,1,req,name=chapID" json:"chapID,omitempty"`
	DupID                *int32   `protobuf:"zigzag32,2,req,name=dupID" json:"dupID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenDupConfig) Reset()         { *m = OpenDupConfig{} }
func (m *OpenDupConfig) String() string { return proto.CompactTextString(m) }
func (*OpenDupConfig) ProtoMessage()    {}
func (*OpenDupConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{3}
}
func (m *OpenDupConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenDupConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenDupConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenDupConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenDupConfig.Merge(m, src)
}
func (m *OpenDupConfig) XXX_Size() int {
	return m.Size()
}
func (m *OpenDupConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenDupConfig.DiscardUnknown(m)
}

var xxx_messageInfo_OpenDupConfig proto.InternalMessageInfo

func (m *OpenDupConfig) GetChapID() int32 {
	if m != nil && m.ChapID != nil {
		return *m.ChapID
	}
	return 0
}

func (m *OpenDupConfig) GetDupID() int32 {
	if m != nil && m.DupID != nil {
		return *m.DupID
	}
	return 0
}

//事件参数列表
type LuaEventArgList struct {
	Percent              *int32   `protobuf:"zigzag32,1,opt,name=percent" json:"percent,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaEventArgList) Reset()         { *m = LuaEventArgList{} }
func (m *LuaEventArgList) String() string { return proto.CompactTextString(m) }
func (*LuaEventArgList) ProtoMessage()    {}
func (*LuaEventArgList) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{4}
}
func (m *LuaEventArgList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaEventArgList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaEventArgList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaEventArgList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaEventArgList.Merge(m, src)
}
func (m *LuaEventArgList) XXX_Size() int {
	return m.Size()
}
func (m *LuaEventArgList) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaEventArgList.DiscardUnknown(m)
}

var xxx_messageInfo_LuaEventArgList proto.InternalMessageInfo

func (m *LuaEventArgList) GetPercent() int32 {
	if m != nil && m.Percent != nil {
		return *m.Percent
	}
	return 0
}

type ShopRandomSection struct {
	MinId                *int32   `protobuf:"zigzag32,1,req,name=minId" json:"minId,omitempty"`
	MaxId                *int32   `protobuf:"zigzag32,2,req,name=maxId" json:"maxId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShopRandomSection) Reset()         { *m = ShopRandomSection{} }
func (m *ShopRandomSection) String() string { return proto.CompactTextString(m) }
func (*ShopRandomSection) ProtoMessage()    {}
func (*ShopRandomSection) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{5}
}
func (m *ShopRandomSection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShopRandomSection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShopRandomSection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShopRandomSection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShopRandomSection.Merge(m, src)
}
func (m *ShopRandomSection) XXX_Size() int {
	return m.Size()
}
func (m *ShopRandomSection) XXX_DiscardUnknown() {
	xxx_messageInfo_ShopRandomSection.DiscardUnknown(m)
}

var xxx_messageInfo_ShopRandomSection proto.InternalMessageInfo

func (m *ShopRandomSection) GetMinId() int32 {
	if m != nil && m.MinId != nil {
		return *m.MinId
	}
	return 0
}

func (m *ShopRandomSection) GetMaxId() int32 {
	if m != nil && m.MaxId != nil {
		return *m.MaxId
	}
	return 0
}

type ShopRandomSectionList struct {
	SectionList          []*ShopRandomSection `protobuf:"bytes,1,rep,name=sectionList" json:"sectionList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ShopRandomSectionList) Reset()         { *m = ShopRandomSectionList{} }
func (m *ShopRandomSectionList) String() string { return proto.CompactTextString(m) }
func (*ShopRandomSectionList) ProtoMessage()    {}
func (*ShopRandomSectionList) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{6}
}
func (m *ShopRandomSectionList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShopRandomSectionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShopRandomSectionList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShopRandomSectionList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShopRandomSectionList.Merge(m, src)
}
func (m *ShopRandomSectionList) XXX_Size() int {
	return m.Size()
}
func (m *ShopRandomSectionList) XXX_DiscardUnknown() {
	xxx_messageInfo_ShopRandomSectionList.DiscardUnknown(m)
}

var xxx_messageInfo_ShopRandomSectionList proto.InternalMessageInfo

func (m *ShopRandomSectionList) GetSectionList() []*ShopRandomSection {
	if m != nil {
		return m.SectionList
	}
	return nil
}

// 澡堂道具通用message
type BathInteractTool struct {
	Type                 *int32   `protobuf:"zigzag32,1,req,name=type" json:"type,omitempty"`
	Num                  *int32   `protobuf:"zigzag32,2,req,name=num" json:"num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BathInteractTool) Reset()         { *m = BathInteractTool{} }
func (m *BathInteractTool) String() string { return proto.CompactTextString(m) }
func (*BathInteractTool) ProtoMessage()    {}
func (*BathInteractTool) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{7}
}
func (m *BathInteractTool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BathInteractTool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BathInteractTool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BathInteractTool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BathInteractTool.Merge(m, src)
}
func (m *BathInteractTool) XXX_Size() int {
	return m.Size()
}
func (m *BathInteractTool) XXX_DiscardUnknown() {
	xxx_messageInfo_BathInteractTool.DiscardUnknown(m)
}

var xxx_messageInfo_BathInteractTool proto.InternalMessageInfo

func (m *BathInteractTool) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *BathInteractTool) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

type SignDayReward struct {
	ItemId               *int32   `protobuf:"zigzag32,1,req,name=item_id" json:"item_id,omitempty"`
	ItemCount            *int32   `protobuf:"zigzag32,2,req,name=item_count" json:"item_count,omitempty"`
	VipDouble            *int32   `protobuf:"zigzag32,3,req,name=vip_double" json:"vip_double,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignDayReward) Reset()         { *m = SignDayReward{} }
func (m *SignDayReward) String() string { return proto.CompactTextString(m) }
func (*SignDayReward) ProtoMessage()    {}
func (*SignDayReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{8}
}
func (m *SignDayReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignDayReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignDayReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignDayReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignDayReward.Merge(m, src)
}
func (m *SignDayReward) XXX_Size() int {
	return m.Size()
}
func (m *SignDayReward) XXX_DiscardUnknown() {
	xxx_messageInfo_SignDayReward.DiscardUnknown(m)
}

var xxx_messageInfo_SignDayReward proto.InternalMessageInfo

func (m *SignDayReward) GetItemId() int32 {
	if m != nil && m.ItemId != nil {
		return *m.ItemId
	}
	return 0
}

func (m *SignDayReward) GetItemCount() int32 {
	if m != nil && m.ItemCount != nil {
		return *m.ItemCount
	}
	return 0
}

func (m *SignDayReward) GetVipDouble() int32 {
	if m != nil && m.VipDouble != nil {
		return *m.VipDouble
	}
	return 0
}

type LuaPackageItemWeight struct {
	RewardId             *int32   `protobuf:"zigzag32,1,req,name=reward_id" json:"reward_id,omitempty"`
	Weight               *int32   `protobuf:"zigzag32,2,req,name=weight" json:"weight,omitempty"`
	Count                *int32   `protobuf:"zigzag32,3,req,name=count" json:"count,omitempty"`
	Clean                *int32   `protobuf:"zigzag32,4,req,name=clean" json:"clean,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaPackageItemWeight) Reset()         { *m = LuaPackageItemWeight{} }
func (m *LuaPackageItemWeight) String() string { return proto.CompactTextString(m) }
func (*LuaPackageItemWeight) ProtoMessage()    {}
func (*LuaPackageItemWeight) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{9}
}
func (m *LuaPackageItemWeight) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaPackageItemWeight) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaPackageItemWeight.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaPackageItemWeight) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaPackageItemWeight.Merge(m, src)
}
func (m *LuaPackageItemWeight) XXX_Size() int {
	return m.Size()
}
func (m *LuaPackageItemWeight) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaPackageItemWeight.DiscardUnknown(m)
}

var xxx_messageInfo_LuaPackageItemWeight proto.InternalMessageInfo

func (m *LuaPackageItemWeight) GetRewardId() int32 {
	if m != nil && m.RewardId != nil {
		return *m.RewardId
	}
	return 0
}

func (m *LuaPackageItemWeight) GetWeight() int32 {
	if m != nil && m.Weight != nil {
		return *m.Weight
	}
	return 0
}

func (m *LuaPackageItemWeight) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *LuaPackageItemWeight) GetClean() int32 {
	if m != nil && m.Clean != nil {
		return *m.Clean
	}
	return 0
}

type FunctionopenRiskInfo struct {
	Chapid               *int32   `protobuf:"zigzag32,1,req,name=chapid" json:"chapid,omitempty"`
	Dupid                *int32   `protobuf:"zigzag32,2,req,name=dupid" json:"dupid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FunctionopenRiskInfo) Reset()         { *m = FunctionopenRiskInfo{} }
func (m *FunctionopenRiskInfo) String() string { return proto.CompactTextString(m) }
func (*FunctionopenRiskInfo) ProtoMessage()    {}
func (*FunctionopenRiskInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{10}
}
func (m *FunctionopenRiskInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionopenRiskInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FunctionopenRiskInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FunctionopenRiskInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionopenRiskInfo.Merge(m, src)
}
func (m *FunctionopenRiskInfo) XXX_Size() int {
	return m.Size()
}
func (m *FunctionopenRiskInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionopenRiskInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionopenRiskInfo proto.InternalMessageInfo

func (m *FunctionopenRiskInfo) GetChapid() int32 {
	if m != nil && m.Chapid != nil {
		return *m.Chapid
	}
	return 0
}

func (m *FunctionopenRiskInfo) GetDupid() int32 {
	if m != nil && m.Dupid != nil {
		return *m.Dupid
	}
	return 0
}

type EquipLastingDecline struct {
	TotalValue           *int32   `protobuf:"zigzag32,1,req,name=total_value" json:"total_value,omitempty"`
	SelectNum            *int32   `protobuf:"zigzag32,2,req,name=select_num" json:"select_num,omitempty"`
	DeclineNum           *int32   `protobuf:"zigzag32,3,req,name=decline_num" json:"decline_num,omitempty"`
	DeclineMin           *int32   `protobuf:"zigzag32,4,req,name=decline_min" json:"decline_min,omitempty"`
	DeclineMax           *int32   `protobuf:"zigzag32,5,req,name=decline_max" json:"decline_max,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EquipLastingDecline) Reset()         { *m = EquipLastingDecline{} }
func (m *EquipLastingDecline) String() string { return proto.CompactTextString(m) }
func (*EquipLastingDecline) ProtoMessage()    {}
func (*EquipLastingDecline) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{11}
}
func (m *EquipLastingDecline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EquipLastingDecline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EquipLastingDecline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EquipLastingDecline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EquipLastingDecline.Merge(m, src)
}
func (m *EquipLastingDecline) XXX_Size() int {
	return m.Size()
}
func (m *EquipLastingDecline) XXX_DiscardUnknown() {
	xxx_messageInfo_EquipLastingDecline.DiscardUnknown(m)
}

var xxx_messageInfo_EquipLastingDecline proto.InternalMessageInfo

func (m *EquipLastingDecline) GetTotalValue() int32 {
	if m != nil && m.TotalValue != nil {
		return *m.TotalValue
	}
	return 0
}

func (m *EquipLastingDecline) GetSelectNum() int32 {
	if m != nil && m.SelectNum != nil {
		return *m.SelectNum
	}
	return 0
}

func (m *EquipLastingDecline) GetDeclineNum() int32 {
	if m != nil && m.DeclineNum != nil {
		return *m.DeclineNum
	}
	return 0
}

func (m *EquipLastingDecline) GetDeclineMin() int32 {
	if m != nil && m.DeclineMin != nil {
		return *m.DeclineMin
	}
	return 0
}

func (m *EquipLastingDecline) GetDeclineMax() int32 {
	if m != nil && m.DeclineMax != nil {
		return *m.DeclineMax
	}
	return 0
}

type EquipResolveItem struct {
	ItemId               *int32   `protobuf:"zigzag32,1,req,name=item_id" json:"item_id,omitempty"`
	MinNum               *int32   `protobuf:"zigzag32,2,req,name=min_num" json:"min_num,omitempty"`
	MaxNum               *int32   `protobuf:"zigzag32,3,req,name=max_num" json:"max_num,omitempty"`
	Rate                 *int32   `protobuf:"zigzag32,4,req,name=rate" json:"rate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EquipResolveItem) Reset()         { *m = EquipResolveItem{} }
func (m *EquipResolveItem) String() string { return proto.CompactTextString(m) }
func (*EquipResolveItem) ProtoMessage()    {}
func (*EquipResolveItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{12}
}
func (m *EquipResolveItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EquipResolveItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EquipResolveItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EquipResolveItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EquipResolveItem.Merge(m, src)
}
func (m *EquipResolveItem) XXX_Size() int {
	return m.Size()
}
func (m *EquipResolveItem) XXX_DiscardUnknown() {
	xxx_messageInfo_EquipResolveItem.DiscardUnknown(m)
}

var xxx_messageInfo_EquipResolveItem proto.InternalMessageInfo

func (m *EquipResolveItem) GetItemId() int32 {
	if m != nil && m.ItemId != nil {
		return *m.ItemId
	}
	return 0
}

func (m *EquipResolveItem) GetMinNum() int32 {
	if m != nil && m.MinNum != nil {
		return *m.MinNum
	}
	return 0
}

func (m *EquipResolveItem) GetMaxNum() int32 {
	if m != nil && m.MaxNum != nil {
		return *m.MaxNum
	}
	return 0
}

func (m *EquipResolveItem) GetRate() int32 {
	if m != nil && m.Rate != nil {
		return *m.Rate
	}
	return 0
}

// 副本章节关卡
type ChapterRisk struct {
	ChapterId            *int32   `protobuf:"zigzag32,1,req,name=chapter_id" json:"chapter_id,omitempty"`
	RiskId               *int32   `protobuf:"zigzag32,2,req,name=risk_id" json:"risk_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChapterRisk) Reset()         { *m = ChapterRisk{} }
func (m *ChapterRisk) String() string { return proto.CompactTextString(m) }
func (*ChapterRisk) ProtoMessage()    {}
func (*ChapterRisk) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{13}
}
func (m *ChapterRisk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChapterRisk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChapterRisk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChapterRisk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChapterRisk.Merge(m, src)
}
func (m *ChapterRisk) XXX_Size() int {
	return m.Size()
}
func (m *ChapterRisk) XXX_DiscardUnknown() {
	xxx_messageInfo_ChapterRisk.DiscardUnknown(m)
}

var xxx_messageInfo_ChapterRisk proto.InternalMessageInfo

func (m *ChapterRisk) GetChapterId() int32 {
	if m != nil && m.ChapterId != nil {
		return *m.ChapterId
	}
	return 0
}

func (m *ChapterRisk) GetRiskId() int32 {
	if m != nil && m.RiskId != nil {
		return *m.RiskId
	}
	return 0
}

type EquipEnduranceCost struct {
	MinCost              *int32   `protobuf:"zigzag32,1,req,name=min_cost" json:"min_cost,omitempty"`
	MaxCost              *int32   `protobuf:"zigzag32,2,req,name=max_cost" json:"max_cost,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EquipEnduranceCost) Reset()         { *m = EquipEnduranceCost{} }
func (m *EquipEnduranceCost) String() string { return proto.CompactTextString(m) }
func (*EquipEnduranceCost) ProtoMessage()    {}
func (*EquipEnduranceCost) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{14}
}
func (m *EquipEnduranceCost) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EquipEnduranceCost) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EquipEnduranceCost.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EquipEnduranceCost) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EquipEnduranceCost.Merge(m, src)
}
func (m *EquipEnduranceCost) XXX_Size() int {
	return m.Size()
}
func (m *EquipEnduranceCost) XXX_DiscardUnknown() {
	xxx_messageInfo_EquipEnduranceCost.DiscardUnknown(m)
}

var xxx_messageInfo_EquipEnduranceCost proto.InternalMessageInfo

func (m *EquipEnduranceCost) GetMinCost() int32 {
	if m != nil && m.MinCost != nil {
		return *m.MinCost
	}
	return 0
}

func (m *EquipEnduranceCost) GetMaxCost() int32 {
	if m != nil && m.MaxCost != nil {
		return *m.MaxCost
	}
	return 0
}

// 技能震屏
type ShakeConfig struct {
	Time                 *float32 `protobuf:"fixed32,1,req,name=time" json:"time,omitempty"`
	ShakeId              *int32   `protobuf:"zigzag32,2,req,name=shake_id" json:"shake_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShakeConfig) Reset()         { *m = ShakeConfig{} }
func (m *ShakeConfig) String() string { return proto.CompactTextString(m) }
func (*ShakeConfig) ProtoMessage()    {}
func (*ShakeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{15}
}
func (m *ShakeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShakeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShakeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShakeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShakeConfig.Merge(m, src)
}
func (m *ShakeConfig) XXX_Size() int {
	return m.Size()
}
func (m *ShakeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ShakeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ShakeConfig proto.InternalMessageInfo

func (m *ShakeConfig) GetTime() float32 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *ShakeConfig) GetShakeId() int32 {
	if m != nil && m.ShakeId != nil {
		return *m.ShakeId
	}
	return 0
}

type NiudanButtonInfo struct {
	Cost                 []*ItemConfig `protobuf:"bytes,1,rep,name=cost" json:"cost,omitempty"`
	MustOutputList       []*ItemConfig `protobuf:"bytes,2,rep,name=must_output_list" json:"must_output_list,omitempty"`
	Cd                   *int32        `protobuf:"zigzag32,3,req,name=cd" json:"cd,omitempty"`
	FirstOutputList      []*ItemConfig `protobuf:"bytes,4,rep,name=first_output_list" json:"first_output_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *NiudanButtonInfo) Reset()         { *m = NiudanButtonInfo{} }
func (m *NiudanButtonInfo) String() string { return proto.CompactTextString(m) }
func (*NiudanButtonInfo) ProtoMessage()    {}
func (*NiudanButtonInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{16}
}
func (m *NiudanButtonInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NiudanButtonInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NiudanButtonInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NiudanButtonInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NiudanButtonInfo.Merge(m, src)
}
func (m *NiudanButtonInfo) XXX_Size() int {
	return m.Size()
}
func (m *NiudanButtonInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NiudanButtonInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NiudanButtonInfo proto.InternalMessageInfo

func (m *NiudanButtonInfo) GetCost() []*ItemConfig {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *NiudanButtonInfo) GetMustOutputList() []*ItemConfig {
	if m != nil {
		return m.MustOutputList
	}
	return nil
}

func (m *NiudanButtonInfo) GetCd() int32 {
	if m != nil && m.Cd != nil {
		return *m.Cd
	}
	return 0
}

func (m *NiudanButtonInfo) GetFirstOutputList() []*ItemConfig {
	if m != nil {
		return m.FirstOutputList
	}
	return nil
}

type ExchangeGoldItem struct {
	Level                *int32   `protobuf:"zigzag32,1,req,name=level" json:"level,omitempty"`
	Gold                 *int32   `protobuf:"zigzag32,2,req,name=gold" json:"gold,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExchangeGoldItem) Reset()         { *m = ExchangeGoldItem{} }
func (m *ExchangeGoldItem) String() string { return proto.CompactTextString(m) }
func (*ExchangeGoldItem) ProtoMessage()    {}
func (*ExchangeGoldItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{17}
}
func (m *ExchangeGoldItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeGoldItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeGoldItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeGoldItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeGoldItem.Merge(m, src)
}
func (m *ExchangeGoldItem) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeGoldItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeGoldItem.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeGoldItem proto.InternalMessageInfo

func (m *ExchangeGoldItem) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *ExchangeGoldItem) GetGold() int32 {
	if m != nil && m.Gold != nil {
		return *m.Gold
	}
	return 0
}

// 随机个数区间
type RandomSection struct {
	MinNum               *int32   `protobuf:"zigzag32,1,req,name=min_num" json:"min_num,omitempty"`
	MaxNum               *int32   `protobuf:"zigzag32,2,req,name=max_num" json:"max_num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RandomSection) Reset()         { *m = RandomSection{} }
func (m *RandomSection) String() string { return proto.CompactTextString(m) }
func (*RandomSection) ProtoMessage()    {}
func (*RandomSection) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{18}
}
func (m *RandomSection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RandomSection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RandomSection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RandomSection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RandomSection.Merge(m, src)
}
func (m *RandomSection) XXX_Size() int {
	return m.Size()
}
func (m *RandomSection) XXX_DiscardUnknown() {
	xxx_messageInfo_RandomSection.DiscardUnknown(m)
}

var xxx_messageInfo_RandomSection proto.InternalMessageInfo

func (m *RandomSection) GetMinNum() int32 {
	if m != nil && m.MinNum != nil {
		return *m.MinNum
	}
	return 0
}

func (m *RandomSection) GetMaxNum() int32 {
	if m != nil && m.MaxNum != nil {
		return *m.MaxNum
	}
	return 0
}

// 具体的百分比属性
type ExtraPerSection struct {
	PerSection           []*RandomSection `protobuf:"bytes,1,rep,name=per_section" json:"per_section,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ExtraPerSection) Reset()         { *m = ExtraPerSection{} }
func (m *ExtraPerSection) String() string { return proto.CompactTextString(m) }
func (*ExtraPerSection) ProtoMessage()    {}
func (*ExtraPerSection) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{19}
}
func (m *ExtraPerSection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtraPerSection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtraPerSection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtraPerSection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtraPerSection.Merge(m, src)
}
func (m *ExtraPerSection) XXX_Size() int {
	return m.Size()
}
func (m *ExtraPerSection) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtraPerSection.DiscardUnknown(m)
}

var xxx_messageInfo_ExtraPerSection proto.InternalMessageInfo

func (m *ExtraPerSection) GetPerSection() []*RandomSection {
	if m != nil {
		return m.PerSection
	}
	return nil
}

//时间区间
type TimeRange struct {
	StartTime            *int32   `protobuf:"zigzag32,1,req,name=start_time" json:"start_time,omitempty"`
	EndTime              *int32   `protobuf:"zigzag32,2,req,name=end_time" json:"end_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TimeRange) Reset()         { *m = TimeRange{} }
func (m *TimeRange) String() string { return proto.CompactTextString(m) }
func (*TimeRange) ProtoMessage()    {}
func (*TimeRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{20}
}
func (m *TimeRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimeRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimeRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeRange.Merge(m, src)
}
func (m *TimeRange) XXX_Size() int {
	return m.Size()
}
func (m *TimeRange) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeRange.DiscardUnknown(m)
}

var xxx_messageInfo_TimeRange proto.InternalMessageInfo

func (m *TimeRange) GetStartTime() int32 {
	if m != nil && m.StartTime != nil {
		return *m.StartTime
	}
	return 0
}

func (m *TimeRange) GetEndTime() int32 {
	if m != nil && m.EndTime != nil {
		return *m.EndTime
	}
	return 0
}

// 澡堂体力一次性恢复时间区间
type BathOnceStimina struct {
	BeginTime            *int32   `protobuf:"varint,1,req,name=begin_time" json:"begin_time,omitempty"`
	EndTime              *int32   `protobuf:"varint,2,req,name=end_time" json:"end_time,omitempty"`
	Value                *int32   `protobuf:"varint,3,req,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BathOnceStimina) Reset()         { *m = BathOnceStimina{} }
func (m *BathOnceStimina) String() string { return proto.CompactTextString(m) }
func (*BathOnceStimina) ProtoMessage()    {}
func (*BathOnceStimina) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{21}
}
func (m *BathOnceStimina) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BathOnceStimina) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BathOnceStimina.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BathOnceStimina) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BathOnceStimina.Merge(m, src)
}
func (m *BathOnceStimina) XXX_Size() int {
	return m.Size()
}
func (m *BathOnceStimina) XXX_DiscardUnknown() {
	xxx_messageInfo_BathOnceStimina.DiscardUnknown(m)
}

var xxx_messageInfo_BathOnceStimina proto.InternalMessageInfo

func (m *BathOnceStimina) GetBeginTime() int32 {
	if m != nil && m.BeginTime != nil {
		return *m.BeginTime
	}
	return 0
}

func (m *BathOnceStimina) GetEndTime() int32 {
	if m != nil && m.EndTime != nil {
		return *m.EndTime
	}
	return 0
}

func (m *BathOnceStimina) GetValue() int32 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

//Boss出场信息
type BossEnter struct {
	Time                 *int32   `protobuf:"zigzag32,1,req,name=time" json:"time,omitempty"`
	Id                   *int32   `protobuf:"zigzag32,2,req,name=id" json:"id,omitempty"`
	Count                *int32   `protobuf:"zigzag32,3,req,name=count" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BossEnter) Reset()         { *m = BossEnter{} }
func (m *BossEnter) String() string { return proto.CompactTextString(m) }
func (*BossEnter) ProtoMessage()    {}
func (*BossEnter) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{22}
}
func (m *BossEnter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BossEnter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BossEnter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BossEnter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BossEnter.Merge(m, src)
}
func (m *BossEnter) XXX_Size() int {
	return m.Size()
}
func (m *BossEnter) XXX_DiscardUnknown() {
	xxx_messageInfo_BossEnter.DiscardUnknown(m)
}

var xxx_messageInfo_BossEnter proto.InternalMessageInfo

func (m *BossEnter) GetTime() int32 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *BossEnter) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *BossEnter) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

// 小游戏等级奖励
type MinigameLevelReward struct {
	Exp                  *int32   `protobuf:"zigzag32,1,req,name=exp" json:"exp,omitempty"`
	Gold                 *int32   `protobuf:"zigzag32,2,req,name=gold" json:"gold,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MinigameLevelReward) Reset()         { *m = MinigameLevelReward{} }
func (m *MinigameLevelReward) String() string { return proto.CompactTextString(m) }
func (*MinigameLevelReward) ProtoMessage()    {}
func (*MinigameLevelReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{23}
}
func (m *MinigameLevelReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MinigameLevelReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MinigameLevelReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MinigameLevelReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MinigameLevelReward.Merge(m, src)
}
func (m *MinigameLevelReward) XXX_Size() int {
	return m.Size()
}
func (m *MinigameLevelReward) XXX_DiscardUnknown() {
	xxx_messageInfo_MinigameLevelReward.DiscardUnknown(m)
}

var xxx_messageInfo_MinigameLevelReward proto.InternalMessageInfo

func (m *MinigameLevelReward) GetExp() int32 {
	if m != nil && m.Exp != nil {
		return *m.Exp
	}
	return 0
}

func (m *MinigameLevelReward) GetGold() int32 {
	if m != nil && m.Gold != nil {
		return *m.Gold
	}
	return 0
}

type MinigameScoreReward_ struct {
	ItemId               *int32   `protobuf:"zigzag32,1,req,name=item_id" json:"item_id,omitempty"`
	MinNum               *int32   `protobuf:"zigzag32,2,req,name=min_num" json:"min_num,omitempty"`
	MaxNum               *int32   `protobuf:"zigzag32,3,req,name=max_num" json:"max_num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MinigameScoreReward_) Reset()         { *m = MinigameScoreReward_{} }
func (m *MinigameScoreReward_) String() string { return proto.CompactTextString(m) }
func (*MinigameScoreReward_) ProtoMessage()    {}
func (*MinigameScoreReward_) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{24}
}
func (m *MinigameScoreReward_) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MinigameScoreReward_) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MinigameScoreReward_.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MinigameScoreReward_) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MinigameScoreReward_.Merge(m, src)
}
func (m *MinigameScoreReward_) XXX_Size() int {
	return m.Size()
}
func (m *MinigameScoreReward_) XXX_DiscardUnknown() {
	xxx_messageInfo_MinigameScoreReward_.DiscardUnknown(m)
}

var xxx_messageInfo_MinigameScoreReward_ proto.InternalMessageInfo

func (m *MinigameScoreReward_) GetItemId() int32 {
	if m != nil && m.ItemId != nil {
		return *m.ItemId
	}
	return 0
}

func (m *MinigameScoreReward_) GetMinNum() int32 {
	if m != nil && m.MinNum != nil {
		return *m.MinNum
	}
	return 0
}

func (m *MinigameScoreReward_) GetMaxNum() int32 {
	if m != nil && m.MaxNum != nil {
		return *m.MaxNum
	}
	return 0
}

type MinigameScoreReward struct {
	DisplayPercent       *int32                `protobuf:"zigzag32,1,req,name=display_percent" json:"display_percent,omitempty"`
	Reward               *MinigameScoreReward_ `protobuf:"bytes,2,req,name=reward" json:"reward,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MinigameScoreReward) Reset()         { *m = MinigameScoreReward{} }
func (m *MinigameScoreReward) String() string { return proto.CompactTextString(m) }
func (*MinigameScoreReward) ProtoMessage()    {}
func (*MinigameScoreReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{25}
}
func (m *MinigameScoreReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MinigameScoreReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MinigameScoreReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MinigameScoreReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MinigameScoreReward.Merge(m, src)
}
func (m *MinigameScoreReward) XXX_Size() int {
	return m.Size()
}
func (m *MinigameScoreReward) XXX_DiscardUnknown() {
	xxx_messageInfo_MinigameScoreReward.DiscardUnknown(m)
}

var xxx_messageInfo_MinigameScoreReward proto.InternalMessageInfo

func (m *MinigameScoreReward) GetDisplayPercent() int32 {
	if m != nil && m.DisplayPercent != nil {
		return *m.DisplayPercent
	}
	return 0
}

func (m *MinigameScoreReward) GetReward() *MinigameScoreReward_ {
	if m != nil {
		return m.Reward
	}
	return nil
}

// 小游戏排行
type MinigameRankInfo struct {
	Diff                 *int32   `protobuf:"zigzag32,1,req,name=diff" json:"diff,omitempty"`
	Display              *int32   `protobuf:"zigzag32,2,req,name=display" json:"display,omitempty"`
	Defeat               *int32   `protobuf:"zigzag32,3,req,name=defeat" json:"defeat,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MinigameRankInfo) Reset()         { *m = MinigameRankInfo{} }
func (m *MinigameRankInfo) String() string { return proto.CompactTextString(m) }
func (*MinigameRankInfo) ProtoMessage()    {}
func (*MinigameRankInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{26}
}
func (m *MinigameRankInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MinigameRankInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MinigameRankInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MinigameRankInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MinigameRankInfo.Merge(m, src)
}
func (m *MinigameRankInfo) XXX_Size() int {
	return m.Size()
}
func (m *MinigameRankInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MinigameRankInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MinigameRankInfo proto.InternalMessageInfo

func (m *MinigameRankInfo) GetDiff() int32 {
	if m != nil && m.Diff != nil {
		return *m.Diff
	}
	return 0
}

func (m *MinigameRankInfo) GetDisplay() int32 {
	if m != nil && m.Display != nil {
		return *m.Display
	}
	return 0
}

func (m *MinigameRankInfo) GetDefeat() int32 {
	if m != nil && m.Defeat != nil {
		return *m.Defeat
	}
	return 0
}

// 通用商店物品价格信息
type CommonGoodPrice struct {
	ItemId               *int32   `protobuf:"zigzag32,1,req,name=item_id" json:"item_id,omitempty"`
	Num                  *int32   `protobuf:"zigzag32,2,req,name=num" json:"num,omitempty"`
	CostType             *int32   `protobuf:"zigzag32,3,req,name=cost_type" json:"cost_type,omitempty"`
	Price                *int32   `protobuf:"zigzag32,4,req,name=price" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommonGoodPrice) Reset()         { *m = CommonGoodPrice{} }
func (m *CommonGoodPrice) String() string { return proto.CompactTextString(m) }
func (*CommonGoodPrice) ProtoMessage()    {}
func (*CommonGoodPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_26e7dc0545a5519b, []int{27}
}
func (m *CommonGoodPrice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonGoodPrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonGoodPrice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonGoodPrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonGoodPrice.Merge(m, src)
}
func (m *CommonGoodPrice) XXX_Size() int {
	return m.Size()
}
func (m *CommonGoodPrice) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonGoodPrice.DiscardUnknown(m)
}

var xxx_messageInfo_CommonGoodPrice proto.InternalMessageInfo

func (m *CommonGoodPrice) GetItemId() int32 {
	if m != nil && m.ItemId != nil {
		return *m.ItemId
	}
	return 0
}

func (m *CommonGoodPrice) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

func (m *CommonGoodPrice) GetCostType() int32 {
	if m != nil && m.CostType != nil {
		return *m.CostType
	}
	return 0
}

func (m *CommonGoodPrice) GetPrice() int32 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

func init() {
	proto.RegisterType((*LuaRgba)(nil), "pbd.lua_rgba")
	proto.RegisterType((*LuaSize)(nil), "pbd.lua_size")
	proto.RegisterType((*LuaArenaRect)(nil), "pbd.lua_arena_rect")
	proto.RegisterType((*OpenDupConfig)(nil), "pbd.open_dup_config")
	proto.RegisterType((*LuaEventArgList)(nil), "pbd.lua_event_arg_list")
	proto.RegisterType((*ShopRandomSection)(nil), "pbd.shop_random_section")
	proto.RegisterType((*ShopRandomSectionList)(nil), "pbd.shop_random_section_list")
	proto.RegisterType((*BathInteractTool)(nil), "pbd.bath_interact_tool")
	proto.RegisterType((*SignDayReward)(nil), "pbd.sign_day_reward")
	proto.RegisterType((*LuaPackageItemWeight)(nil), "pbd.lua_package_item_weight")
	proto.RegisterType((*FunctionopenRiskInfo)(nil), "pbd.functionopen_risk_info")
	proto.RegisterType((*EquipLastingDecline)(nil), "pbd.equip_lasting_decline")
	proto.RegisterType((*EquipResolveItem)(nil), "pbd.equip_resolve_item")
	proto.RegisterType((*ChapterRisk)(nil), "pbd.chapter_risk")
	proto.RegisterType((*EquipEnduranceCost)(nil), "pbd.equip_endurance_cost")
	proto.RegisterType((*ShakeConfig)(nil), "pbd.shake_config")
	proto.RegisterType((*NiudanButtonInfo)(nil), "pbd.niudan_button_info")
	proto.RegisterType((*ExchangeGoldItem)(nil), "pbd.exchange_gold_item")
	proto.RegisterType((*RandomSection)(nil), "pbd.random_section")
	proto.RegisterType((*ExtraPerSection)(nil), "pbd.extra_per_section")
	proto.RegisterType((*TimeRange)(nil), "pbd.time_range")
	proto.RegisterType((*BathOnceStimina)(nil), "pbd.bath_once_stimina")
	proto.RegisterType((*BossEnter)(nil), "pbd.boss_enter")
	proto.RegisterType((*MinigameLevelReward)(nil), "pbd.minigame_level_reward")
	proto.RegisterType((*MinigameScoreReward_)(nil), "pbd.minigame_score_reward_")
	proto.RegisterType((*MinigameScoreReward)(nil), "pbd.minigame_score_reward")
	proto.RegisterType((*MinigameRankInfo)(nil), "pbd.minigame_rank_info")
	proto.RegisterType((*CommonGoodPrice)(nil), "pbd.common_good_price")
}

func init() { proto.RegisterFile("ProtoBaseDef.proto", fileDescriptor_26e7dc0545a5519b) }

var fileDescriptor_26e7dc0545a5519b = []byte{
	// 921 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xcd, 0x8e, 0x23, 0x35,
	0x10, 0x26, 0x7f, 0xb3, 0xbb, 0x95, 0x6c, 0x32, 0xf1, 0xb0, 0xbb, 0x11, 0x48, 0xd1, 0xa8, 0x25,
	0xa4, 0xb0, 0x88, 0x01, 0xb2, 0x02, 0x24, 0x24, 0x2e, 0xcb, 0x1e, 0x18, 0xe0, 0x80, 0x84, 0xb8,
	0x20, 0x21, 0xcb, 0x69, 0x57, 0x3a, 0xd6, 0x74, 0xdb, 0x8d, 0xed, 0x4e, 0x32, 0x5c, 0x78, 0x0d,
	0x78, 0x23, 0x8e, 0x3c, 0x02, 0x1a, 0x5e, 0x04, 0xf9, 0xa7, 0x3b, 0x3d, 0x99, 0x70, 0xe1, 0x66,
	0x97, 0xfd, 0xd5, 0xcf, 0xf7, 0x55, 0x15, 0x90, 0xef, 0xb5, 0xb2, 0xea, 0x35, 0x33, 0xf8, 0x06,
	0xd7, 0x57, 0xa5, 0xbb, 0x90, 0x5e, 0xb9, 0xe2, 0xef, 0x8c, 0xfd, 0x43, 0x63, 0x4c, 0x3e, 0x83,
	0xc7, 0x79, 0xc5, 0xa8, 0xce, 0x56, 0x8c, 0x3c, 0x81, 0x8e, 0x9e, 0x75, 0x2e, 0xbb, 0x8b, 0xa9,
	0x3b, 0x66, 0xb3, 0x6e, 0x7d, 0x5c, 0xcd, 0x7a, 0xf5, 0x91, 0xcd, 0xfa, 0x97, 0xdd, 0x45, 0x37,
	0x79, 0x3f, 0xe0, 0x8c, 0xf8, 0x15, 0xc9, 0x53, 0x18, 0xec, 0x04, 0xb7, 0x9b, 0x88, 0x1d, 0xc3,
	0xd9, 0x06, 0x45, 0xb6, 0xb1, 0xc1, 0x41, 0xf2, 0x12, 0xc6, 0xee, 0x2b, 0xd3, 0x28, 0x19, 0xd5,
	0x98, 0x5a, 0x32, 0x84, 0x5e, 0xae, 0x76, 0xf1, 0xfb, 0x10, 0x7a, 0x1b, 0x11, 0x83, 0x25, 0x1f,
	0xc3, 0x44, 0x95, 0x28, 0x29, 0xaf, 0x4a, 0x9a, 0x2a, 0xb9, 0x16, 0x99, 0x73, 0x97, 0x6e, 0x58,
	0x79, 0xfd, 0x26, 0xfe, 0x7f, 0x0a, 0x03, 0x5e, 0xb9, 0x6b, 0x40, 0xbc, 0x07, 0xc4, 0x79, 0xc7,
	0x2d, 0x4a, 0x4b, 0x99, 0xce, 0x68, 0x2e, 0x8c, 0x25, 0x13, 0x78, 0x54, 0xa2, 0x4e, 0x51, 0xda,
	0x59, 0xe7, 0xb2, 0xb3, 0x98, 0x26, 0xaf, 0xe0, 0xc2, 0x6c, 0x54, 0x49, 0x35, 0x93, 0x5c, 0x15,
	0xd4, 0x60, 0x6a, 0x85, 0x92, 0xce, 0x59, 0x21, 0xe4, 0x35, 0x3f, 0xf8, 0x2e, 0xd8, 0xfe, 0x9a,
	0x47, 0xdf, 0xd7, 0x30, 0x3b, 0x01, 0x0a, 0x11, 0x3e, 0x84, 0x61, 0xbc, 0x7f, 0x27, 0x8c, 0x8b,
	0xd2, 0x5b, 0x0c, 0x97, 0xb3, 0xab, 0x72, 0xc5, 0xaf, 0x4e, 0x60, 0x92, 0x8f, 0x80, 0xac, 0x98,
	0xdd, 0x50, 0x21, 0x2d, 0x6a, 0x96, 0x5a, 0x6a, 0x95, 0xca, 0xc9, 0x08, 0xfa, 0xf6, 0xb6, 0xc4,
	0x03, 0x13, 0xb2, 0x2a, 0x62, 0xec, 0x6f, 0x60, 0x62, 0x44, 0x26, 0x29, 0x67, 0xb7, 0x54, 0xe3,
	0x8e, 0x69, 0xee, 0x8a, 0x12, 0x16, 0x0b, 0x2a, 0xea, 0x74, 0x09, 0x80, 0x37, 0xa4, 0xaa, 0x92,
	0x91, 0x6d, 0x67, 0xdb, 0x8a, 0x92, 0x72, 0x55, 0xad, 0x72, 0x0c, 0xba, 0x25, 0x3f, 0xc1, 0x0b,
	0xc7, 0x51, 0xc9, 0xd2, 0x1b, 0x96, 0x21, 0xf5, 0x98, 0x9d, 0x97, 0x88, 0x4c, 0xe1, 0x49, 0xf0,
	0x7e, 0xf0, 0x3a, 0x86, 0xb3, 0x5d, 0x4b, 0x3f, 0x47, 0x4a, 0x08, 0xd0, 0x6b, 0xae, 0x39, 0x32,
	0xe9, 0x1b, 0x61, 0x9a, 0x7c, 0x0e, 0xcf, 0xd7, 0x95, 0xf4, 0x45, 0x7a, 0xe5, 0xb4, 0x30, 0x37,
	0x54, 0xc8, 0xb5, 0xaa, 0x85, 0x13, 0xfc, 0x9e, 0x70, 0xa2, 0x26, 0xf7, 0x37, 0x78, 0x86, 0xbf,
	0x54, 0xa2, 0xa4, 0x39, 0x33, 0x56, 0xc8, 0x8c, 0x72, 0x4c, 0x73, 0x21, 0x91, 0x5c, 0xc0, 0xd0,
	0x2a, 0xcb, 0x72, 0xba, 0x65, 0x79, 0x85, 0x87, 0x52, 0x0d, 0xe6, 0x98, 0x5a, 0xda, 0x50, 0xe4,
	0x3e, 0x46, 0x8c, 0x37, 0xf6, 0x8e, 0x8d, 0x85, 0x88, 0x49, 0xde, 0x33, 0xb2, 0xfd, 0x6c, 0xe0,
	0x13, 0xf8, 0x11, 0x48, 0x48, 0x40, 0xa3, 0x51, 0xf9, 0x36, 0xf0, 0xf2, 0x90, 0xe4, 0x09, 0x3c,
	0x2a, 0x84, 0x6c, 0x85, 0x75, 0x06, 0xb6, 0x6f, 0x85, 0x1c, 0x41, 0x5f, 0x33, 0x8b, 0x91, 0x90,
	0x57, 0x30, 0x72, 0x65, 0x5b, 0xd4, 0x9e, 0x0b, 0x97, 0x79, 0x7d, 0x6f, 0xfb, 0x0c, 0x3c, 0xd5,
	0x64, 0x7c, 0x01, 0x6f, 0x87, 0x5c, 0x50, 0xf2, 0x4a, 0x33, 0x99, 0x22, 0x4d, 0x95, 0xb1, 0xe4,
	0x1c, 0x1e, 0xbb, 0xe0, 0xee, 0x1c, 0xa1, 0xce, 0xc2, 0xf6, 0xc1, 0x12, 0xb0, 0x57, 0x30, 0x32,
	0x1b, 0x76, 0x83, 0xf5, 0xc0, 0xb8, 0xa6, 0x12, 0x45, 0x20, 0xae, 0xeb, 0xfe, 0x87, 0xd7, 0x26,
	0xd6, 0x1f, 0x1d, 0x20, 0x52, 0x54, 0x9c, 0x49, 0xba, 0xaa, 0xac, 0x55, 0x32, 0xc8, 0x35, 0x87,
	0x7e, 0x0c, 0xe3, 0x3a, 0xf9, 0xdc, 0x77, 0x72, 0xec, 0x2e, 0xef, 0xf6, 0x25, 0x9c, 0x17, 0x95,
	0xb1, 0x54, 0x55, 0xb6, 0xac, 0xac, 0x1f, 0x82, 0x59, 0xf7, 0x3f, 0xfe, 0x02, 0x74, 0x53, 0x1e,
	0xd9, 0xf9, 0x00, 0xa6, 0x6b, 0xa1, 0x8f, 0x80, 0xfd, 0xd3, 0xc0, 0xe4, 0x13, 0x20, 0xb8, 0x4f,
	0x37, 0x4c, 0x66, 0x48, 0x33, 0x95, 0xf3, 0xa0, 0xc9, 0x53, 0x18, 0xe4, 0xb8, 0xc5, 0x3c, 0x52,
	0x30, 0x82, 0xbe, 0x7b, 0x8b, 0xe5, 0x2c, 0x61, 0x7c, 0x34, 0xd4, 0x2d, 0xc5, 0x3a, 0xc7, 0x8a,
	0x05, 0xcc, 0x97, 0x30, 0xc5, 0xbd, 0xd5, 0x8c, 0x96, 0xa8, 0x1b, 0xd8, 0x02, 0x86, 0xad, 0x6b,
	0xe4, 0xe1, 0xc2, 0xa7, 0x78, 0x34, 0xcc, 0x4b, 0x00, 0xc7, 0xb0, 0x9b, 0xf1, 0x0c, 0x7d, 0x6b,
	0x5a, 0xa6, 0x2d, 0x6d, 0x58, 0xf7, 0x2a, 0xa1, 0xe4, 0xc1, 0x12, 0x42, 0x7e, 0x0d, 0x53, 0xbf,
	0x00, 0x94, 0xd3, 0xd6, 0x58, 0x51, 0x08, 0xc9, 0x1c, 0x74, 0x85, 0x99, 0x90, 0x07, 0xe8, 0xe0,
	0x01, 0x74, 0xe0, 0xca, 0x0f, 0xa3, 0xe0, 0x08, 0x1d, 0x24, 0x9f, 0x02, 0xac, 0x94, 0x31, 0x14,
	0xdd, 0x2a, 0xb9, 0xa7, 0xf6, 0xd4, 0x11, 0x5f, 0xeb, 0x7c, 0x34, 0xb7, 0xc9, 0x12, 0x9e, 0x15,
	0x42, 0x8a, 0x8c, 0x15, 0x48, 0x3d, 0x9b, 0xf5, 0x5a, 0x19, 0x42, 0x0f, 0xf7, 0xe5, 0x49, 0x6e,
	0xbf, 0x85, 0xe7, 0x0d, 0xc6, 0xa4, 0x4a, 0x63, 0xc4, 0xd0, 0xff, 0x31, 0x26, 0xc9, 0xcf, 0xad,
	0x04, 0xda, 0xce, 0xc8, 0x0b, 0x98, 0x70, 0x61, 0xca, 0x9c, 0xdd, 0xd2, 0xc3, 0xd2, 0x0e, 0xad,
	0x73, 0x16, 0xbe, 0x78, 0x97, 0xc3, 0xe5, 0xbb, 0x5e, 0x8c, 0xd3, 0x19, 0x25, 0x5f, 0x01, 0x69,
	0x5e, 0x34, 0x93, 0x71, 0x09, 0x8d, 0xa0, 0xcf, 0xc5, 0x7a, 0x7d, 0x48, 0x32, 0x46, 0x8a, 0x49,
	0x8e, 0xe1, 0x8c, 0xe3, 0x1a, 0x59, 0x4d, 0xd2, 0x0f, 0x30, 0x4d, 0x55, 0x51, 0x28, 0x49, 0x33,
	0xa5, 0x38, 0x2d, 0xb5, 0x48, 0xf1, 0x61, 0xad, 0xed, 0x45, 0xed, 0x36, 0xa8, 0x9b, 0x1b, 0xea,
	0x17, 0x79, 0xb3, 0x22, 0x3d, 0x32, 0x6c, 0x84, 0xd7, 0xe7, 0x7f, 0xde, 0xcd, 0x3b, 0x7f, 0xdd,
	0xcd, 0x3b, 0x7f, 0xdf, 0xcd, 0x3b, 0xbf, 0xff, 0x33, 0x7f, 0xeb, 0xdf, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x42, 0x0e, 0xf5, 0x36, 0x9f, 0x07, 0x00, 0x00,
}

func (m *LuaRgba) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaRgba) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.R == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.R)<<1)^uint32((*m.R>>31))))
	}
	if m.G == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.G)<<1)^uint32((*m.G>>31))))
	}
	if m.B == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.B)<<1)^uint32((*m.B>>31))))
	}
	if m.A == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.A))))
		i += 4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LuaSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaSize) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Width == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Width)<<1)^uint32((*m.Width>>31))))
	}
	if m.Height == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Height)<<1)^uint32((*m.Height>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LuaArenaRect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaArenaRect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Low == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Low)<<1)^uint32((*m.Low>>31))))
	}
	if m.Hig == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Hig)<<1)^uint32((*m.Hig>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OpenDupConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenDupConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChapID == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.ChapID)<<1)^uint32((*m.ChapID>>31))))
	}
	if m.DupID == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.DupID)<<1)^uint32((*m.DupID>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LuaEventArgList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaEventArgList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Percent != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Percent)<<1)^uint32((*m.Percent>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShopRandomSection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShopRandomSection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.MinId)<<1)^uint32((*m.MinId>>31))))
	}
	if m.MaxId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.MaxId)<<1)^uint32((*m.MaxId>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShopRandomSectionList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShopRandomSectionList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SectionList) > 0 {
		for _, msg := range m.SectionList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProtoBaseDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BathInteractTool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BathInteractTool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
	}
	if m.Num == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Num)<<1)^uint32((*m.Num>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SignDayReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignDayReward) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.ItemId)<<1)^uint32((*m.ItemId>>31))))
	}
	if m.ItemCount == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.ItemCount)<<1)^uint32((*m.ItemCount>>31))))
	}
	if m.VipDouble == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.VipDouble)<<1)^uint32((*m.VipDouble>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LuaPackageItemWeight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaPackageItemWeight) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RewardId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.RewardId)<<1)^uint32((*m.RewardId>>31))))
	}
	if m.Weight == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Weight)<<1)^uint32((*m.Weight>>31))))
	}
	if m.Count == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Count)<<1)^uint32((*m.Count>>31))))
	}
	if m.Clean == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Clean)<<1)^uint32((*m.Clean>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FunctionopenRiskInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionopenRiskInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chapid == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Chapid)<<1)^uint32((*m.Chapid>>31))))
	}
	if m.Dupid == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Dupid)<<1)^uint32((*m.Dupid>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EquipLastingDecline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipLastingDecline) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalValue == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.TotalValue)<<1)^uint32((*m.TotalValue>>31))))
	}
	if m.SelectNum == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.SelectNum)<<1)^uint32((*m.SelectNum>>31))))
	}
	if m.DeclineNum == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.DeclineNum)<<1)^uint32((*m.DeclineNum>>31))))
	}
	if m.DeclineMin == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.DeclineMin)<<1)^uint32((*m.DeclineMin>>31))))
	}
	if m.DeclineMax == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.DeclineMax)<<1)^uint32((*m.DeclineMax>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EquipResolveItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipResolveItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.ItemId)<<1)^uint32((*m.ItemId>>31))))
	}
	if m.MinNum == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.MinNum)<<1)^uint32((*m.MinNum>>31))))
	}
	if m.MaxNum == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.MaxNum)<<1)^uint32((*m.MaxNum>>31))))
	}
	if m.Rate == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Rate)<<1)^uint32((*m.Rate>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChapterRisk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChapterRisk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChapterId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.ChapterId)<<1)^uint32((*m.ChapterId>>31))))
	}
	if m.RiskId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.RiskId)<<1)^uint32((*m.RiskId>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EquipEnduranceCost) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipEnduranceCost) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinCost == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.MinCost)<<1)^uint32((*m.MinCost>>31))))
	}
	if m.MaxCost == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.MaxCost)<<1)^uint32((*m.MaxCost>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShakeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShakeConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Time))))
		i += 4
	}
	if m.ShakeId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.ShakeId)<<1)^uint32((*m.ShakeId>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NiudanButtonInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NiudanButtonInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cost) > 0 {
		for _, msg := range m.Cost {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProtoBaseDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MustOutputList) > 0 {
		for _, msg := range m.MustOutputList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintProtoBaseDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Cd == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Cd)<<1)^uint32((*m.Cd>>31))))
	}
	if len(m.FirstOutputList) > 0 {
		for _, msg := range m.FirstOutputList {
			dAtA[i] = 0x22
			i++
			i = encodeVarintProtoBaseDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExchangeGoldItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeGoldItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
	}
	if m.Gold == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Gold)<<1)^uint32((*m.Gold>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RandomSection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RandomSection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinNum == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.MinNum)<<1)^uint32((*m.MinNum>>31))))
	}
	if m.MaxNum == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.MaxNum)<<1)^uint32((*m.MaxNum>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExtraPerSection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtraPerSection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PerSection) > 0 {
		for _, msg := range m.PerSection {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProtoBaseDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TimeRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.StartTime)<<1)^uint32((*m.StartTime>>31))))
	}
	if m.EndTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.EndTime)<<1)^uint32((*m.EndTime>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BathOnceStimina) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BathOnceStimina) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BeginTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64(*m.BeginTime))
	}
	if m.EndTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64(*m.EndTime))
	}
	if m.Value == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64(*m.Value))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BossEnter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BossEnter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Time)<<1)^uint32((*m.Time>>31))))
	}
	if m.Id == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
	}
	if m.Count == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Count)<<1)^uint32((*m.Count>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MinigameLevelReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinigameLevelReward) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exp == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Exp)<<1)^uint32((*m.Exp>>31))))
	}
	if m.Gold == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Gold)<<1)^uint32((*m.Gold>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MinigameScoreReward_) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinigameScoreReward_) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.ItemId)<<1)^uint32((*m.ItemId>>31))))
	}
	if m.MinNum == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.MinNum)<<1)^uint32((*m.MinNum>>31))))
	}
	if m.MaxNum == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.MaxNum)<<1)^uint32((*m.MaxNum>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MinigameScoreReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinigameScoreReward) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DisplayPercent == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.DisplayPercent)<<1)^uint32((*m.DisplayPercent>>31))))
	}
	if m.Reward == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64(m.Reward.Size()))
		n1, err1 := m.Reward.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MinigameRankInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinigameRankInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Diff == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Diff)<<1)^uint32((*m.Diff>>31))))
	}
	if m.Display == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Display)<<1)^uint32((*m.Display>>31))))
	}
	if m.Defeat == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Defeat)<<1)^uint32((*m.Defeat>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommonGoodPrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonGoodPrice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.ItemId)<<1)^uint32((*m.ItemId>>31))))
	}
	if m.Num == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Num)<<1)^uint32((*m.Num>>31))))
	}
	if m.CostType == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.CostType)<<1)^uint32((*m.CostType>>31))))
	}
	if m.Price == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoBaseDef(dAtA, i, uint64((uint32(*m.Price)<<1)^uint32((*m.Price>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintProtoBaseDef(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *LuaRgba) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.R != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.R))
	}
	if m.G != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.G))
	}
	if m.B != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.B))
	}
	if m.A != nil {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaSize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Width != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Width))
	}
	if m.Height != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Height))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaArenaRect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Low != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Low))
	}
	if m.Hig != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Hig))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpenDupConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChapID != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.ChapID))
	}
	if m.DupID != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.DupID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaEventArgList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Percent != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Percent))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShopRandomSection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinId != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.MinId))
	}
	if m.MaxId != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.MaxId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShopRandomSectionList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SectionList) > 0 {
		for _, e := range m.SectionList {
			l = e.Size()
			n += 1 + l + sovProtoBaseDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BathInteractTool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Type))
	}
	if m.Num != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignDayReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemId != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.ItemId))
	}
	if m.ItemCount != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.ItemCount))
	}
	if m.VipDouble != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.VipDouble))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaPackageItemWeight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RewardId != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.RewardId))
	}
	if m.Weight != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Weight))
	}
	if m.Count != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Count))
	}
	if m.Clean != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Clean))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FunctionopenRiskInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chapid != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Chapid))
	}
	if m.Dupid != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Dupid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EquipLastingDecline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalValue != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.TotalValue))
	}
	if m.SelectNum != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.SelectNum))
	}
	if m.DeclineNum != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.DeclineNum))
	}
	if m.DeclineMin != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.DeclineMin))
	}
	if m.DeclineMax != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.DeclineMax))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EquipResolveItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemId != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.ItemId))
	}
	if m.MinNum != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.MinNum))
	}
	if m.MaxNum != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.MaxNum))
	}
	if m.Rate != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Rate))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChapterRisk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChapterId != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.ChapterId))
	}
	if m.RiskId != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.RiskId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EquipEnduranceCost) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinCost != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.MinCost))
	}
	if m.MaxCost != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.MaxCost))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShakeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != nil {
		n += 5
	}
	if m.ShakeId != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.ShakeId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NiudanButtonInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cost) > 0 {
		for _, e := range m.Cost {
			l = e.Size()
			n += 1 + l + sovProtoBaseDef(uint64(l))
		}
	}
	if len(m.MustOutputList) > 0 {
		for _, e := range m.MustOutputList {
			l = e.Size()
			n += 1 + l + sovProtoBaseDef(uint64(l))
		}
	}
	if m.Cd != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Cd))
	}
	if len(m.FirstOutputList) > 0 {
		for _, e := range m.FirstOutputList {
			l = e.Size()
			n += 1 + l + sovProtoBaseDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExchangeGoldItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Level))
	}
	if m.Gold != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Gold))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RandomSection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinNum != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.MinNum))
	}
	if m.MaxNum != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.MaxNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtraPerSection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PerSection) > 0 {
		for _, e := range m.PerSection {
			l = e.Size()
			n += 1 + l + sovProtoBaseDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TimeRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTime != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.StartTime))
	}
	if m.EndTime != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.EndTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BathOnceStimina) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BeginTime != nil {
		n += 1 + sovProtoBaseDef(uint64(*m.BeginTime))
	}
	if m.EndTime != nil {
		n += 1 + sovProtoBaseDef(uint64(*m.EndTime))
	}
	if m.Value != nil {
		n += 1 + sovProtoBaseDef(uint64(*m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BossEnter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Time))
	}
	if m.Id != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Id))
	}
	if m.Count != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MinigameLevelReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exp != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Exp))
	}
	if m.Gold != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Gold))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MinigameScoreReward_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemId != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.ItemId))
	}
	if m.MinNum != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.MinNum))
	}
	if m.MaxNum != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.MaxNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MinigameScoreReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisplayPercent != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.DisplayPercent))
	}
	if m.Reward != nil {
		l = m.Reward.Size()
		n += 1 + l + sovProtoBaseDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MinigameRankInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Diff != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Diff))
	}
	if m.Display != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Display))
	}
	if m.Defeat != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Defeat))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommonGoodPrice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemId != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.ItemId))
	}
	if m.Num != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Num))
	}
	if m.CostType != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.CostType))
	}
	if m.Price != nil {
		n += 1 + sozProtoBaseDef(uint64(*m.Price))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovProtoBaseDef(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProtoBaseDef(x uint64) (n int) {
	return sovProtoBaseDef(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LuaRgba) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_rgba: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_rgba: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.R = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field G", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.G = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.B = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.A = &v2
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaSize) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_size: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_size: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Width = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Height = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaArenaRect) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_arena_rect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_arena_rect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Low = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hig", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Hig = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenDupConfig) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: open_dup_config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: open_dup_config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ChapID = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DupID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DupID = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaEventArgList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_event_arg_list: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_event_arg_list: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percent", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Percent = &v
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShopRandomSection) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: shop_random_section: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: shop_random_section: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MinId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MaxId = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShopRandomSectionList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: shop_random_section_list: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: shop_random_section_list: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SectionList = append(m.SectionList, &ShopRandomSection{})
			if err := m.SectionList[len(m.SectionList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BathInteractTool) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: bath_interact_tool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: bath_interact_tool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Num = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignDayReward) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sign_day_reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sign_day_reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemCount = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipDouble", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.VipDouble = &v
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaPackageItemWeight) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_package_item_weight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_package_item_weight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.RewardId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Weight = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Count = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clean", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Clean = &v
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionopenRiskInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: functionopen_risk_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: functionopen_risk_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chapid", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Chapid = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dupid", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Dupid = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipLastingDecline) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: equip_lasting_decline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: equip_lasting_decline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalValue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.TotalValue = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SelectNum = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeclineNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DeclineNum = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeclineMin", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DeclineMin = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeclineMax", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DeclineMax = &v
			hasFields[0] |= uint64(0x00000010)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipResolveItem) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: equip_resolve_item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: equip_resolve_item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MinNum = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MaxNum = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Rate = &v
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChapterRisk) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: chapter_risk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: chapter_risk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapterId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ChapterId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.RiskId = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipEnduranceCost) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: equip_endurance_cost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: equip_endurance_cost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCost", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MinCost = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCost", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MaxCost = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShakeConfig) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: shake_config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: shake_config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Time = &v2
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShakeId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ShakeId = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NiudanButtonInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: niudan_button_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: niudan_button_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cost = append(m.Cost, &ItemConfig{})
			if err := m.Cost[len(m.Cost)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustOutputList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MustOutputList = append(m.MustOutputList, &ItemConfig{})
			if err := m.MustOutputList[len(m.MustOutputList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cd", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Cd = &v
			hasFields[0] |= uint64(0x00000001)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstOutputList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstOutputList = append(m.FirstOutputList, &ItemConfig{})
			if err := m.FirstOutputList[len(m.FirstOutputList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeGoldItem) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: exchange_gold_item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: exchange_gold_item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Gold = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RandomSection) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: random_section: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: random_section: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MinNum = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MaxNum = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtraPerSection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: extra_per_section: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: extra_per_section: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerSection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PerSection = append(m.PerSection, &RandomSection{})
			if err := m.PerSection[len(m.PerSection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeRange) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: time_range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: time_range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.StartTime = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EndTime = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BathOnceStimina) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: bath_once_stimina: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: bath_once_stimina: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BeginTime = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EndTime = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &v
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BossEnter) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: boss_enter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: boss_enter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Time = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Count = &v
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MinigameLevelReward) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: minigame_level_reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: minigame_level_reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Exp = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Gold = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MinigameScoreReward_) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: minigame_score_reward_: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: minigame_score_reward_: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MinNum = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MaxNum = &v
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MinigameScoreReward) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: minigame_score_reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: minigame_score_reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayPercent", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DisplayPercent = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reward == nil {
				m.Reward = &MinigameScoreReward_{}
			}
			if err := m.Reward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MinigameRankInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: minigame_rank_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: minigame_rank_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diff", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Diff = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Display = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defeat", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Defeat = &v
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonGoodPrice) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: common_good_price: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: common_good_price: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Num = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CostType = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Price = &v
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoBaseDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoBaseDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProtoBaseDef(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtoBaseDef
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtoBaseDef
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProtoBaseDef
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthProtoBaseDef
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProtoBaseDef
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProtoBaseDef(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthProtoBaseDef
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProtoBaseDef = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtoBaseDef   = fmt.Errorf("proto: integer overflow")
)
