// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ProtoDef.proto

package pbd

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// 通用存储
type UniversalData struct {
	Key                  *int64           `protobuf:"varint,1,req,name=key" json:"key,omitempty"`
	Type                 []byte           `protobuf:"bytes,2,req,name=type" json:"type,omitempty"`
	Name                 []byte           `protobuf:"bytes,3,req,name=name" json:"name,omitempty"`
	B                    []bool           `protobuf:"varint,4,rep,name=b" json:"b,omitempty"`
	F                    []float32        `protobuf:"fixed32,5,rep,name=f" json:"f,omitempty"`
	D                    []float64        `protobuf:"fixed64,6,rep,name=d" json:"d,omitempty"`
	E                    []int32          `protobuf:"zigzag32,7,rep,name=e" json:"e,omitempty"`
	I32                  []int32          `protobuf:"zigzag32,8,rep,name=i32" json:"i32,omitempty"`
	I64                  []int64          `protobuf:"zigzag64,9,rep,name=i64" json:"i64,omitempty"`
	U32                  []uint32         `protobuf:"varint,10,rep,name=u32" json:"u32,omitempty"`
	U64                  []uint64         `protobuf:"varint,11,rep,name=u64" json:"u64,omitempty"`
	Str                  [][]byte         `protobuf:"bytes,12,rep,name=str" json:"str,omitempty"`
	Sub                  []*UniversalData `protobuf:"bytes,13,rep,name=sub" json:"sub,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *UniversalData) Reset()         { *m = UniversalData{} }
func (m *UniversalData) String() string { return proto.CompactTextString(m) }
func (*UniversalData) ProtoMessage()    {}
func (*UniversalData) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{0}
}
func (m *UniversalData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UniversalData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UniversalData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UniversalData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UniversalData.Merge(m, src)
}
func (m *UniversalData) XXX_Size() int {
	return m.Size()
}
func (m *UniversalData) XXX_DiscardUnknown() {
	xxx_messageInfo_UniversalData.DiscardUnknown(m)
}

var xxx_messageInfo_UniversalData proto.InternalMessageInfo

func (m *UniversalData) GetKey() int64 {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return 0
}

func (m *UniversalData) GetType() []byte {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *UniversalData) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *UniversalData) GetB() []bool {
	if m != nil {
		return m.B
	}
	return nil
}

func (m *UniversalData) GetF() []float32 {
	if m != nil {
		return m.F
	}
	return nil
}

func (m *UniversalData) GetD() []float64 {
	if m != nil {
		return m.D
	}
	return nil
}

func (m *UniversalData) GetE() []int32 {
	if m != nil {
		return m.E
	}
	return nil
}

func (m *UniversalData) GetI32() []int32 {
	if m != nil {
		return m.I32
	}
	return nil
}

func (m *UniversalData) GetI64() []int64 {
	if m != nil {
		return m.I64
	}
	return nil
}

func (m *UniversalData) GetU32() []uint32 {
	if m != nil {
		return m.U32
	}
	return nil
}

func (m *UniversalData) GetU64() []uint64 {
	if m != nil {
		return m.U64
	}
	return nil
}

func (m *UniversalData) GetStr() [][]byte {
	if m != nil {
		return m.Str
	}
	return nil
}

func (m *UniversalData) GetSub() []*UniversalData {
	if m != nil {
		return m.Sub
	}
	return nil
}

// 坐标
type LuaPos struct {
	PosX                 *int32   `protobuf:"zigzag32,1,req,name=pos_x" json:"pos_x,omitempty"`
	PosY                 *int32   `protobuf:"zigzag32,2,req,name=pos_y" json:"pos_y,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaPos) Reset()         { *m = LuaPos{} }
func (m *LuaPos) String() string { return proto.CompactTextString(m) }
func (*LuaPos) ProtoMessage()    {}
func (*LuaPos) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{1}
}
func (m *LuaPos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaPos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaPos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaPos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaPos.Merge(m, src)
}
func (m *LuaPos) XXX_Size() int {
	return m.Size()
}
func (m *LuaPos) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaPos.DiscardUnknown(m)
}

var xxx_messageInfo_LuaPos proto.InternalMessageInfo

func (m *LuaPos) GetPosX() int32 {
	if m != nil && m.PosX != nil {
		return *m.PosX
	}
	return 0
}

func (m *LuaPos) GetPosY() int32 {
	if m != nil && m.PosY != nil {
		return *m.PosY
	}
	return 0
}

// 背包道具
type DbBagItem struct {
	ItemIndex            *int64   `protobuf:"zigzag64,1,req,name=item_index" json:"item_index,omitempty"`
	ItemId               *int32   `protobuf:"zigzag32,2,req,name=item_id" json:"item_id,omitempty"`
	ItemCount            *int64   `protobuf:"zigzag64,3,req,name=item_count" json:"item_count,omitempty"`
	IsTouched            *bool    `protobuf:"varint,4,req,name=is_touched" json:"is_touched,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DbBagItem) Reset()         { *m = DbBagItem{} }
func (m *DbBagItem) String() string { return proto.CompactTextString(m) }
func (*DbBagItem) ProtoMessage()    {}
func (*DbBagItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{2}
}
func (m *DbBagItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DbBagItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DbBagItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DbBagItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DbBagItem.Merge(m, src)
}
func (m *DbBagItem) XXX_Size() int {
	return m.Size()
}
func (m *DbBagItem) XXX_DiscardUnknown() {
	xxx_messageInfo_DbBagItem.DiscardUnknown(m)
}

var xxx_messageInfo_DbBagItem proto.InternalMessageInfo

func (m *DbBagItem) GetItemIndex() int64 {
	if m != nil && m.ItemIndex != nil {
		return *m.ItemIndex
	}
	return 0
}

func (m *DbBagItem) GetItemId() int32 {
	if m != nil && m.ItemId != nil {
		return *m.ItemId
	}
	return 0
}

func (m *DbBagItem) GetItemCount() int64 {
	if m != nil && m.ItemCount != nil {
		return *m.ItemCount
	}
	return 0
}

func (m *DbBagItem) GetIsTouched() bool {
	if m != nil && m.IsTouched != nil {
		return *m.IsTouched
	}
	return false
}

type ListDbBagItems struct {
	BagItem              []*DbBagItem `protobuf:"bytes,1,rep,name=bag_item" json:"bag_item,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ListDbBagItems) Reset()         { *m = ListDbBagItems{} }
func (m *ListDbBagItems) String() string { return proto.CompactTextString(m) }
func (*ListDbBagItems) ProtoMessage()    {}
func (*ListDbBagItems) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{3}
}
func (m *ListDbBagItems) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDbBagItems) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDbBagItems.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDbBagItems) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDbBagItems.Merge(m, src)
}
func (m *ListDbBagItems) XXX_Size() int {
	return m.Size()
}
func (m *ListDbBagItems) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDbBagItems.DiscardUnknown(m)
}

var xxx_messageInfo_ListDbBagItems proto.InternalMessageInfo

func (m *ListDbBagItems) GetBagItem() []*DbBagItem {
	if m != nil {
		return m.BagItem
	}
	return nil
}

// 背包装备
type DbBagEquip struct {
	EquipIndex           *int64             `protobuf:"zigzag64,1,req,name=equip_index" json:"equip_index,omitempty"`
	EquipId              *int32             `protobuf:"zigzag32,2,req,name=equip_id" json:"equip_id,omitempty"`
	Level                *int32             `protobuf:"zigzag32,3,req,name=level" json:"level,omitempty"`
	Attack               *int32             `protobuf:"zigzag32,4,req,name=attack" json:"attack,omitempty"`
	Endurance            *int32             `protobuf:"zigzag32,5,req,name=endurance" json:"endurance,omitempty"`
	Quality              *int32             `protobuf:"zigzag32,6,req,name=quality" json:"quality,omitempty"`
	SiteType             *E_EQUIP_SITE_TYPE `protobuf:"varint,7,req,name=site_type,enum=pbd.E_EQUIP_SITE_TYPE" json:"site_type,omitempty"`
	IsTouched            *bool              `protobuf:"varint,8,req,name=is_touched" json:"is_touched,omitempty"`
	ExtraPer             *EquipExtraPer     `protobuf:"bytes,9,opt,name=extra_per" json:"extra_per,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *DbBagEquip) Reset()         { *m = DbBagEquip{} }
func (m *DbBagEquip) String() string { return proto.CompactTextString(m) }
func (*DbBagEquip) ProtoMessage()    {}
func (*DbBagEquip) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{4}
}
func (m *DbBagEquip) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DbBagEquip) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DbBagEquip.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DbBagEquip) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DbBagEquip.Merge(m, src)
}
func (m *DbBagEquip) XXX_Size() int {
	return m.Size()
}
func (m *DbBagEquip) XXX_DiscardUnknown() {
	xxx_messageInfo_DbBagEquip.DiscardUnknown(m)
}

var xxx_messageInfo_DbBagEquip proto.InternalMessageInfo

func (m *DbBagEquip) GetEquipIndex() int64 {
	if m != nil && m.EquipIndex != nil {
		return *m.EquipIndex
	}
	return 0
}

func (m *DbBagEquip) GetEquipId() int32 {
	if m != nil && m.EquipId != nil {
		return *m.EquipId
	}
	return 0
}

func (m *DbBagEquip) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *DbBagEquip) GetAttack() int32 {
	if m != nil && m.Attack != nil {
		return *m.Attack
	}
	return 0
}

func (m *DbBagEquip) GetEndurance() int32 {
	if m != nil && m.Endurance != nil {
		return *m.Endurance
	}
	return 0
}

func (m *DbBagEquip) GetQuality() int32 {
	if m != nil && m.Quality != nil {
		return *m.Quality
	}
	return 0
}

func (m *DbBagEquip) GetSiteType() E_EQUIP_SITE_TYPE {
	if m != nil && m.SiteType != nil {
		return *m.SiteType
	}
	return E_EQUIP_SITE_TYPE_EEST_HELMET
}

func (m *DbBagEquip) GetIsTouched() bool {
	if m != nil && m.IsTouched != nil {
		return *m.IsTouched
	}
	return false
}

func (m *DbBagEquip) GetExtraPer() *EquipExtraPer {
	if m != nil {
		return m.ExtraPer
	}
	return nil
}

// 角色装备
type DbRoleEquip struct {
	EquipIndex           *int64             `protobuf:"zigzag64,1,req,name=equip_index" json:"equip_index,omitempty"`
	EquipId              *int32             `protobuf:"zigzag32,2,req,name=equip_id" json:"equip_id,omitempty"`
	Level                *int32             `protobuf:"zigzag32,3,req,name=level" json:"level,omitempty"`
	Attack               *int32             `protobuf:"zigzag32,4,req,name=attack" json:"attack,omitempty"`
	Endurance            *int32             `protobuf:"zigzag32,5,req,name=endurance" json:"endurance,omitempty"`
	Quality              *int32             `protobuf:"zigzag32,6,req,name=quality" json:"quality,omitempty"`
	SiteType             *E_EQUIP_SITE_TYPE `protobuf:"varint,7,req,name=site_type,enum=pbd.E_EQUIP_SITE_TYPE" json:"site_type,omitempty"`
	ExtraPer             *EquipExtraPer     `protobuf:"bytes,8,opt,name=extra_per" json:"extra_per,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *DbRoleEquip) Reset()         { *m = DbRoleEquip{} }
func (m *DbRoleEquip) String() string { return proto.CompactTextString(m) }
func (*DbRoleEquip) ProtoMessage()    {}
func (*DbRoleEquip) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{5}
}
func (m *DbRoleEquip) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DbRoleEquip) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DbRoleEquip.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DbRoleEquip) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DbRoleEquip.Merge(m, src)
}
func (m *DbRoleEquip) XXX_Size() int {
	return m.Size()
}
func (m *DbRoleEquip) XXX_DiscardUnknown() {
	xxx_messageInfo_DbRoleEquip.DiscardUnknown(m)
}

var xxx_messageInfo_DbRoleEquip proto.InternalMessageInfo

func (m *DbRoleEquip) GetEquipIndex() int64 {
	if m != nil && m.EquipIndex != nil {
		return *m.EquipIndex
	}
	return 0
}

func (m *DbRoleEquip) GetEquipId() int32 {
	if m != nil && m.EquipId != nil {
		return *m.EquipId
	}
	return 0
}

func (m *DbRoleEquip) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *DbRoleEquip) GetAttack() int32 {
	if m != nil && m.Attack != nil {
		return *m.Attack
	}
	return 0
}

func (m *DbRoleEquip) GetEndurance() int32 {
	if m != nil && m.Endurance != nil {
		return *m.Endurance
	}
	return 0
}

func (m *DbRoleEquip) GetQuality() int32 {
	if m != nil && m.Quality != nil {
		return *m.Quality
	}
	return 0
}

func (m *DbRoleEquip) GetSiteType() E_EQUIP_SITE_TYPE {
	if m != nil && m.SiteType != nil {
		return *m.SiteType
	}
	return E_EQUIP_SITE_TYPE_EEST_HELMET
}

func (m *DbRoleEquip) GetExtraPer() *EquipExtraPer {
	if m != nil {
		return m.ExtraPer
	}
	return nil
}

// 额外增益百分比
type EquipExtraPer struct {
	FightPer             *int32   `protobuf:"zigzag32,1,req,name=fight_per" json:"fight_per,omitempty"`
	DefPer               *int32   `protobuf:"zigzag32,2,req,name=def_per" json:"def_per,omitempty"`
	CritPer              *int32   `protobuf:"zigzag32,3,req,name=crit_per" json:"crit_per,omitempty"`
	BlockPer             *int32   `protobuf:"zigzag32,4,req,name=block_per" json:"block_per,omitempty"`
	SpeedPer             *int32   `protobuf:"zigzag32,5,req,name=speed_per" json:"speed_per,omitempty"`
	HpPer                *int32   `protobuf:"zigzag32,6,req,name=hp_per" json:"hp_per,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EquipExtraPer) Reset()         { *m = EquipExtraPer{} }
func (m *EquipExtraPer) String() string { return proto.CompactTextString(m) }
func (*EquipExtraPer) ProtoMessage()    {}
func (*EquipExtraPer) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{6}
}
func (m *EquipExtraPer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EquipExtraPer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EquipExtraPer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EquipExtraPer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EquipExtraPer.Merge(m, src)
}
func (m *EquipExtraPer) XXX_Size() int {
	return m.Size()
}
func (m *EquipExtraPer) XXX_DiscardUnknown() {
	xxx_messageInfo_EquipExtraPer.DiscardUnknown(m)
}

var xxx_messageInfo_EquipExtraPer proto.InternalMessageInfo

func (m *EquipExtraPer) GetFightPer() int32 {
	if m != nil && m.FightPer != nil {
		return *m.FightPer
	}
	return 0
}

func (m *EquipExtraPer) GetDefPer() int32 {
	if m != nil && m.DefPer != nil {
		return *m.DefPer
	}
	return 0
}

func (m *EquipExtraPer) GetCritPer() int32 {
	if m != nil && m.CritPer != nil {
		return *m.CritPer
	}
	return 0
}

func (m *EquipExtraPer) GetBlockPer() int32 {
	if m != nil && m.BlockPer != nil {
		return *m.BlockPer
	}
	return 0
}

func (m *EquipExtraPer) GetSpeedPer() int32 {
	if m != nil && m.SpeedPer != nil {
		return *m.SpeedPer
	}
	return 0
}

func (m *EquipExtraPer) GetHpPer() int32 {
	if m != nil && m.HpPer != nil {
		return *m.HpPer
	}
	return 0
}

// 修复背包装备
type DbFixEquip struct {
	FullEndurance        *int32      `protobuf:"zigzag32,1,req,name=full_endurance" json:"full_endurance,omitempty"`
	FixTime              *int64      `protobuf:"zigzag64,2,req,name=fix_time" json:"fix_time,omitempty"`
	NeedTime             *int32      `protobuf:"zigzag32,3,req,name=need_time" json:"need_time,omitempty"`
	BagEquip             *DbBagEquip `protobuf:"bytes,4,req,name=bag_equip" json:"bag_equip,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DbFixEquip) Reset()         { *m = DbFixEquip{} }
func (m *DbFixEquip) String() string { return proto.CompactTextString(m) }
func (*DbFixEquip) ProtoMessage()    {}
func (*DbFixEquip) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{7}
}
func (m *DbFixEquip) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DbFixEquip) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DbFixEquip.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DbFixEquip) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DbFixEquip.Merge(m, src)
}
func (m *DbFixEquip) XXX_Size() int {
	return m.Size()
}
func (m *DbFixEquip) XXX_DiscardUnknown() {
	xxx_messageInfo_DbFixEquip.DiscardUnknown(m)
}

var xxx_messageInfo_DbFixEquip proto.InternalMessageInfo

func (m *DbFixEquip) GetFullEndurance() int32 {
	if m != nil && m.FullEndurance != nil {
		return *m.FullEndurance
	}
	return 0
}

func (m *DbFixEquip) GetFixTime() int64 {
	if m != nil && m.FixTime != nil {
		return *m.FixTime
	}
	return 0
}

func (m *DbFixEquip) GetNeedTime() int32 {
	if m != nil && m.NeedTime != nil {
		return *m.NeedTime
	}
	return 0
}

func (m *DbFixEquip) GetBagEquip() *DbBagEquip {
	if m != nil {
		return m.BagEquip
	}
	return nil
}

type ListDbFixEquips struct {
	FixInfo              []*DbFixEquip `protobuf:"bytes,1,rep,name=fix_info" json:"fix_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ListDbFixEquips) Reset()         { *m = ListDbFixEquips{} }
func (m *ListDbFixEquips) String() string { return proto.CompactTextString(m) }
func (*ListDbFixEquips) ProtoMessage()    {}
func (*ListDbFixEquips) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{8}
}
func (m *ListDbFixEquips) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDbFixEquips) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDbFixEquips.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDbFixEquips) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDbFixEquips.Merge(m, src)
}
func (m *ListDbFixEquips) XXX_Size() int {
	return m.Size()
}
func (m *ListDbFixEquips) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDbFixEquips.DiscardUnknown(m)
}

var xxx_messageInfo_ListDbFixEquips proto.InternalMessageInfo

func (m *ListDbFixEquips) GetFixInfo() []*DbFixEquip {
	if m != nil {
		return m.FixInfo
	}
	return nil
}

type ListDbBagEquips struct {
	BagEquip             []*DbBagEquip `protobuf:"bytes,1,rep,name=bag_equip" json:"bag_equip,omitempty"`
	LastRewardId         *int32        `protobuf:"zigzag32,2,opt,name=last_reward_id" json:"last_reward_id,omitempty"`
	EquipIdList          []int32       `protobuf:"zigzag32,3,rep,name=equip_id_list" json:"equip_id_list,omitempty"`
	BagCurrSize          *int32        `protobuf:"zigzag32,4,opt,name=bag_curr_size" json:"bag_curr_size,omitempty"`
	BagExtendCount       *int32        `protobuf:"zigzag32,5,opt,name=bag_extend_count" json:"bag_extend_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ListDbBagEquips) Reset()         { *m = ListDbBagEquips{} }
func (m *ListDbBagEquips) String() string { return proto.CompactTextString(m) }
func (*ListDbBagEquips) ProtoMessage()    {}
func (*ListDbBagEquips) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{9}
}
func (m *ListDbBagEquips) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDbBagEquips) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDbBagEquips.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDbBagEquips) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDbBagEquips.Merge(m, src)
}
func (m *ListDbBagEquips) XXX_Size() int {
	return m.Size()
}
func (m *ListDbBagEquips) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDbBagEquips.DiscardUnknown(m)
}

var xxx_messageInfo_ListDbBagEquips proto.InternalMessageInfo

func (m *ListDbBagEquips) GetBagEquip() []*DbBagEquip {
	if m != nil {
		return m.BagEquip
	}
	return nil
}

func (m *ListDbBagEquips) GetLastRewardId() int32 {
	if m != nil && m.LastRewardId != nil {
		return *m.LastRewardId
	}
	return 0
}

func (m *ListDbBagEquips) GetEquipIdList() []int32 {
	if m != nil {
		return m.EquipIdList
	}
	return nil
}

func (m *ListDbBagEquips) GetBagCurrSize() int32 {
	if m != nil && m.BagCurrSize != nil {
		return *m.BagCurrSize
	}
	return 0
}

func (m *ListDbBagEquips) GetBagExtendCount() int32 {
	if m != nil && m.BagExtendCount != nil {
		return *m.BagExtendCount
	}
	return 0
}

type ListDbRoleEquips struct {
	RoleEquip            []*DbRoleEquip `protobuf:"bytes,1,rep,name=role_equip" json:"role_equip,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ListDbRoleEquips) Reset()         { *m = ListDbRoleEquips{} }
func (m *ListDbRoleEquips) String() string { return proto.CompactTextString(m) }
func (*ListDbRoleEquips) ProtoMessage()    {}
func (*ListDbRoleEquips) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{10}
}
func (m *ListDbRoleEquips) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDbRoleEquips) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDbRoleEquips.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDbRoleEquips) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDbRoleEquips.Merge(m, src)
}
func (m *ListDbRoleEquips) XXX_Size() int {
	return m.Size()
}
func (m *ListDbRoleEquips) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDbRoleEquips.DiscardUnknown(m)
}

var xxx_messageInfo_ListDbRoleEquips proto.InternalMessageInfo

func (m *ListDbRoleEquips) GetRoleEquip() []*DbRoleEquip {
	if m != nil {
		return m.RoleEquip
	}
	return nil
}

// 奖励信息
type RewardInfo struct {
	Id                   *int32   `protobuf:"zigzag32,1,req,name=id" json:"id,omitempty"`
	Count                *int32   `protobuf:"zigzag32,2,req,name=count" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RewardInfo) Reset()         { *m = RewardInfo{} }
func (m *RewardInfo) String() string { return proto.CompactTextString(m) }
func (*RewardInfo) ProtoMessage()    {}
func (*RewardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{11}
}
func (m *RewardInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardInfo.Merge(m, src)
}
func (m *RewardInfo) XXX_Size() int {
	return m.Size()
}
func (m *RewardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RewardInfo proto.InternalMessageInfo

func (m *RewardInfo) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *RewardInfo) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

// 好友信息
type DbFriendInfo struct {
	RoleIndex            *int64            `protobuf:"zigzag64,1,req,name=role_index" json:"role_index,omitempty"`
	State                []byte            `protobuf:"bytes,2,req,name=state" json:"state,omitempty"`
	Time                 *int64            `protobuf:"zigzag64,3,req,name=time" json:"time,omitempty"`
	LoginTime            *int64            `protobuf:"zigzag64,4,req,name=login_time" json:"login_time,omitempty"`
	CardInfo             *VisitingCardInfo `protobuf:"bytes,5,req,name=card_info" json:"card_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *DbFriendInfo) Reset()         { *m = DbFriendInfo{} }
func (m *DbFriendInfo) String() string { return proto.CompactTextString(m) }
func (*DbFriendInfo) ProtoMessage()    {}
func (*DbFriendInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{12}
}
func (m *DbFriendInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DbFriendInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DbFriendInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DbFriendInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DbFriendInfo.Merge(m, src)
}
func (m *DbFriendInfo) XXX_Size() int {
	return m.Size()
}
func (m *DbFriendInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DbFriendInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DbFriendInfo proto.InternalMessageInfo

func (m *DbFriendInfo) GetRoleIndex() int64 {
	if m != nil && m.RoleIndex != nil {
		return *m.RoleIndex
	}
	return 0
}

func (m *DbFriendInfo) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *DbFriendInfo) GetTime() int64 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *DbFriendInfo) GetLoginTime() int64 {
	if m != nil && m.LoginTime != nil {
		return *m.LoginTime
	}
	return 0
}

func (m *DbFriendInfo) GetCardInfo() *VisitingCardInfo {
	if m != nil {
		return m.CardInfo
	}
	return nil
}

// 竞技场杀人榜信息
type DbArenaKillInfo struct {
	RoleIndex            *int64          `protobuf:"zigzag64,1,req,name=role_index" json:"role_index,omitempty"`
	KillDate             *int32          `protobuf:"zigzag32,2,req,name=kill_date" json:"kill_date,omitempty"`
	ShowInfo             *PlayerShowInfo `protobuf:"bytes,3,req,name=show_info" json:"show_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *DbArenaKillInfo) Reset()         { *m = DbArenaKillInfo{} }
func (m *DbArenaKillInfo) String() string { return proto.CompactTextString(m) }
func (*DbArenaKillInfo) ProtoMessage()    {}
func (*DbArenaKillInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{13}
}
func (m *DbArenaKillInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DbArenaKillInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DbArenaKillInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DbArenaKillInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DbArenaKillInfo.Merge(m, src)
}
func (m *DbArenaKillInfo) XXX_Size() int {
	return m.Size()
}
func (m *DbArenaKillInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DbArenaKillInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DbArenaKillInfo proto.InternalMessageInfo

func (m *DbArenaKillInfo) GetRoleIndex() int64 {
	if m != nil && m.RoleIndex != nil {
		return *m.RoleIndex
	}
	return 0
}

func (m *DbArenaKillInfo) GetKillDate() int32 {
	if m != nil && m.KillDate != nil {
		return *m.KillDate
	}
	return 0
}

func (m *DbArenaKillInfo) GetShowInfo() *PlayerShowInfo {
	if m != nil {
		return m.ShowInfo
	}
	return nil
}

type RoleFace struct {
	Type                 *int32   `protobuf:"zigzag32,1,req,name=type" json:"type,omitempty"`
	FaceId               *int32   `protobuf:"zigzag32,2,opt,name=face_id" json:"face_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoleFace) Reset()         { *m = RoleFace{} }
func (m *RoleFace) String() string { return proto.CompactTextString(m) }
func (*RoleFace) ProtoMessage()    {}
func (*RoleFace) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{14}
}
func (m *RoleFace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleFace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleFace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleFace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleFace.Merge(m, src)
}
func (m *RoleFace) XXX_Size() int {
	return m.Size()
}
func (m *RoleFace) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleFace.DiscardUnknown(m)
}

var xxx_messageInfo_RoleFace proto.InternalMessageInfo

func (m *RoleFace) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *RoleFace) GetFaceId() int32 {
	if m != nil && m.FaceId != nil {
		return *m.FaceId
	}
	return 0
}

type MinigameRecord struct {
	HistoryMaxScore      *int32   `protobuf:"zigzag32,1,opt,name=history_max_score" json:"history_max_score,omitempty"`
	TodayMaxScore        *int32   `protobuf:"zigzag32,2,opt,name=today_max_score" json:"today_max_score,omitempty"`
	HistoryTopRank       *int32   `protobuf:"zigzag32,3,opt,name=history_top_rank" json:"history_top_rank,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MinigameRecord) Reset()         { *m = MinigameRecord{} }
func (m *MinigameRecord) String() string { return proto.CompactTextString(m) }
func (*MinigameRecord) ProtoMessage()    {}
func (*MinigameRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{15}
}
func (m *MinigameRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MinigameRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MinigameRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MinigameRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MinigameRecord.Merge(m, src)
}
func (m *MinigameRecord) XXX_Size() int {
	return m.Size()
}
func (m *MinigameRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_MinigameRecord.DiscardUnknown(m)
}

var xxx_messageInfo_MinigameRecord proto.InternalMessageInfo

func (m *MinigameRecord) GetHistoryMaxScore() int32 {
	if m != nil && m.HistoryMaxScore != nil {
		return *m.HistoryMaxScore
	}
	return 0
}

func (m *MinigameRecord) GetTodayMaxScore() int32 {
	if m != nil && m.TodayMaxScore != nil {
		return *m.TodayMaxScore
	}
	return 0
}

func (m *MinigameRecord) GetHistoryTopRank() int32 {
	if m != nil && m.HistoryTopRank != nil {
		return *m.HistoryTopRank
	}
	return 0
}

type MinigamePlayInfo struct {
	PlayRecord           []*MinigameRecord `protobuf:"bytes,1,rep,name=play_record" json:"play_record,omitempty"`
	DayBuyCount          *int32            `protobuf:"zigzag32,2,opt,name=day_buy_count" json:"day_buy_count,omitempty"`
	GetFlag              *int32            `protobuf:"zigzag32,3,opt,name=get_flag" json:"get_flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MinigamePlayInfo) Reset()         { *m = MinigamePlayInfo{} }
func (m *MinigamePlayInfo) String() string { return proto.CompactTextString(m) }
func (*MinigamePlayInfo) ProtoMessage()    {}
func (*MinigamePlayInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{16}
}
func (m *MinigamePlayInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MinigamePlayInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MinigamePlayInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MinigamePlayInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MinigamePlayInfo.Merge(m, src)
}
func (m *MinigamePlayInfo) XXX_Size() int {
	return m.Size()
}
func (m *MinigamePlayInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MinigamePlayInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MinigamePlayInfo proto.InternalMessageInfo

func (m *MinigamePlayInfo) GetPlayRecord() []*MinigameRecord {
	if m != nil {
		return m.PlayRecord
	}
	return nil
}

func (m *MinigamePlayInfo) GetDayBuyCount() int32 {
	if m != nil && m.DayBuyCount != nil {
		return *m.DayBuyCount
	}
	return 0
}

func (m *MinigamePlayInfo) GetGetFlag() int32 {
	if m != nil && m.GetFlag != nil {
		return *m.GetFlag
	}
	return 0
}

// 玩家显示信息
type PlayerShowInfo struct {
	Level                *int32    `protobuf:"zigzag32,1,req,name=level" json:"level,omitempty"`
	VipLvl               *int32    `protobuf:"zigzag32,2,req,name=vip_lvl" json:"vip_lvl,omitempty"`
	Gender               *int32    `protobuf:"zigzag32,3,req,name=gender" json:"gender,omitempty"`
	NickName             []byte    `protobuf:"bytes,4,req,name=nick_name" json:"nick_name,omitempty"`
	HelmetId             *int32    `protobuf:"zigzag32,5,req,name=helmet_id" json:"helmet_id,omitempty"`
	ClothesId            *int32    `protobuf:"zigzag32,6,req,name=clothes_id" json:"clothes_id,omitempty"`
	ShoesId              *int32    `protobuf:"zigzag32,7,req,name=shoes_id" json:"shoes_id,omitempty"`
	WingId               *int32    `protobuf:"zigzag32,8,req,name=wing_id" json:"wing_id,omitempty"`
	WeaponId             *int32    `protobuf:"zigzag32,9,req,name=weapon_id" json:"weapon_id,omitempty"`
	VehicleId            *int32    `protobuf:"zigzag32,10,req,name=vehicle_id" json:"vehicle_id,omitempty"`
	SuitId               *int32    `protobuf:"zigzag32,11,req,name=suit_id" json:"suit_id,omitempty"`
	Face                 *RoleFace `protobuf:"bytes,12,req,name=face" json:"face,omitempty"`
	PlayerId             []byte    `protobuf:"bytes,13,req,name=player_id" json:"player_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *PlayerShowInfo) Reset()         { *m = PlayerShowInfo{} }
func (m *PlayerShowInfo) String() string { return proto.CompactTextString(m) }
func (*PlayerShowInfo) ProtoMessage()    {}
func (*PlayerShowInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{17}
}
func (m *PlayerShowInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerShowInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerShowInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerShowInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerShowInfo.Merge(m, src)
}
func (m *PlayerShowInfo) XXX_Size() int {
	return m.Size()
}
func (m *PlayerShowInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerShowInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerShowInfo proto.InternalMessageInfo

func (m *PlayerShowInfo) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *PlayerShowInfo) GetVipLvl() int32 {
	if m != nil && m.VipLvl != nil {
		return *m.VipLvl
	}
	return 0
}

func (m *PlayerShowInfo) GetGender() int32 {
	if m != nil && m.Gender != nil {
		return *m.Gender
	}
	return 0
}

func (m *PlayerShowInfo) GetNickName() []byte {
	if m != nil {
		return m.NickName
	}
	return nil
}

func (m *PlayerShowInfo) GetHelmetId() int32 {
	if m != nil && m.HelmetId != nil {
		return *m.HelmetId
	}
	return 0
}

func (m *PlayerShowInfo) GetClothesId() int32 {
	if m != nil && m.ClothesId != nil {
		return *m.ClothesId
	}
	return 0
}

func (m *PlayerShowInfo) GetShoesId() int32 {
	if m != nil && m.ShoesId != nil {
		return *m.ShoesId
	}
	return 0
}

func (m *PlayerShowInfo) GetWingId() int32 {
	if m != nil && m.WingId != nil {
		return *m.WingId
	}
	return 0
}

func (m *PlayerShowInfo) GetWeaponId() int32 {
	if m != nil && m.WeaponId != nil {
		return *m.WeaponId
	}
	return 0
}

func (m *PlayerShowInfo) GetVehicleId() int32 {
	if m != nil && m.VehicleId != nil {
		return *m.VehicleId
	}
	return 0
}

func (m *PlayerShowInfo) GetSuitId() int32 {
	if m != nil && m.SuitId != nil {
		return *m.SuitId
	}
	return 0
}

func (m *PlayerShowInfo) GetFace() *RoleFace {
	if m != nil {
		return m.Face
	}
	return nil
}

func (m *PlayerShowInfo) GetPlayerId() []byte {
	if m != nil {
		return m.PlayerId
	}
	return nil
}

//玩家基础数据
type PlayerValueInfo struct {
	Hp                   *int32   `protobuf:"zigzag32,1,req,name=hp" json:"hp,omitempty"`
	Atk                  *int32   `protobuf:"zigzag32,2,req,name=atk" json:"atk,omitempty"`
	Def                  *int32   `protobuf:"zigzag32,3,req,name=def" json:"def,omitempty"`
	Crit                 *int32   `protobuf:"zigzag32,4,req,name=crit" json:"crit,omitempty"`
	Block                *int32   `protobuf:"zigzag32,5,req,name=block" json:"block,omitempty"`
	Speed                *int32   `protobuf:"zigzag32,6,req,name=speed" json:"speed,omitempty"`
	Fight                *int32   `protobuf:"zigzag32,7,opt,name=fight" json:"fight,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayerValueInfo) Reset()         { *m = PlayerValueInfo{} }
func (m *PlayerValueInfo) String() string { return proto.CompactTextString(m) }
func (*PlayerValueInfo) ProtoMessage()    {}
func (*PlayerValueInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{18}
}
func (m *PlayerValueInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerValueInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerValueInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerValueInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerValueInfo.Merge(m, src)
}
func (m *PlayerValueInfo) XXX_Size() int {
	return m.Size()
}
func (m *PlayerValueInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerValueInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerValueInfo proto.InternalMessageInfo

func (m *PlayerValueInfo) GetHp() int32 {
	if m != nil && m.Hp != nil {
		return *m.Hp
	}
	return 0
}

func (m *PlayerValueInfo) GetAtk() int32 {
	if m != nil && m.Atk != nil {
		return *m.Atk
	}
	return 0
}

func (m *PlayerValueInfo) GetDef() int32 {
	if m != nil && m.Def != nil {
		return *m.Def
	}
	return 0
}

func (m *PlayerValueInfo) GetCrit() int32 {
	if m != nil && m.Crit != nil {
		return *m.Crit
	}
	return 0
}

func (m *PlayerValueInfo) GetBlock() int32 {
	if m != nil && m.Block != nil {
		return *m.Block
	}
	return 0
}

func (m *PlayerValueInfo) GetSpeed() int32 {
	if m != nil && m.Speed != nil {
		return *m.Speed
	}
	return 0
}

func (m *PlayerValueInfo) GetFight() int32 {
	if m != nil && m.Fight != nil {
		return *m.Fight
	}
	return 0
}

// 名片
type VisitingCardInfo struct {
	ShowInfo             *PlayerShowInfo  `protobuf:"bytes,1,opt,name=show_info" json:"show_info,omitempty"`
	PlayerInfo           *PlayerValueInfo `protobuf:"bytes,2,opt,name=player_info" json:"player_info,omitempty"`
	RoleIndex            *int64           `protobuf:"zigzag64,3,opt,name=role_index" json:"role_index,omitempty"`
	ExtraPercent         *EquipExtraPer   `protobuf:"bytes,4,opt,name=extra_percent" json:"extra_percent,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *VisitingCardInfo) Reset()         { *m = VisitingCardInfo{} }
func (m *VisitingCardInfo) String() string { return proto.CompactTextString(m) }
func (*VisitingCardInfo) ProtoMessage()    {}
func (*VisitingCardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{19}
}
func (m *VisitingCardInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VisitingCardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VisitingCardInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VisitingCardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VisitingCardInfo.Merge(m, src)
}
func (m *VisitingCardInfo) XXX_Size() int {
	return m.Size()
}
func (m *VisitingCardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VisitingCardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VisitingCardInfo proto.InternalMessageInfo

func (m *VisitingCardInfo) GetShowInfo() *PlayerShowInfo {
	if m != nil {
		return m.ShowInfo
	}
	return nil
}

func (m *VisitingCardInfo) GetPlayerInfo() *PlayerValueInfo {
	if m != nil {
		return m.PlayerInfo
	}
	return nil
}

func (m *VisitingCardInfo) GetRoleIndex() int64 {
	if m != nil && m.RoleIndex != nil {
		return *m.RoleIndex
	}
	return 0
}

func (m *VisitingCardInfo) GetExtraPercent() *EquipExtraPer {
	if m != nil {
		return m.ExtraPercent
	}
	return nil
}

type ArenaPlayerInfo struct {
	Rank                 *int32            `protobuf:"zigzag32,1,req,name=rank" json:"rank,omitempty"`
	PlayerInfo           *VisitingCardInfo `protobuf:"bytes,2,req,name=player_info" json:"player_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ArenaPlayerInfo) Reset()         { *m = ArenaPlayerInfo{} }
func (m *ArenaPlayerInfo) String() string { return proto.CompactTextString(m) }
func (*ArenaPlayerInfo) ProtoMessage()    {}
func (*ArenaPlayerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{20}
}
func (m *ArenaPlayerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArenaPlayerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArenaPlayerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArenaPlayerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArenaPlayerInfo.Merge(m, src)
}
func (m *ArenaPlayerInfo) XXX_Size() int {
	return m.Size()
}
func (m *ArenaPlayerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ArenaPlayerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ArenaPlayerInfo proto.InternalMessageInfo

func (m *ArenaPlayerInfo) GetRank() int32 {
	if m != nil && m.Rank != nil {
		return *m.Rank
	}
	return 0
}

func (m *ArenaPlayerInfo) GetPlayerInfo() *VisitingCardInfo {
	if m != nil {
		return m.PlayerInfo
	}
	return nil
}

// 战斗技能信息
type BattleSkillInfo struct {
	Id                   *int32   `protobuf:"zigzag32,1,req,name=id" json:"id,omitempty"`
	Level                *int32   `protobuf:"zigzag32,2,req,name=level" json:"level,omitempty"`
	Skilled              *int32   `protobuf:"zigzag32,3,req,name=skilled" json:"skilled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BattleSkillInfo) Reset()         { *m = BattleSkillInfo{} }
func (m *BattleSkillInfo) String() string { return proto.CompactTextString(m) }
func (*BattleSkillInfo) ProtoMessage()    {}
func (*BattleSkillInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{21}
}
func (m *BattleSkillInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BattleSkillInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BattleSkillInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BattleSkillInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BattleSkillInfo.Merge(m, src)
}
func (m *BattleSkillInfo) XXX_Size() int {
	return m.Size()
}
func (m *BattleSkillInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BattleSkillInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BattleSkillInfo proto.InternalMessageInfo

func (m *BattleSkillInfo) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *BattleSkillInfo) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *BattleSkillInfo) GetSkilled() int32 {
	if m != nil && m.Skilled != nil {
		return *m.Skilled
	}
	return 0
}

// 玩家战斗数据(与竞技场排行无关, 不应存排行)
type BattlePlayerInfo struct {
	VisitingCard         *VisitingCardInfo  `protobuf:"bytes,1,opt,name=visiting_card" json:"visiting_card,omitempty"`
	SkillList            []*BattleSkillInfo `protobuf:"bytes,2,rep,name=skill_list" json:"skill_list,omitempty"`
	SuitSkill            *BattleSkillInfo   `protobuf:"bytes,3,opt,name=suit_skill" json:"suit_skill,omitempty"`
	CardList             []int32            `protobuf:"zigzag32,4,rep,name=card_list" json:"card_list,omitempty"`
	Position             *int32             `protobuf:"zigzag32,5,opt,name=position" json:"position,omitempty"`
	ActValue             *int32             `protobuf:"zigzag32,6,opt,name=act_value" json:"act_value,omitempty"`
	FightPet             *PetInfo           `protobuf:"bytes,7,opt,name=fight_pet" json:"fight_pet,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *BattlePlayerInfo) Reset()         { *m = BattlePlayerInfo{} }
func (m *BattlePlayerInfo) String() string { return proto.CompactTextString(m) }
func (*BattlePlayerInfo) ProtoMessage()    {}
func (*BattlePlayerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{22}
}
func (m *BattlePlayerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BattlePlayerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BattlePlayerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BattlePlayerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BattlePlayerInfo.Merge(m, src)
}
func (m *BattlePlayerInfo) XXX_Size() int {
	return m.Size()
}
func (m *BattlePlayerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BattlePlayerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BattlePlayerInfo proto.InternalMessageInfo

func (m *BattlePlayerInfo) GetVisitingCard() *VisitingCardInfo {
	if m != nil {
		return m.VisitingCard
	}
	return nil
}

func (m *BattlePlayerInfo) GetSkillList() []*BattleSkillInfo {
	if m != nil {
		return m.SkillList
	}
	return nil
}

func (m *BattlePlayerInfo) GetSuitSkill() *BattleSkillInfo {
	if m != nil {
		return m.SuitSkill
	}
	return nil
}

func (m *BattlePlayerInfo) GetCardList() []int32 {
	if m != nil {
		return m.CardList
	}
	return nil
}

func (m *BattlePlayerInfo) GetPosition() int32 {
	if m != nil && m.Position != nil {
		return *m.Position
	}
	return 0
}

func (m *BattlePlayerInfo) GetActValue() int32 {
	if m != nil && m.ActValue != nil {
		return *m.ActValue
	}
	return 0
}

func (m *BattlePlayerInfo) GetFightPet() *PetInfo {
	if m != nil {
		return m.FightPet
	}
	return nil
}

// 竞技场战斗信息(与排名有关)
type ArenaBattleInfo struct {
	Player               *BattlePlayerInfo `protobuf:"bytes,1,req,name=player" json:"player,omitempty"`
	Rank                 *int32            `protobuf:"zigzag32,2,req,name=rank" json:"rank,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ArenaBattleInfo) Reset()         { *m = ArenaBattleInfo{} }
func (m *ArenaBattleInfo) String() string { return proto.CompactTextString(m) }
func (*ArenaBattleInfo) ProtoMessage()    {}
func (*ArenaBattleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{23}
}
func (m *ArenaBattleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArenaBattleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArenaBattleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArenaBattleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArenaBattleInfo.Merge(m, src)
}
func (m *ArenaBattleInfo) XXX_Size() int {
	return m.Size()
}
func (m *ArenaBattleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ArenaBattleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ArenaBattleInfo proto.InternalMessageInfo

func (m *ArenaBattleInfo) GetPlayer() *BattlePlayerInfo {
	if m != nil {
		return m.Player
	}
	return nil
}

func (m *ArenaBattleInfo) GetRank() int32 {
	if m != nil && m.Rank != nil {
		return *m.Rank
	}
	return 0
}

// 琅琊榜排行榜信息
type RankInfo struct {
	RoleIndex            *int64          `protobuf:"zigzag64,1,req,name=role_index" json:"role_index,omitempty"`
	PlayerInfo           *PlayerShowInfo `protobuf:"bytes,2,req,name=player_info" json:"player_info,omitempty"`
	Rank                 *int32          `protobuf:"zigzag32,3,req,name=rank" json:"rank,omitempty"`
	Score                *int64          `protobuf:"zigzag64,4,req,name=score" json:"score,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RankInfo) Reset()         { *m = RankInfo{} }
func (m *RankInfo) String() string { return proto.CompactTextString(m) }
func (*RankInfo) ProtoMessage()    {}
func (*RankInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{24}
}
func (m *RankInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankInfo.Merge(m, src)
}
func (m *RankInfo) XXX_Size() int {
	return m.Size()
}
func (m *RankInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RankInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RankInfo proto.InternalMessageInfo

func (m *RankInfo) GetRoleIndex() int64 {
	if m != nil && m.RoleIndex != nil {
		return *m.RoleIndex
	}
	return 0
}

func (m *RankInfo) GetPlayerInfo() *PlayerShowInfo {
	if m != nil {
		return m.PlayerInfo
	}
	return nil
}

func (m *RankInfo) GetRank() int32 {
	if m != nil && m.Rank != nil {
		return *m.Rank
	}
	return 0
}

func (m *RankInfo) GetScore() int64 {
	if m != nil && m.Score != nil {
		return *m.Score
	}
	return 0
}

// 战斗中使用的技能次数
type SkillUseInfo struct {
	SkillId              *int32   `protobuf:"zigzag32,1,req,name=skill_id" json:"skill_id,omitempty"`
	SkillCount           *int32   `protobuf:"zigzag32,2,req,name=skill_count" json:"skill_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SkillUseInfo) Reset()         { *m = SkillUseInfo{} }
func (m *SkillUseInfo) String() string { return proto.CompactTextString(m) }
func (*SkillUseInfo) ProtoMessage()    {}
func (*SkillUseInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{25}
}
func (m *SkillUseInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SkillUseInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SkillUseInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SkillUseInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SkillUseInfo.Merge(m, src)
}
func (m *SkillUseInfo) XXX_Size() int {
	return m.Size()
}
func (m *SkillUseInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SkillUseInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SkillUseInfo proto.InternalMessageInfo

func (m *SkillUseInfo) GetSkillId() int32 {
	if m != nil && m.SkillId != nil {
		return *m.SkillId
	}
	return 0
}

func (m *SkillUseInfo) GetSkillCount() int32 {
	if m != nil && m.SkillCount != nil {
		return *m.SkillCount
	}
	return 0
}

// 日常任务信息
type DbDailyTaskInfo struct {
	Type                 *int32   `protobuf:"zigzag32,1,req,name=type" json:"type,omitempty"`
	Id                   *int32   `protobuf:"zigzag32,2,req,name=id" json:"id,omitempty"`
	Count                *int32   `protobuf:"zigzag32,3,req,name=count" json:"count,omitempty"`
	TotCount             *int32   `protobuf:"zigzag32,4,req,name=tot_count" json:"tot_count,omitempty"`
	GetFlag              *bool    `protobuf:"varint,5,req,name=get_flag" json:"get_flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DbDailyTaskInfo) Reset()         { *m = DbDailyTaskInfo{} }
func (m *DbDailyTaskInfo) String() string { return proto.CompactTextString(m) }
func (*DbDailyTaskInfo) ProtoMessage()    {}
func (*DbDailyTaskInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{26}
}
func (m *DbDailyTaskInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DbDailyTaskInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DbDailyTaskInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DbDailyTaskInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DbDailyTaskInfo.Merge(m, src)
}
func (m *DbDailyTaskInfo) XXX_Size() int {
	return m.Size()
}
func (m *DbDailyTaskInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DbDailyTaskInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DbDailyTaskInfo proto.InternalMessageInfo

func (m *DbDailyTaskInfo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *DbDailyTaskInfo) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *DbDailyTaskInfo) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *DbDailyTaskInfo) GetTotCount() int32 {
	if m != nil && m.TotCount != nil {
		return *m.TotCount
	}
	return 0
}

func (m *DbDailyTaskInfo) GetGetFlag() bool {
	if m != nil && m.GetFlag != nil {
		return *m.GetFlag
	}
	return false
}

// 日常活跃度信息
type DbDailyActivityPerLevelInfo struct {
	Level                *int32   `protobuf:"varint,1,req,name=level" json:"level,omitempty"`
	GetFlag              *bool    `protobuf:"varint,2,req,name=get_flag" json:"get_flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DbDailyActivityPerLevelInfo) Reset()         { *m = DbDailyActivityPerLevelInfo{} }
func (m *DbDailyActivityPerLevelInfo) String() string { return proto.CompactTextString(m) }
func (*DbDailyActivityPerLevelInfo) ProtoMessage()    {}
func (*DbDailyActivityPerLevelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{27}
}
func (m *DbDailyActivityPerLevelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DbDailyActivityPerLevelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DbDailyActivityPerLevelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DbDailyActivityPerLevelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DbDailyActivityPerLevelInfo.Merge(m, src)
}
func (m *DbDailyActivityPerLevelInfo) XXX_Size() int {
	return m.Size()
}
func (m *DbDailyActivityPerLevelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DbDailyActivityPerLevelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DbDailyActivityPerLevelInfo proto.InternalMessageInfo

func (m *DbDailyActivityPerLevelInfo) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *DbDailyActivityPerLevelInfo) GetGetFlag() bool {
	if m != nil && m.GetFlag != nil {
		return *m.GetFlag
	}
	return false
}

// 日常活跃度信息
type DbDailyActivityInfo struct {
	TotalAvtivityValue   *int32                         `protobuf:"zigzag32,1,req,name=total_avtivity_value" json:"total_avtivity_value,omitempty"`
	LevelInfo            []*DbDailyActivityPerLevelInfo `protobuf:"bytes,2,rep,name=level_info" json:"level_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *DbDailyActivityInfo) Reset()         { *m = DbDailyActivityInfo{} }
func (m *DbDailyActivityInfo) String() string { return proto.CompactTextString(m) }
func (*DbDailyActivityInfo) ProtoMessage()    {}
func (*DbDailyActivityInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{28}
}
func (m *DbDailyActivityInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DbDailyActivityInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DbDailyActivityInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DbDailyActivityInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DbDailyActivityInfo.Merge(m, src)
}
func (m *DbDailyActivityInfo) XXX_Size() int {
	return m.Size()
}
func (m *DbDailyActivityInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DbDailyActivityInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DbDailyActivityInfo proto.InternalMessageInfo

func (m *DbDailyActivityInfo) GetTotalAvtivityValue() int32 {
	if m != nil && m.TotalAvtivityValue != nil {
		return *m.TotalAvtivityValue
	}
	return 0
}

func (m *DbDailyActivityInfo) GetLevelInfo() []*DbDailyActivityPerLevelInfo {
	if m != nil {
		return m.LevelInfo
	}
	return nil
}

// 区域范围
type LuaRect struct {
	X                    *int32   `protobuf:"zigzag32,1,req,name=x" json:"x,omitempty"`
	Y                    *int32   `protobuf:"zigzag32,2,req,name=y" json:"y,omitempty"`
	W                    *int32   `protobuf:"zigzag32,3,req,name=w" json:"w,omitempty"`
	H                    *int32   `protobuf:"zigzag32,4,req,name=h" json:"h,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaRect) Reset()         { *m = LuaRect{} }
func (m *LuaRect) String() string { return proto.CompactTextString(m) }
func (*LuaRect) ProtoMessage()    {}
func (*LuaRect) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{29}
}
func (m *LuaRect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaRect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaRect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaRect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaRect.Merge(m, src)
}
func (m *LuaRect) XXX_Size() int {
	return m.Size()
}
func (m *LuaRect) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaRect.DiscardUnknown(m)
}

var xxx_messageInfo_LuaRect proto.InternalMessageInfo

func (m *LuaRect) GetX() int32 {
	if m != nil && m.X != nil {
		return *m.X
	}
	return 0
}

func (m *LuaRect) GetY() int32 {
	if m != nil && m.Y != nil {
		return *m.Y
	}
	return 0
}

func (m *LuaRect) GetW() int32 {
	if m != nil && m.W != nil {
		return *m.W
	}
	return 0
}

func (m *LuaRect) GetH() int32 {
	if m != nil && m.H != nil {
		return *m.H
	}
	return 0
}

// 坐标范围
type LuaPosRect struct {
	StartX               *int32   `protobuf:"zigzag32,1,req,name=start_x" json:"start_x,omitempty"`
	StartY               *int32   `protobuf:"zigzag32,2,req,name=start_y" json:"start_y,omitempty"`
	EndX                 *int32   `protobuf:"zigzag32,3,req,name=end_x" json:"end_x,omitempty"`
	EndY                 *int32   `protobuf:"zigzag32,4,req,name=end_y" json:"end_y,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LuaPosRect) Reset()         { *m = LuaPosRect{} }
func (m *LuaPosRect) String() string { return proto.CompactTextString(m) }
func (*LuaPosRect) ProtoMessage()    {}
func (*LuaPosRect) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{30}
}
func (m *LuaPosRect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LuaPosRect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LuaPosRect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LuaPosRect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LuaPosRect.Merge(m, src)
}
func (m *LuaPosRect) XXX_Size() int {
	return m.Size()
}
func (m *LuaPosRect) XXX_DiscardUnknown() {
	xxx_messageInfo_LuaPosRect.DiscardUnknown(m)
}

var xxx_messageInfo_LuaPosRect proto.InternalMessageInfo

func (m *LuaPosRect) GetStartX() int32 {
	if m != nil && m.StartX != nil {
		return *m.StartX
	}
	return 0
}

func (m *LuaPosRect) GetStartY() int32 {
	if m != nil && m.StartY != nil {
		return *m.StartY
	}
	return 0
}

func (m *LuaPosRect) GetEndX() int32 {
	if m != nil && m.EndX != nil {
		return *m.EndX
	}
	return 0
}

func (m *LuaPosRect) GetEndY() int32 {
	if m != nil && m.EndY != nil {
		return *m.EndY
	}
	return 0
}

// 物品列表
type ItemConfig struct {
	ItemId               *int32   `protobuf:"zigzag32,1,req,name=item_id" json:"item_id,omitempty"`
	ItemCount            *int32   `protobuf:"zigzag32,2,req,name=item_count" json:"item_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ItemConfig) Reset()         { *m = ItemConfig{} }
func (m *ItemConfig) String() string { return proto.CompactTextString(m) }
func (*ItemConfig) ProtoMessage()    {}
func (*ItemConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{31}
}
func (m *ItemConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemConfig.Merge(m, src)
}
func (m *ItemConfig) XXX_Size() int {
	return m.Size()
}
func (m *ItemConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ItemConfig proto.InternalMessageInfo

func (m *ItemConfig) GetItemId() int32 {
	if m != nil && m.ItemId != nil {
		return *m.ItemId
	}
	return 0
}

func (m *ItemConfig) GetItemCount() int32 {
	if m != nil && m.ItemCount != nil {
		return *m.ItemCount
	}
	return 0
}

// 表情列表
type FaceConfig struct {
	ItemId               *int32   `protobuf:"zigzag32,1,req,name=item_id" json:"item_id,omitempty"`
	ItemTime             *int32   `protobuf:"zigzag32,2,req,name=item_time" json:"item_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FaceConfig) Reset()         { *m = FaceConfig{} }
func (m *FaceConfig) String() string { return proto.CompactTextString(m) }
func (*FaceConfig) ProtoMessage()    {}
func (*FaceConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{32}
}
func (m *FaceConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FaceConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FaceConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FaceConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FaceConfig.Merge(m, src)
}
func (m *FaceConfig) XXX_Size() int {
	return m.Size()
}
func (m *FaceConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_FaceConfig.DiscardUnknown(m)
}

var xxx_messageInfo_FaceConfig proto.InternalMessageInfo

func (m *FaceConfig) GetItemId() int32 {
	if m != nil && m.ItemId != nil {
		return *m.ItemId
	}
	return 0
}

func (m *FaceConfig) GetItemTime() int32 {
	if m != nil && m.ItemTime != nil {
		return *m.ItemTime
	}
	return 0
}

// 套装列表
type SuitConfig struct {
	ItemId               *int32   `protobuf:"zigzag32,1,req,name=item_id" json:"item_id,omitempty"`
	ItemTime             *int32   `protobuf:"zigzag32,2,req,name=item_time" json:"item_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SuitConfig) Reset()         { *m = SuitConfig{} }
func (m *SuitConfig) String() string { return proto.CompactTextString(m) }
func (*SuitConfig) ProtoMessage()    {}
func (*SuitConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{33}
}
func (m *SuitConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuitConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SuitConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SuitConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuitConfig.Merge(m, src)
}
func (m *SuitConfig) XXX_Size() int {
	return m.Size()
}
func (m *SuitConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SuitConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SuitConfig proto.InternalMessageInfo

func (m *SuitConfig) GetItemId() int32 {
	if m != nil && m.ItemId != nil {
		return *m.ItemId
	}
	return 0
}

func (m *SuitConfig) GetItemTime() int32 {
	if m != nil && m.ItemTime != nil {
		return *m.ItemTime
	}
	return 0
}

// 邮件结构
type MinosMailTitle struct {
	MailIndex            *int64   `protobuf:"zigzag64,1,req,name=mail_index" json:"mail_index,omitempty"`
	MailTitle            []byte   `protobuf:"bytes,2,req,name=mail_title" json:"mail_title,omitempty"`
	MailTime             *int64   `protobuf:"zigzag64,3,req,name=mail_time" json:"mail_time,omitempty"`
	MailType             *int32   `protobuf:"zigzag32,4,opt,name=mail_type" json:"mail_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MinosMailTitle) Reset()         { *m = MinosMailTitle{} }
func (m *MinosMailTitle) String() string { return proto.CompactTextString(m) }
func (*MinosMailTitle) ProtoMessage()    {}
func (*MinosMailTitle) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{34}
}
func (m *MinosMailTitle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MinosMailTitle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MinosMailTitle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MinosMailTitle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MinosMailTitle.Merge(m, src)
}
func (m *MinosMailTitle) XXX_Size() int {
	return m.Size()
}
func (m *MinosMailTitle) XXX_DiscardUnknown() {
	xxx_messageInfo_MinosMailTitle.DiscardUnknown(m)
}

var xxx_messageInfo_MinosMailTitle proto.InternalMessageInfo

func (m *MinosMailTitle) GetMailIndex() int64 {
	if m != nil && m.MailIndex != nil {
		return *m.MailIndex
	}
	return 0
}

func (m *MinosMailTitle) GetMailTitle() []byte {
	if m != nil {
		return m.MailTitle
	}
	return nil
}

func (m *MinosMailTitle) GetMailTime() int64 {
	if m != nil && m.MailTime != nil {
		return *m.MailTime
	}
	return 0
}

func (m *MinosMailTitle) GetMailType() int32 {
	if m != nil && m.MailType != nil {
		return *m.MailType
	}
	return 0
}

type MinosMail struct {
	SrcRoleIndex         *int64          `protobuf:"zigzag64,1,req,name=src_role_index" json:"src_role_index,omitempty"`
	TarRoleIndex         *int64          `protobuf:"zigzag64,2,req,name=tar_role_index" json:"tar_role_index,omitempty"`
	MailTitle            *MinosMailTitle `protobuf:"bytes,3,req,name=mail_title" json:"mail_title,omitempty"`
	MailText             []byte          `protobuf:"bytes,4,req,name=mail_text" json:"mail_text,omitempty"`
	MailListItems        []*ItemConfig   `protobuf:"bytes,5,rep,name=mail_list_items" json:"mail_list_items,omitempty"`
	MailListFaces        []*FaceConfig   `protobuf:"bytes,6,rep,name=mail_list_faces" json:"mail_list_faces,omitempty"`
	MailListSuits        []*SuitConfig   `protobuf:"bytes,7,rep,name=mail_list_suits" json:"mail_list_suits,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MinosMail) Reset()         { *m = MinosMail{} }
func (m *MinosMail) String() string { return proto.CompactTextString(m) }
func (*MinosMail) ProtoMessage()    {}
func (*MinosMail) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{35}
}
func (m *MinosMail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MinosMail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MinosMail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MinosMail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MinosMail.Merge(m, src)
}
func (m *MinosMail) XXX_Size() int {
	return m.Size()
}
func (m *MinosMail) XXX_DiscardUnknown() {
	xxx_messageInfo_MinosMail.DiscardUnknown(m)
}

var xxx_messageInfo_MinosMail proto.InternalMessageInfo

func (m *MinosMail) GetSrcRoleIndex() int64 {
	if m != nil && m.SrcRoleIndex != nil {
		return *m.SrcRoleIndex
	}
	return 0
}

func (m *MinosMail) GetTarRoleIndex() int64 {
	if m != nil && m.TarRoleIndex != nil {
		return *m.TarRoleIndex
	}
	return 0
}

func (m *MinosMail) GetMailTitle() *MinosMailTitle {
	if m != nil {
		return m.MailTitle
	}
	return nil
}

func (m *MinosMail) GetMailText() []byte {
	if m != nil {
		return m.MailText
	}
	return nil
}

func (m *MinosMail) GetMailListItems() []*ItemConfig {
	if m != nil {
		return m.MailListItems
	}
	return nil
}

func (m *MinosMail) GetMailListFaces() []*FaceConfig {
	if m != nil {
		return m.MailListFaces
	}
	return nil
}

func (m *MinosMail) GetMailListSuits() []*SuitConfig {
	if m != nil {
		return m.MailListSuits
	}
	return nil
}

type InteractNpc struct {
	NpcId                *int32   `protobuf:"zigzag32,1,req,name=npc_id" json:"npc_id,omitempty"`
	Count                *int32   `protobuf:"zigzag32,2,req,name=count" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InteractNpc) Reset()         { *m = InteractNpc{} }
func (m *InteractNpc) String() string { return proto.CompactTextString(m) }
func (*InteractNpc) ProtoMessage()    {}
func (*InteractNpc) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{36}
}
func (m *InteractNpc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InteractNpc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InteractNpc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InteractNpc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InteractNpc.Merge(m, src)
}
func (m *InteractNpc) XXX_Size() int {
	return m.Size()
}
func (m *InteractNpc) XXX_DiscardUnknown() {
	xxx_messageInfo_InteractNpc.DiscardUnknown(m)
}

var xxx_messageInfo_InteractNpc proto.InternalMessageInfo

func (m *InteractNpc) GetNpcId() int32 {
	if m != nil && m.NpcId != nil {
		return *m.NpcId
	}
	return 0
}

func (m *InteractNpc) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

// 交互动作计数
type InteractCount struct {
	Id                   *int32   `protobuf:"zigzag32,1,req,name=id" json:"id,omitempty"`
	Count                *int32   `protobuf:"zigzag32,2,req,name=count" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InteractCount) Reset()         { *m = InteractCount{} }
func (m *InteractCount) String() string { return proto.CompactTextString(m) }
func (*InteractCount) ProtoMessage()    {}
func (*InteractCount) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{37}
}
func (m *InteractCount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InteractCount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InteractCount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InteractCount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InteractCount.Merge(m, src)
}
func (m *InteractCount) XXX_Size() int {
	return m.Size()
}
func (m *InteractCount) XXX_DiscardUnknown() {
	xxx_messageInfo_InteractCount.DiscardUnknown(m)
}

var xxx_messageInfo_InteractCount proto.InternalMessageInfo

func (m *InteractCount) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *InteractCount) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

// 交互系统解锁条件
type InteractUnlock struct {
	Condition            []int32  `protobuf:"zigzag32,1,rep,name=condition" json:"condition,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InteractUnlock) Reset()         { *m = InteractUnlock{} }
func (m *InteractUnlock) String() string { return proto.CompactTextString(m) }
func (*InteractUnlock) ProtoMessage()    {}
func (*InteractUnlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{38}
}
func (m *InteractUnlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InteractUnlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InteractUnlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InteractUnlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InteractUnlock.Merge(m, src)
}
func (m *InteractUnlock) XXX_Size() int {
	return m.Size()
}
func (m *InteractUnlock) XXX_DiscardUnknown() {
	xxx_messageInfo_InteractUnlock.DiscardUnknown(m)
}

var xxx_messageInfo_InteractUnlock proto.InternalMessageInfo

func (m *InteractUnlock) GetCondition() []int32 {
	if m != nil {
		return m.Condition
	}
	return nil
}

type LevelNeed struct {
	CurLevel             *int32   `protobuf:"zigzag32,1,req,name=cur_level" json:"cur_level,omitempty"`
	NeedLevel            *int32   `protobuf:"zigzag32,2,req,name=need_level" json:"need_level,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LevelNeed) Reset()         { *m = LevelNeed{} }
func (m *LevelNeed) String() string { return proto.CompactTextString(m) }
func (*LevelNeed) ProtoMessage()    {}
func (*LevelNeed) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{39}
}
func (m *LevelNeed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LevelNeed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LevelNeed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LevelNeed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LevelNeed.Merge(m, src)
}
func (m *LevelNeed) XXX_Size() int {
	return m.Size()
}
func (m *LevelNeed) XXX_DiscardUnknown() {
	xxx_messageInfo_LevelNeed.DiscardUnknown(m)
}

var xxx_messageInfo_LevelNeed proto.InternalMessageInfo

func (m *LevelNeed) GetCurLevel() int32 {
	if m != nil && m.CurLevel != nil {
		return *m.CurLevel
	}
	return 0
}

func (m *LevelNeed) GetNeedLevel() int32 {
	if m != nil && m.NeedLevel != nil {
		return *m.NeedLevel
	}
	return 0
}

type ItemNeed struct {
	Id                   *int32   `protobuf:"zigzag32,1,req,name=id" json:"id,omitempty"`
	CurCount             *int64   `protobuf:"zigzag64,2,req,name=cur_count" json:"cur_count,omitempty"`
	NeedCount            *int64   `protobuf:"zigzag64,3,req,name=need_count" json:"need_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ItemNeed) Reset()         { *m = ItemNeed{} }
func (m *ItemNeed) String() string { return proto.CompactTextString(m) }
func (*ItemNeed) ProtoMessage()    {}
func (*ItemNeed) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{40}
}
func (m *ItemNeed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemNeed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemNeed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemNeed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemNeed.Merge(m, src)
}
func (m *ItemNeed) XXX_Size() int {
	return m.Size()
}
func (m *ItemNeed) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemNeed.DiscardUnknown(m)
}

var xxx_messageInfo_ItemNeed proto.InternalMessageInfo

func (m *ItemNeed) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *ItemNeed) GetCurCount() int64 {
	if m != nil && m.CurCount != nil {
		return *m.CurCount
	}
	return 0
}

func (m *ItemNeed) GetNeedCount() int64 {
	if m != nil && m.NeedCount != nil {
		return *m.NeedCount
	}
	return 0
}

// 特殊道具广播
type SpInfo struct {
	SpId                 *int32   `protobuf:"zigzag32,1,req,name=sp_id" json:"sp_id,omitempty"`
	Stamp                *int64   `protobuf:"zigzag64,2,req,name=stamp" json:"stamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SpInfo) Reset()         { *m = SpInfo{} }
func (m *SpInfo) String() string { return proto.CompactTextString(m) }
func (*SpInfo) ProtoMessage()    {}
func (*SpInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{41}
}
func (m *SpInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpInfo.Merge(m, src)
}
func (m *SpInfo) XXX_Size() int {
	return m.Size()
}
func (m *SpInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SpInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SpInfo proto.InternalMessageInfo

func (m *SpInfo) GetSpId() int32 {
	if m != nil && m.SpId != nil {
		return *m.SpId
	}
	return 0
}

func (m *SpInfo) GetStamp() int64 {
	if m != nil && m.Stamp != nil {
		return *m.Stamp
	}
	return 0
}

// 自定义表情
type RoleCustomFace struct {
	FaceId               *int32   `protobuf:"zigzag32,1,req,name=face_id" json:"face_id,omitempty"`
	Valid                *int32   `protobuf:"zigzag32,2,req,name=valid" json:"valid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoleCustomFace) Reset()         { *m = RoleCustomFace{} }
func (m *RoleCustomFace) String() string { return proto.CompactTextString(m) }
func (*RoleCustomFace) ProtoMessage()    {}
func (*RoleCustomFace) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{42}
}
func (m *RoleCustomFace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleCustomFace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleCustomFace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleCustomFace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleCustomFace.Merge(m, src)
}
func (m *RoleCustomFace) XXX_Size() int {
	return m.Size()
}
func (m *RoleCustomFace) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleCustomFace.DiscardUnknown(m)
}

var xxx_messageInfo_RoleCustomFace proto.InternalMessageInfo

func (m *RoleCustomFace) GetFaceId() int32 {
	if m != nil && m.FaceId != nil {
		return *m.FaceId
	}
	return 0
}

func (m *RoleCustomFace) GetValid() int32 {
	if m != nil && m.Valid != nil {
		return *m.Valid
	}
	return 0
}

// 宠物战斗基本属性(宠物战斗属性由基本属性与等级对应属性的和)
type PetBaseFight struct {
	Hp                   *int64   `protobuf:"zigzag64,1,req,name=hp" json:"hp,omitempty"`
	Atk                  *int64   `protobuf:"zigzag64,2,req,name=atk" json:"atk,omitempty"`
	Def                  *int64   `protobuf:"zigzag64,3,req,name=def" json:"def,omitempty"`
	Crit                 *int64   `protobuf:"zigzag64,4,req,name=crit" json:"crit,omitempty"`
	Block                *int64   `protobuf:"zigzag64,5,req,name=block" json:"block,omitempty"`
	Speed                *int64   `protobuf:"zigzag64,6,req,name=speed" json:"speed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PetBaseFight) Reset()         { *m = PetBaseFight{} }
func (m *PetBaseFight) String() string { return proto.CompactTextString(m) }
func (*PetBaseFight) ProtoMessage()    {}
func (*PetBaseFight) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{43}
}
func (m *PetBaseFight) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PetBaseFight) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PetBaseFight.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PetBaseFight) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PetBaseFight.Merge(m, src)
}
func (m *PetBaseFight) XXX_Size() int {
	return m.Size()
}
func (m *PetBaseFight) XXX_DiscardUnknown() {
	xxx_messageInfo_PetBaseFight.DiscardUnknown(m)
}

var xxx_messageInfo_PetBaseFight proto.InternalMessageInfo

func (m *PetBaseFight) GetHp() int64 {
	if m != nil && m.Hp != nil {
		return *m.Hp
	}
	return 0
}

func (m *PetBaseFight) GetAtk() int64 {
	if m != nil && m.Atk != nil {
		return *m.Atk
	}
	return 0
}

func (m *PetBaseFight) GetDef() int64 {
	if m != nil && m.Def != nil {
		return *m.Def
	}
	return 0
}

func (m *PetBaseFight) GetCrit() int64 {
	if m != nil && m.Crit != nil {
		return *m.Crit
	}
	return 0
}

func (m *PetBaseFight) GetBlock() int64 {
	if m != nil && m.Block != nil {
		return *m.Block
	}
	return 0
}

func (m *PetBaseFight) GetSpeed() int64 {
	if m != nil && m.Speed != nil {
		return *m.Speed
	}
	return 0
}

// 宠物技能
type PetTalent struct {
	TalentId             *int32   `protobuf:"zigzag32,1,req,name=talent_id" json:"talent_id,omitempty"`
	Level                *int32   `protobuf:"zigzag32,2,req,name=level" json:"level,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PetTalent) Reset()         { *m = PetTalent{} }
func (m *PetTalent) String() string { return proto.CompactTextString(m) }
func (*PetTalent) ProtoMessage()    {}
func (*PetTalent) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{44}
}
func (m *PetTalent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PetTalent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PetTalent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PetTalent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PetTalent.Merge(m, src)
}
func (m *PetTalent) XXX_Size() int {
	return m.Size()
}
func (m *PetTalent) XXX_DiscardUnknown() {
	xxx_messageInfo_PetTalent.DiscardUnknown(m)
}

var xxx_messageInfo_PetTalent proto.InternalMessageInfo

func (m *PetTalent) GetTalentId() int32 {
	if m != nil && m.TalentId != nil {
		return *m.TalentId
	}
	return 0
}

func (m *PetTalent) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

// 宠物信息
type PetInfo struct {
	PetId                *int32        `protobuf:"zigzag32,1,req,name=pet_id" json:"pet_id,omitempty"`
	Level                *int32        `protobuf:"zigzag32,2,req,name=level" json:"level,omitempty"`
	Exp                  *int64        `protobuf:"zigzag64,3,req,name=exp" json:"exp,omitempty"`
	BaseAttr             *PetBaseFight `protobuf:"bytes,4,req,name=base_attr" json:"base_attr,omitempty"`
	ActiveList           []*PetTalent  `protobuf:"bytes,5,rep,name=active_list" json:"active_list,omitempty"`
	PassiveList          []*PetTalent  `protobuf:"bytes,6,rep,name=passive_list" json:"passive_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *PetInfo) Reset()         { *m = PetInfo{} }
func (m *PetInfo) String() string { return proto.CompactTextString(m) }
func (*PetInfo) ProtoMessage()    {}
func (*PetInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{45}
}
func (m *PetInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PetInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PetInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PetInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PetInfo.Merge(m, src)
}
func (m *PetInfo) XXX_Size() int {
	return m.Size()
}
func (m *PetInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PetInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PetInfo proto.InternalMessageInfo

func (m *PetInfo) GetPetId() int32 {
	if m != nil && m.PetId != nil {
		return *m.PetId
	}
	return 0
}

func (m *PetInfo) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *PetInfo) GetExp() int64 {
	if m != nil && m.Exp != nil {
		return *m.Exp
	}
	return 0
}

func (m *PetInfo) GetBaseAttr() *PetBaseFight {
	if m != nil {
		return m.BaseAttr
	}
	return nil
}

func (m *PetInfo) GetActiveList() []*PetTalent {
	if m != nil {
		return m.ActiveList
	}
	return nil
}

func (m *PetInfo) GetPassiveList() []*PetTalent {
	if m != nil {
		return m.PassiveList
	}
	return nil
}

// 宠物刷新信息
type PetRefresh struct {
	Status               *int32   `protobuf:"zigzag32,1,opt,name=status" json:"status,omitempty"`
	NextRefreshTimestamp *int64   `protobuf:"zigzag64,2,opt,name=next_refresh_timestamp" json:"next_refresh_timestamp,omitempty"`
	PetId                *int32   `protobuf:"zigzag32,3,opt,name=pet_id" json:"pet_id,omitempty"`
	SceneId              *int32   `protobuf:"zigzag32,4,opt,name=scene_id" json:"scene_id,omitempty"`
	PosInfo              *LuaPos  `protobuf:"bytes,5,opt,name=pos_info" json:"pos_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PetRefresh) Reset()         { *m = PetRefresh{} }
func (m *PetRefresh) String() string { return proto.CompactTextString(m) }
func (*PetRefresh) ProtoMessage()    {}
func (*PetRefresh) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{46}
}
func (m *PetRefresh) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PetRefresh) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PetRefresh.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PetRefresh) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PetRefresh.Merge(m, src)
}
func (m *PetRefresh) XXX_Size() int {
	return m.Size()
}
func (m *PetRefresh) XXX_DiscardUnknown() {
	xxx_messageInfo_PetRefresh.DiscardUnknown(m)
}

var xxx_messageInfo_PetRefresh proto.InternalMessageInfo

func (m *PetRefresh) GetStatus() int32 {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return 0
}

func (m *PetRefresh) GetNextRefreshTimestamp() int64 {
	if m != nil && m.NextRefreshTimestamp != nil {
		return *m.NextRefreshTimestamp
	}
	return 0
}

func (m *PetRefresh) GetPetId() int32 {
	if m != nil && m.PetId != nil {
		return *m.PetId
	}
	return 0
}

func (m *PetRefresh) GetSceneId() int32 {
	if m != nil && m.SceneId != nil {
		return *m.SceneId
	}
	return 0
}

func (m *PetRefresh) GetPosInfo() *LuaPos {
	if m != nil {
		return m.PosInfo
	}
	return nil
}

// 走马灯数据信息
type HorseEvent struct {
	Type                 *E_HORSE_LIGHT_TYPE `protobuf:"varint,1,opt,name=type,enum=pbd.E_HORSE_LIGHT_TYPE" json:"type,omitempty"`
	ParaList             []int64             `protobuf:"zigzag64,2,rep,name=para_list" json:"para_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *HorseEvent) Reset()         { *m = HorseEvent{} }
func (m *HorseEvent) String() string { return proto.CompactTextString(m) }
func (*HorseEvent) ProtoMessage()    {}
func (*HorseEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{47}
}
func (m *HorseEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HorseEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HorseEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HorseEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HorseEvent.Merge(m, src)
}
func (m *HorseEvent) XXX_Size() int {
	return m.Size()
}
func (m *HorseEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_HorseEvent.DiscardUnknown(m)
}

var xxx_messageInfo_HorseEvent proto.InternalMessageInfo

func (m *HorseEvent) GetType() E_HORSE_LIGHT_TYPE {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return E_HORSE_LIGHT_TYPE_EHLT_CALIBURN_WEAPON_COLOR
}

func (m *HorseEvent) GetParaList() []int64 {
	if m != nil {
		return m.ParaList
	}
	return nil
}

// 物品列表
type ItemListConfig struct {
	Item                 []*ItemConfig `protobuf:"bytes,1,rep,name=item" json:"item,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ItemListConfig) Reset()         { *m = ItemListConfig{} }
func (m *ItemListConfig) String() string { return proto.CompactTextString(m) }
func (*ItemListConfig) ProtoMessage()    {}
func (*ItemListConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{48}
}
func (m *ItemListConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemListConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemListConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemListConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemListConfig.Merge(m, src)
}
func (m *ItemListConfig) XXX_Size() int {
	return m.Size()
}
func (m *ItemListConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemListConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ItemListConfig proto.InternalMessageInfo

func (m *ItemListConfig) GetItem() []*ItemConfig {
	if m != nil {
		return m.Item
	}
	return nil
}

// 走马灯推送
type HorseLightInfo struct {
	HorseId              *int32   `protobuf:"zigzag32,1,req,name=horse_id" json:"horse_id,omitempty"`
	NickName             []byte   `protobuf:"bytes,2,opt,name=nick_name" json:"nick_name,omitempty"`
	ParaList             []int64  `protobuf:"zigzag64,3,rep,name=para_list" json:"para_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HorseLightInfo) Reset()         { *m = HorseLightInfo{} }
func (m *HorseLightInfo) String() string { return proto.CompactTextString(m) }
func (*HorseLightInfo) ProtoMessage()    {}
func (*HorseLightInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{49}
}
func (m *HorseLightInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HorseLightInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HorseLightInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HorseLightInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HorseLightInfo.Merge(m, src)
}
func (m *HorseLightInfo) XXX_Size() int {
	return m.Size()
}
func (m *HorseLightInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HorseLightInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HorseLightInfo proto.InternalMessageInfo

func (m *HorseLightInfo) GetHorseId() int32 {
	if m != nil && m.HorseId != nil {
		return *m.HorseId
	}
	return 0
}

func (m *HorseLightInfo) GetNickName() []byte {
	if m != nil {
		return m.NickName
	}
	return nil
}

func (m *HorseLightInfo) GetParaList() []int64 {
	if m != nil {
		return m.ParaList
	}
	return nil
}

type SuccessDetail struct {
	SuccessCount         *int64   `protobuf:"zigzag64,1,req,name=success_count" json:"success_count,omitempty"`
	SuccessNum           *int64   `protobuf:"zigzag64,2,opt,name=success_num" json:"success_num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SuccessDetail) Reset()         { *m = SuccessDetail{} }
func (m *SuccessDetail) String() string { return proto.CompactTextString(m) }
func (*SuccessDetail) ProtoMessage()    {}
func (*SuccessDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{50}
}
func (m *SuccessDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuccessDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SuccessDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SuccessDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuccessDetail.Merge(m, src)
}
func (m *SuccessDetail) XXX_Size() int {
	return m.Size()
}
func (m *SuccessDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_SuccessDetail.DiscardUnknown(m)
}

var xxx_messageInfo_SuccessDetail proto.InternalMessageInfo

func (m *SuccessDetail) GetSuccessCount() int64 {
	if m != nil && m.SuccessCount != nil {
		return *m.SuccessCount
	}
	return 0
}

func (m *SuccessDetail) GetSuccessNum() int64 {
	if m != nil && m.SuccessNum != nil {
		return *m.SuccessNum
	}
	return 0
}

// 二次园结果信息
type GuadraticResult struct {
	Show                 *PlayerShowInfo `protobuf:"bytes,1,req,name=show" json:"show,omitempty"`
	LiveTime             *int32          `protobuf:"zigzag32,2,req,name=live_time" json:"live_time,omitempty"`
	KillNum              *int32          `protobuf:"zigzag32,3,req,name=kill_num" json:"kill_num,omitempty"`
	ItemList             *ItemListConfig `protobuf:"bytes,4,req,name=item_list" json:"item_list,omitempty"`
	RoleIndex            *int64          `protobuf:"zigzag64,5,req,name=role_index" json:"role_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GuadraticResult) Reset()         { *m = GuadraticResult{} }
func (m *GuadraticResult) String() string { return proto.CompactTextString(m) }
func (*GuadraticResult) ProtoMessage()    {}
func (*GuadraticResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{51}
}
func (m *GuadraticResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuadraticResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuadraticResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GuadraticResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuadraticResult.Merge(m, src)
}
func (m *GuadraticResult) XXX_Size() int {
	return m.Size()
}
func (m *GuadraticResult) XXX_DiscardUnknown() {
	xxx_messageInfo_GuadraticResult.DiscardUnknown(m)
}

var xxx_messageInfo_GuadraticResult proto.InternalMessageInfo

func (m *GuadraticResult) GetShow() *PlayerShowInfo {
	if m != nil {
		return m.Show
	}
	return nil
}

func (m *GuadraticResult) GetLiveTime() int32 {
	if m != nil && m.LiveTime != nil {
		return *m.LiveTime
	}
	return 0
}

func (m *GuadraticResult) GetKillNum() int32 {
	if m != nil && m.KillNum != nil {
		return *m.KillNum
	}
	return 0
}

func (m *GuadraticResult) GetItemList() *ItemListConfig {
	if m != nil {
		return m.ItemList
	}
	return nil
}

func (m *GuadraticResult) GetRoleIndex() int64 {
	if m != nil && m.RoleIndex != nil {
		return *m.RoleIndex
	}
	return 0
}

// 二次元房间玩家坐标信息
type GuadraticRoleInfo struct {
	RoleIndex            *int64   `protobuf:"zigzag64,1,req,name=role_index" json:"role_index,omitempty"`
	Pos                  *LuaPos  `protobuf:"bytes,2,opt,name=pos" json:"pos,omitempty"`
	CurrentHp            *int32   `protobuf:"zigzag32,3,req,name=current_hp" json:"current_hp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GuadraticRoleInfo) Reset()         { *m = GuadraticRoleInfo{} }
func (m *GuadraticRoleInfo) String() string { return proto.CompactTextString(m) }
func (*GuadraticRoleInfo) ProtoMessage()    {}
func (*GuadraticRoleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{52}
}
func (m *GuadraticRoleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuadraticRoleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuadraticRoleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GuadraticRoleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuadraticRoleInfo.Merge(m, src)
}
func (m *GuadraticRoleInfo) XXX_Size() int {
	return m.Size()
}
func (m *GuadraticRoleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GuadraticRoleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GuadraticRoleInfo proto.InternalMessageInfo

func (m *GuadraticRoleInfo) GetRoleIndex() int64 {
	if m != nil && m.RoleIndex != nil {
		return *m.RoleIndex
	}
	return 0
}

func (m *GuadraticRoleInfo) GetPos() *LuaPos {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *GuadraticRoleInfo) GetCurrentHp() int32 {
	if m != nil && m.CurrentHp != nil {
		return *m.CurrentHp
	}
	return 0
}

// 二次元房间玩家血量变化
type GuadraticRoleHp struct {
	RoleIndex            *int64   `protobuf:"zigzag64,1,req,name=role_index" json:"role_index,omitempty"`
	Hp                   *int32   `protobuf:"zigzag32,2,req,name=hp" json:"hp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GuadraticRoleHp) Reset()         { *m = GuadraticRoleHp{} }
func (m *GuadraticRoleHp) String() string { return proto.CompactTextString(m) }
func (*GuadraticRoleHp) ProtoMessage()    {}
func (*GuadraticRoleHp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{53}
}
func (m *GuadraticRoleHp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuadraticRoleHp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuadraticRoleHp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GuadraticRoleHp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuadraticRoleHp.Merge(m, src)
}
func (m *GuadraticRoleHp) XXX_Size() int {
	return m.Size()
}
func (m *GuadraticRoleHp) XXX_DiscardUnknown() {
	xxx_messageInfo_GuadraticRoleHp.DiscardUnknown(m)
}

var xxx_messageInfo_GuadraticRoleHp proto.InternalMessageInfo

func (m *GuadraticRoleHp) GetRoleIndex() int64 {
	if m != nil && m.RoleIndex != nil {
		return *m.RoleIndex
	}
	return 0
}

func (m *GuadraticRoleHp) GetHp() int32 {
	if m != nil && m.Hp != nil {
		return *m.Hp
	}
	return 0
}

// 二次元房间玩家CD变化
type GuadraticRoleCd struct {
	RoleIndex            *int64   `protobuf:"zigzag64,1,req,name=role_index" json:"role_index,omitempty"`
	Cd                   *int32   `protobuf:"zigzag32,2,req,name=cd" json:"cd,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GuadraticRoleCd) Reset()         { *m = GuadraticRoleCd{} }
func (m *GuadraticRoleCd) String() string { return proto.CompactTextString(m) }
func (*GuadraticRoleCd) ProtoMessage()    {}
func (*GuadraticRoleCd) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{54}
}
func (m *GuadraticRoleCd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuadraticRoleCd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuadraticRoleCd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GuadraticRoleCd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuadraticRoleCd.Merge(m, src)
}
func (m *GuadraticRoleCd) XXX_Size() int {
	return m.Size()
}
func (m *GuadraticRoleCd) XXX_DiscardUnknown() {
	xxx_messageInfo_GuadraticRoleCd.DiscardUnknown(m)
}

var xxx_messageInfo_GuadraticRoleCd proto.InternalMessageInfo

func (m *GuadraticRoleCd) GetRoleIndex() int64 {
	if m != nil && m.RoleIndex != nil {
		return *m.RoleIndex
	}
	return 0
}

func (m *GuadraticRoleCd) GetCd() int32 {
	if m != nil && m.Cd != nil {
		return *m.Cd
	}
	return 0
}

type SellInfo struct {
	Index                *int64   `protobuf:"zigzag64,1,req,name=index" json:"index,omitempty"`
	Num                  *int32   `protobuf:"zigzag32,2,req,name=num" json:"num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SellInfo) Reset()         { *m = SellInfo{} }
func (m *SellInfo) String() string { return proto.CompactTextString(m) }
func (*SellInfo) ProtoMessage()    {}
func (*SellInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{55}
}
func (m *SellInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SellInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SellInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SellInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SellInfo.Merge(m, src)
}
func (m *SellInfo) XXX_Size() int {
	return m.Size()
}
func (m *SellInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SellInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SellInfo proto.InternalMessageInfo

func (m *SellInfo) GetIndex() int64 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *SellInfo) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

// 兑换码信息
type RedeemCodeInfo struct {
	Code                 []byte   `protobuf:"bytes,1,req,name=code" json:"code,omitempty"`
	BatchNo              []byte   `protobuf:"bytes,2,req,name=batch_no" json:"batch_no,omitempty"`
	AccountType          *int32   `protobuf:"varint,3,req,name=account_type" json:"account_type,omitempty"`
	ServerRule           *int32   `protobuf:"varint,4,req,name=server_rule" json:"server_rule,omitempty"`
	ServerId             *int32   `protobuf:"varint,5,req,name=server_id" json:"server_id,omitempty"`
	GiftId               *int64   `protobuf:"varint,6,req,name=gift_id" json:"gift_id,omitempty"`
	StartTime            *int64   `protobuf:"varint,7,req,name=start_time" json:"start_time,omitempty"`
	EndTime              *int64   `protobuf:"varint,8,req,name=end_time" json:"end_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RedeemCodeInfo) Reset()         { *m = RedeemCodeInfo{} }
func (m *RedeemCodeInfo) String() string { return proto.CompactTextString(m) }
func (*RedeemCodeInfo) ProtoMessage()    {}
func (*RedeemCodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{56}
}
func (m *RedeemCodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedeemCodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedeemCodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedeemCodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedeemCodeInfo.Merge(m, src)
}
func (m *RedeemCodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *RedeemCodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RedeemCodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RedeemCodeInfo proto.InternalMessageInfo

func (m *RedeemCodeInfo) GetCode() []byte {
	if m != nil {
		return m.Code
	}
	return nil
}

func (m *RedeemCodeInfo) GetBatchNo() []byte {
	if m != nil {
		return m.BatchNo
	}
	return nil
}

func (m *RedeemCodeInfo) GetAccountType() int32 {
	if m != nil && m.AccountType != nil {
		return *m.AccountType
	}
	return 0
}

func (m *RedeemCodeInfo) GetServerRule() int32 {
	if m != nil && m.ServerRule != nil {
		return *m.ServerRule
	}
	return 0
}

func (m *RedeemCodeInfo) GetServerId() int32 {
	if m != nil && m.ServerId != nil {
		return *m.ServerId
	}
	return 0
}

func (m *RedeemCodeInfo) GetGiftId() int64 {
	if m != nil && m.GiftId != nil {
		return *m.GiftId
	}
	return 0
}

func (m *RedeemCodeInfo) GetStartTime() int64 {
	if m != nil && m.StartTime != nil {
		return *m.StartTime
	}
	return 0
}

func (m *RedeemCodeInfo) GetEndTime() int64 {
	if m != nil && m.EndTime != nil {
		return *m.EndTime
	}
	return 0
}

// 兑换码对应奖励信息
type RedeemGiftInfo struct {
	GiftId               *int64          `protobuf:"zigzag64,1,req,name=gift_id" json:"gift_id,omitempty"`
	ItemList             *ItemListConfig `protobuf:"bytes,2,req,name=item_list" json:"item_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RedeemGiftInfo) Reset()         { *m = RedeemGiftInfo{} }
func (m *RedeemGiftInfo) String() string { return proto.CompactTextString(m) }
func (*RedeemGiftInfo) ProtoMessage()    {}
func (*RedeemGiftInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{57}
}
func (m *RedeemGiftInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedeemGiftInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedeemGiftInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedeemGiftInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedeemGiftInfo.Merge(m, src)
}
func (m *RedeemGiftInfo) XXX_Size() int {
	return m.Size()
}
func (m *RedeemGiftInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RedeemGiftInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RedeemGiftInfo proto.InternalMessageInfo

func (m *RedeemGiftInfo) GetGiftId() int64 {
	if m != nil && m.GiftId != nil {
		return *m.GiftId
	}
	return 0
}

func (m *RedeemGiftInfo) GetItemList() *ItemListConfig {
	if m != nil {
		return m.ItemList
	}
	return nil
}

// 活动
type ActivitySummary struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	PlatformId           *int32   `protobuf:"zigzag32,2,opt,name=platform_id" json:"platform_id,omitempty"`
	Title                []byte   `protobuf:"bytes,3,opt,name=title" json:"title,omitempty"`
	Content              []byte   `protobuf:"bytes,4,opt,name=content" json:"content,omitempty"`
	Type                 *int32   `protobuf:"varint,5,opt,name=type" json:"type,omitempty"`
	SubType              *int32   `protobuf:"varint,6,opt,name=sub_type" json:"sub_type,omitempty"`
	StartTime            *int64   `protobuf:"zigzag64,7,opt,name=start_time" json:"start_time,omitempty"`
	EndTime              *int64   `protobuf:"zigzag64,8,opt,name=end_time" json:"end_time,omitempty"`
	StopTime             *int64   `protobuf:"zigzag64,9,opt,name=stop_time" json:"stop_time,omitempty"`
	ResetType            *int32   `protobuf:"zigzag32,10,opt,name=reset_type" json:"reset_type,omitempty"`
	ResetHour            *int32   `protobuf:"zigzag32,11,opt,name=reset_hour" json:"reset_hour,omitempty"`
	Rules                []byte   `protobuf:"bytes,12,opt,name=rules" json:"rules,omitempty"`
	ResetTime            *int64   `protobuf:"zigzag64,13,opt,name=reset_time" json:"reset_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActivitySummary) Reset()         { *m = ActivitySummary{} }
func (m *ActivitySummary) String() string { return proto.CompactTextString(m) }
func (*ActivitySummary) ProtoMessage()    {}
func (*ActivitySummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{58}
}
func (m *ActivitySummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivitySummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivitySummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivitySummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivitySummary.Merge(m, src)
}
func (m *ActivitySummary) XXX_Size() int {
	return m.Size()
}
func (m *ActivitySummary) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivitySummary.DiscardUnknown(m)
}

var xxx_messageInfo_ActivitySummary proto.InternalMessageInfo

func (m *ActivitySummary) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *ActivitySummary) GetPlatformId() int32 {
	if m != nil && m.PlatformId != nil {
		return *m.PlatformId
	}
	return 0
}

func (m *ActivitySummary) GetTitle() []byte {
	if m != nil {
		return m.Title
	}
	return nil
}

func (m *ActivitySummary) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *ActivitySummary) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *ActivitySummary) GetSubType() int32 {
	if m != nil && m.SubType != nil {
		return *m.SubType
	}
	return 0
}

func (m *ActivitySummary) GetStartTime() int64 {
	if m != nil && m.StartTime != nil {
		return *m.StartTime
	}
	return 0
}

func (m *ActivitySummary) GetEndTime() int64 {
	if m != nil && m.EndTime != nil {
		return *m.EndTime
	}
	return 0
}

func (m *ActivitySummary) GetStopTime() int64 {
	if m != nil && m.StopTime != nil {
		return *m.StopTime
	}
	return 0
}

func (m *ActivitySummary) GetResetType() int32 {
	if m != nil && m.ResetType != nil {
		return *m.ResetType
	}
	return 0
}

func (m *ActivitySummary) GetResetHour() int32 {
	if m != nil && m.ResetHour != nil {
		return *m.ResetHour
	}
	return 0
}

func (m *ActivitySummary) GetRules() []byte {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *ActivitySummary) GetResetTime() int64 {
	if m != nil && m.ResetTime != nil {
		return *m.ResetTime
	}
	return 0
}

// 具体的活动规则,利用变长参数
type ActivityRule struct {
	RuleDes              []byte        `protobuf:"bytes,1,opt,name=rule_des" json:"rule_des,omitempty"`
	SubType              *int32        `protobuf:"zigzag32,2,opt,name=sub_type" json:"sub_type,omitempty"`
	ParaList             []int32       `protobuf:"zigzag32,3,rep,name=para_list" json:"para_list,omitempty"`
	CanGetCount          *int32        `protobuf:"zigzag32,4,opt,name=can_get_count" json:"can_get_count,omitempty"`
	GotCount             *int32        `protobuf:"zigzag32,5,opt,name=got_count" json:"got_count,omitempty"`
	GetLimitCount        *int32        `protobuf:"zigzag32,6,opt,name=get_limit_count" json:"get_limit_count,omitempty"`
	RewardList           []*ItemConfig `protobuf:"bytes,7,rep,name=reward_list" json:"reward_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ActivityRule) Reset()         { *m = ActivityRule{} }
func (m *ActivityRule) String() string { return proto.CompactTextString(m) }
func (*ActivityRule) ProtoMessage()    {}
func (*ActivityRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{59}
}
func (m *ActivityRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivityRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivityRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivityRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivityRule.Merge(m, src)
}
func (m *ActivityRule) XXX_Size() int {
	return m.Size()
}
func (m *ActivityRule) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivityRule.DiscardUnknown(m)
}

var xxx_messageInfo_ActivityRule proto.InternalMessageInfo

func (m *ActivityRule) GetRuleDes() []byte {
	if m != nil {
		return m.RuleDes
	}
	return nil
}

func (m *ActivityRule) GetSubType() int32 {
	if m != nil && m.SubType != nil {
		return *m.SubType
	}
	return 0
}

func (m *ActivityRule) GetParaList() []int32 {
	if m != nil {
		return m.ParaList
	}
	return nil
}

func (m *ActivityRule) GetCanGetCount() int32 {
	if m != nil && m.CanGetCount != nil {
		return *m.CanGetCount
	}
	return 0
}

func (m *ActivityRule) GetGotCount() int32 {
	if m != nil && m.GotCount != nil {
		return *m.GotCount
	}
	return 0
}

func (m *ActivityRule) GetGetLimitCount() int32 {
	if m != nil && m.GetLimitCount != nil {
		return *m.GetLimitCount
	}
	return 0
}

func (m *ActivityRule) GetRewardList() []*ItemConfig {
	if m != nil {
		return m.RewardList
	}
	return nil
}

// 还要写上对应每个活动类型的子规则
type ActivityInfo struct {
	Version              *int32           `protobuf:"zigzag32,1,req,name=version" json:"version,omitempty"`
	SummaryInfo          *ActivitySummary `protobuf:"bytes,2,opt,name=summary_info" json:"summary_info,omitempty"`
	RuleList             []*ActivityRule  `protobuf:"bytes,3,rep,name=rule_list" json:"rule_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ActivityInfo) Reset()         { *m = ActivityInfo{} }
func (m *ActivityInfo) String() string { return proto.CompactTextString(m) }
func (*ActivityInfo) ProtoMessage()    {}
func (*ActivityInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{60}
}
func (m *ActivityInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivityInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivityInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivityInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivityInfo.Merge(m, src)
}
func (m *ActivityInfo) XXX_Size() int {
	return m.Size()
}
func (m *ActivityInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivityInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ActivityInfo proto.InternalMessageInfo

func (m *ActivityInfo) GetVersion() int32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *ActivityInfo) GetSummaryInfo() *ActivitySummary {
	if m != nil {
		return m.SummaryInfo
	}
	return nil
}

func (m *ActivityInfo) GetRuleList() []*ActivityRule {
	if m != nil {
		return m.RuleList
	}
	return nil
}

// 活动进度信息
type ActivityProgressInfo struct {
	Type                 *E_ACTIVITY_TYPE     `protobuf:"varint,1,req,name=type,enum=pbd.E_ACTIVITY_TYPE" json:"type,omitempty"`
	SubType              *E_ACTIVITY_SUB_TYPE `protobuf:"varint,2,opt,name=sub_type,enum=pbd.E_ACTIVITY_SUB_TYPE" json:"sub_type,omitempty"`
	Param                []int32              `protobuf:"zigzag32,3,rep,name=param" json:"param,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ActivityProgressInfo) Reset()         { *m = ActivityProgressInfo{} }
func (m *ActivityProgressInfo) String() string { return proto.CompactTextString(m) }
func (*ActivityProgressInfo) ProtoMessage()    {}
func (*ActivityProgressInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{61}
}
func (m *ActivityProgressInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivityProgressInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivityProgressInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivityProgressInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivityProgressInfo.Merge(m, src)
}
func (m *ActivityProgressInfo) XXX_Size() int {
	return m.Size()
}
func (m *ActivityProgressInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivityProgressInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ActivityProgressInfo proto.InternalMessageInfo

func (m *ActivityProgressInfo) GetType() E_ACTIVITY_TYPE {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return E_ACTIVITY_TYPE_FIRST_SAVE
}

func (m *ActivityProgressInfo) GetSubType() E_ACTIVITY_SUB_TYPE {
	if m != nil && m.SubType != nil {
		return *m.SubType
	}
	return E_ACTIVITY_SUB_TYPE_PASS_RISK
}

func (m *ActivityProgressInfo) GetParam() []int32 {
	if m != nil {
		return m.Param
	}
	return nil
}

type ActivityBaseInfo struct {
	Id                   *int32   `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	Ver                  *int32   `protobuf:"zigzag32,2,opt,name=ver" json:"ver,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActivityBaseInfo) Reset()         { *m = ActivityBaseInfo{} }
func (m *ActivityBaseInfo) String() string { return proto.CompactTextString(m) }
func (*ActivityBaseInfo) ProtoMessage()    {}
func (*ActivityBaseInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{62}
}
func (m *ActivityBaseInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivityBaseInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivityBaseInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivityBaseInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivityBaseInfo.Merge(m, src)
}
func (m *ActivityBaseInfo) XXX_Size() int {
	return m.Size()
}
func (m *ActivityBaseInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivityBaseInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ActivityBaseInfo proto.InternalMessageInfo

func (m *ActivityBaseInfo) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *ActivityBaseInfo) GetVer() int32 {
	if m != nil && m.Ver != nil {
		return *m.Ver
	}
	return 0
}

// 合体技
type CombinationSkillInfo struct {
	CdTime               *int64   `protobuf:"zigzag64,1,opt,name=cd_time" json:"cd_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CombinationSkillInfo) Reset()         { *m = CombinationSkillInfo{} }
func (m *CombinationSkillInfo) String() string { return proto.CompactTextString(m) }
func (*CombinationSkillInfo) ProtoMessage()    {}
func (*CombinationSkillInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{63}
}
func (m *CombinationSkillInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombinationSkillInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombinationSkillInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombinationSkillInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombinationSkillInfo.Merge(m, src)
}
func (m *CombinationSkillInfo) XXX_Size() int {
	return m.Size()
}
func (m *CombinationSkillInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CombinationSkillInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CombinationSkillInfo proto.InternalMessageInfo

func (m *CombinationSkillInfo) GetCdTime() int64 {
	if m != nil && m.CdTime != nil {
		return *m.CdTime
	}
	return 0
}

// 玩家副本信息
type FightRiskInfo struct {
	ChapterId            *int32   `protobuf:"zigzag32,1,opt,name=chapter_id" json:"chapter_id,omitempty"`
	DupId                *int32   `protobuf:"zigzag32,2,opt,name=dup_id" json:"dup_id,omitempty"`
	SubmitStatus         *int32   `protobuf:"zigzag32,3,opt,name=submit_status" json:"submit_status,omitempty"`
	DangerMode           *int32   `protobuf:"zigzag32,4,opt,name=danger_mode" json:"danger_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FightRiskInfo) Reset()         { *m = FightRiskInfo{} }
func (m *FightRiskInfo) String() string { return proto.CompactTextString(m) }
func (*FightRiskInfo) ProtoMessage()    {}
func (*FightRiskInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{64}
}
func (m *FightRiskInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FightRiskInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FightRiskInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FightRiskInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FightRiskInfo.Merge(m, src)
}
func (m *FightRiskInfo) XXX_Size() int {
	return m.Size()
}
func (m *FightRiskInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FightRiskInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FightRiskInfo proto.InternalMessageInfo

func (m *FightRiskInfo) GetChapterId() int32 {
	if m != nil && m.ChapterId != nil {
		return *m.ChapterId
	}
	return 0
}

func (m *FightRiskInfo) GetDupId() int32 {
	if m != nil && m.DupId != nil {
		return *m.DupId
	}
	return 0
}

func (m *FightRiskInfo) GetSubmitStatus() int32 {
	if m != nil && m.SubmitStatus != nil {
		return *m.SubmitStatus
	}
	return 0
}

func (m *FightRiskInfo) GetDangerMode() int32 {
	if m != nil && m.DangerMode != nil {
		return *m.DangerMode
	}
	return 0
}

// 玩家打开礼包的次数
type PackageCount struct {
	PackageId            *int32   `protobuf:"zigzag32,1,req,name=package_id" json:"package_id,omitempty"`
	Count                *int32   `protobuf:"zigzag32,2,req,name=count" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PackageCount) Reset()         { *m = PackageCount{} }
func (m *PackageCount) String() string { return proto.CompactTextString(m) }
func (*PackageCount) ProtoMessage()    {}
func (*PackageCount) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{65}
}
func (m *PackageCount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PackageCount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PackageCount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PackageCount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PackageCount.Merge(m, src)
}
func (m *PackageCount) XXX_Size() int {
	return m.Size()
}
func (m *PackageCount) XXX_DiscardUnknown() {
	xxx_messageInfo_PackageCount.DiscardUnknown(m)
}

var xxx_messageInfo_PackageCount proto.InternalMessageInfo

func (m *PackageCount) GetPackageId() int32 {
	if m != nil && m.PackageId != nil {
		return *m.PackageId
	}
	return 0
}

func (m *PackageCount) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

//玩家打开礼包的次数
type RoleOpenPackage struct {
	Count                []*PackageCount `protobuf:"bytes,1,rep,name=count" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RoleOpenPackage) Reset()         { *m = RoleOpenPackage{} }
func (m *RoleOpenPackage) String() string { return proto.CompactTextString(m) }
func (*RoleOpenPackage) ProtoMessage()    {}
func (*RoleOpenPackage) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{66}
}
func (m *RoleOpenPackage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleOpenPackage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleOpenPackage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleOpenPackage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleOpenPackage.Merge(m, src)
}
func (m *RoleOpenPackage) XXX_Size() int {
	return m.Size()
}
func (m *RoleOpenPackage) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleOpenPackage.DiscardUnknown(m)
}

var xxx_messageInfo_RoleOpenPackage proto.InternalMessageInfo

func (m *RoleOpenPackage) GetCount() []*PackageCount {
	if m != nil {
		return m.Count
	}
	return nil
}

// 首充相关
type ShopRecharge struct {
	Id                   *int32        `protobuf:"zigzag32,1,opt,name=id" json:"id,omitempty"`
	StartTime            *int64        `protobuf:"zigzag64,2,opt,name=start_time" json:"start_time,omitempty"`
	EndTime              *int64        `protobuf:"zigzag64,3,opt,name=end_time" json:"end_time,omitempty"`
	RewardList           []*ItemConfig `protobuf:"bytes,4,rep,name=rewardList" json:"rewardList,omitempty"`
	CostList             []*ItemConfig `protobuf:"bytes,5,rep,name=CostList" json:"CostList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ShopRecharge) Reset()         { *m = ShopRecharge{} }
func (m *ShopRecharge) String() string { return proto.CompactTextString(m) }
func (*ShopRecharge) ProtoMessage()    {}
func (*ShopRecharge) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{67}
}
func (m *ShopRecharge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShopRecharge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShopRecharge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShopRecharge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShopRecharge.Merge(m, src)
}
func (m *ShopRecharge) XXX_Size() int {
	return m.Size()
}
func (m *ShopRecharge) XXX_DiscardUnknown() {
	xxx_messageInfo_ShopRecharge.DiscardUnknown(m)
}

var xxx_messageInfo_ShopRecharge proto.InternalMessageInfo

func (m *ShopRecharge) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *ShopRecharge) GetStartTime() int64 {
	if m != nil && m.StartTime != nil {
		return *m.StartTime
	}
	return 0
}

func (m *ShopRecharge) GetEndTime() int64 {
	if m != nil && m.EndTime != nil {
		return *m.EndTime
	}
	return 0
}

func (m *ShopRecharge) GetRewardList() []*ItemConfig {
	if m != nil {
		return m.RewardList
	}
	return nil
}

func (m *ShopRecharge) GetCostList() []*ItemConfig {
	if m != nil {
		return m.CostList
	}
	return nil
}

type RoleRechargeGet struct {
	GetFlag              *int32        `protobuf:"zigzag32,1,opt,name=get_flag" json:"get_flag,omitempty"`
	Ver                  *int32        `protobuf:"zigzag32,2,opt,name=ver" json:"ver,omitempty"`
	Reward               *ShopRecharge `protobuf:"bytes,3,opt,name=reward" json:"reward,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RoleRechargeGet) Reset()         { *m = RoleRechargeGet{} }
func (m *RoleRechargeGet) String() string { return proto.CompactTextString(m) }
func (*RoleRechargeGet) ProtoMessage()    {}
func (*RoleRechargeGet) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{68}
}
func (m *RoleRechargeGet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleRechargeGet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleRechargeGet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleRechargeGet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleRechargeGet.Merge(m, src)
}
func (m *RoleRechargeGet) XXX_Size() int {
	return m.Size()
}
func (m *RoleRechargeGet) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleRechargeGet.DiscardUnknown(m)
}

var xxx_messageInfo_RoleRechargeGet proto.InternalMessageInfo

func (m *RoleRechargeGet) GetGetFlag() int32 {
	if m != nil && m.GetFlag != nil {
		return *m.GetFlag
	}
	return 0
}

func (m *RoleRechargeGet) GetVer() int32 {
	if m != nil && m.Ver != nil {
		return *m.Ver
	}
	return 0
}

func (m *RoleRechargeGet) GetReward() *ShopRecharge {
	if m != nil {
		return m.Reward
	}
	return nil
}

// 通用商品属性
type CommonShopGoodsInfo struct {
	ItemId               *int32   `protobuf:"zigzag32,1,req,name=item_id" json:"item_id,omitempty"`
	Count                *int32   `protobuf:"zigzag32,2,req,name=count" json:"count,omitempty"`
	Currency             *int32   `protobuf:"zigzag32,3,req,name=currency" json:"currency,omitempty"`
	Price                *int32   `protobuf:"zigzag32,4,req,name=price" json:"price,omitempty"`
	IsBuy                *bool    `protobuf:"varint,5,req,name=is_buy" json:"is_buy,omitempty"`
	ShopIndex            *int32   `protobuf:"zigzag32,6,req,name=shop_index" json:"shop_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommonShopGoodsInfo) Reset()         { *m = CommonShopGoodsInfo{} }
func (m *CommonShopGoodsInfo) String() string { return proto.CompactTextString(m) }
func (*CommonShopGoodsInfo) ProtoMessage()    {}
func (*CommonShopGoodsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{69}
}
func (m *CommonShopGoodsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonShopGoodsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonShopGoodsInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonShopGoodsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonShopGoodsInfo.Merge(m, src)
}
func (m *CommonShopGoodsInfo) XXX_Size() int {
	return m.Size()
}
func (m *CommonShopGoodsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonShopGoodsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CommonShopGoodsInfo proto.InternalMessageInfo

func (m *CommonShopGoodsInfo) GetItemId() int32 {
	if m != nil && m.ItemId != nil {
		return *m.ItemId
	}
	return 0
}

func (m *CommonShopGoodsInfo) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *CommonShopGoodsInfo) GetCurrency() int32 {
	if m != nil && m.Currency != nil {
		return *m.Currency
	}
	return 0
}

func (m *CommonShopGoodsInfo) GetPrice() int32 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

func (m *CommonShopGoodsInfo) GetIsBuy() bool {
	if m != nil && m.IsBuy != nil {
		return *m.IsBuy
	}
	return false
}

func (m *CommonShopGoodsInfo) GetShopIndex() int32 {
	if m != nil && m.ShopIndex != nil {
		return *m.ShopIndex
	}
	return 0
}

// 通过商店信息
type CommonShopInfo struct {
	GoodsInfo                []*CommonShopGoodsInfo `protobuf:"bytes,1,rep,name=goods_info" json:"goods_info,omitempty"`
	ShopNextRefreshTimestamp *int64                 `protobuf:"zigzag64,2,opt,name=shop_next_refresh_timestamp" json:"shop_next_refresh_timestamp,omitempty"`
	ServerRefreshCount       *int32                 `protobuf:"zigzag32,3,opt,name=server_refresh_count" json:"server_refresh_count,omitempty"`
	ManualRefreshCount       *int32                 `protobuf:"zigzag32,4,opt,name=manual_refresh_count" json:"manual_refresh_count,omitempty"`
	ManualTotalRefreshCount  *int32                 `protobuf:"zigzag32,5,opt,name=manual_total_refresh_count" json:"manual_total_refresh_count,omitempty"`
	XXX_NoUnkeyedLiteral     struct{}               `json:"-"`
	XXX_unrecognized         []byte                 `json:"-"`
	XXX_sizecache            int32                  `json:"-"`
}

func (m *CommonShopInfo) Reset()         { *m = CommonShopInfo{} }
func (m *CommonShopInfo) String() string { return proto.CompactTextString(m) }
func (*CommonShopInfo) ProtoMessage()    {}
func (*CommonShopInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0bf06cdc6a0a2b1, []int{70}
}
func (m *CommonShopInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonShopInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonShopInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonShopInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonShopInfo.Merge(m, src)
}
func (m *CommonShopInfo) XXX_Size() int {
	return m.Size()
}
func (m *CommonShopInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonShopInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CommonShopInfo proto.InternalMessageInfo

func (m *CommonShopInfo) GetGoodsInfo() []*CommonShopGoodsInfo {
	if m != nil {
		return m.GoodsInfo
	}
	return nil
}

func (m *CommonShopInfo) GetShopNextRefreshTimestamp() int64 {
	if m != nil && m.ShopNextRefreshTimestamp != nil {
		return *m.ShopNextRefreshTimestamp
	}
	return 0
}

func (m *CommonShopInfo) GetServerRefreshCount() int32 {
	if m != nil && m.ServerRefreshCount != nil {
		return *m.ServerRefreshCount
	}
	return 0
}

func (m *CommonShopInfo) GetManualRefreshCount() int32 {
	if m != nil && m.ManualRefreshCount != nil {
		return *m.ManualRefreshCount
	}
	return 0
}

func (m *CommonShopInfo) GetManualTotalRefreshCount() int32 {
	if m != nil && m.ManualTotalRefreshCount != nil {
		return *m.ManualTotalRefreshCount
	}
	return 0
}

func init() {
	proto.RegisterType((*UniversalData)(nil), "pbd.universal_data")
	proto.RegisterType((*LuaPos)(nil), "pbd.lua_pos")
	proto.RegisterType((*DbBagItem)(nil), "pbd.db_bag_item")
	proto.RegisterType((*ListDbBagItems)(nil), "pbd.list_db_bag_items")
	proto.RegisterType((*DbBagEquip)(nil), "pbd.db_bag_equip")
	proto.RegisterType((*DbRoleEquip)(nil), "pbd.db_role_equip")
	proto.RegisterType((*EquipExtraPer)(nil), "pbd.equip_extra_per")
	proto.RegisterType((*DbFixEquip)(nil), "pbd.db_fix_equip")
	proto.RegisterType((*ListDbFixEquips)(nil), "pbd.list_db_fix_equips")
	proto.RegisterType((*ListDbBagEquips)(nil), "pbd.list_db_bag_equips")
	proto.RegisterType((*ListDbRoleEquips)(nil), "pbd.list_db_role_equips")
	proto.RegisterType((*RewardInfo)(nil), "pbd.reward_info")
	proto.RegisterType((*DbFriendInfo)(nil), "pbd.db_friend_info")
	proto.RegisterType((*DbArenaKillInfo)(nil), "pbd.db_arena_kill_info")
	proto.RegisterType((*RoleFace)(nil), "pbd.role_face")
	proto.RegisterType((*MinigameRecord)(nil), "pbd.minigame_record")
	proto.RegisterType((*MinigamePlayInfo)(nil), "pbd.minigame_play_info")
	proto.RegisterType((*PlayerShowInfo)(nil), "pbd.player_show_info")
	proto.RegisterType((*PlayerValueInfo)(nil), "pbd.player_value_info")
	proto.RegisterType((*VisitingCardInfo)(nil), "pbd.visiting_card_info")
	proto.RegisterType((*ArenaPlayerInfo)(nil), "pbd.arena_player_info")
	proto.RegisterType((*BattleSkillInfo)(nil), "pbd.battle_skill_info")
	proto.RegisterType((*BattlePlayerInfo)(nil), "pbd.battle_player_info")
	proto.RegisterType((*ArenaBattleInfo)(nil), "pbd.arena_battle_info")
	proto.RegisterType((*RankInfo)(nil), "pbd.RankInfo")
	proto.RegisterType((*SkillUseInfo)(nil), "pbd.SkillUseInfo")
	proto.RegisterType((*DbDailyTaskInfo)(nil), "pbd.db_daily_task_info")
	proto.RegisterType((*DbDailyActivityPerLevelInfo)(nil), "pbd.db_daily_activity_per_level_info")
	proto.RegisterType((*DbDailyActivityInfo)(nil), "pbd.db_daily_activity_info")
	proto.RegisterType((*LuaRect)(nil), "pbd.lua_rect")
	proto.RegisterType((*LuaPosRect)(nil), "pbd.lua_pos_rect")
	proto.RegisterType((*ItemConfig)(nil), "pbd.item_config")
	proto.RegisterType((*FaceConfig)(nil), "pbd.face_config")
	proto.RegisterType((*SuitConfig)(nil), "pbd.suit_config")
	proto.RegisterType((*MinosMailTitle)(nil), "pbd.minos_mail_title")
	proto.RegisterType((*MinosMail)(nil), "pbd.minos_mail")
	proto.RegisterType((*InteractNpc)(nil), "pbd.interact_npc")
	proto.RegisterType((*InteractCount)(nil), "pbd.interact_count")
	proto.RegisterType((*InteractUnlock)(nil), "pbd.interact_unlock")
	proto.RegisterType((*LevelNeed)(nil), "pbd.level_need")
	proto.RegisterType((*ItemNeed)(nil), "pbd.item_need")
	proto.RegisterType((*SpInfo)(nil), "pbd.sp_info")
	proto.RegisterType((*RoleCustomFace)(nil), "pbd.role_custom_face")
	proto.RegisterType((*PetBaseFight)(nil), "pbd.pet_base_fight")
	proto.RegisterType((*PetTalent)(nil), "pbd.pet_talent")
	proto.RegisterType((*PetInfo)(nil), "pbd.pet_info")
	proto.RegisterType((*PetRefresh)(nil), "pbd.pet_refresh")
	proto.RegisterType((*HorseEvent)(nil), "pbd.horse_event")
	proto.RegisterType((*ItemListConfig)(nil), "pbd.item_list_config")
	proto.RegisterType((*HorseLightInfo)(nil), "pbd.horse_light_info")
	proto.RegisterType((*SuccessDetail)(nil), "pbd.success_detail")
	proto.RegisterType((*GuadraticResult)(nil), "pbd.guadratic_result")
	proto.RegisterType((*GuadraticRoleInfo)(nil), "pbd.guadratic_role_info")
	proto.RegisterType((*GuadraticRoleHp)(nil), "pbd.guadratic_role_hp")
	proto.RegisterType((*GuadraticRoleCd)(nil), "pbd.guadratic_role_cd")
	proto.RegisterType((*SellInfo)(nil), "pbd.sell_info")
	proto.RegisterType((*RedeemCodeInfo)(nil), "pbd.redeem_code_info")
	proto.RegisterType((*RedeemGiftInfo)(nil), "pbd.redeem_gift_info")
	proto.RegisterType((*ActivitySummary)(nil), "pbd.activity_summary")
	proto.RegisterType((*ActivityRule)(nil), "pbd.activity_rule")
	proto.RegisterType((*ActivityInfo)(nil), "pbd.activity_info")
	proto.RegisterType((*ActivityProgressInfo)(nil), "pbd.activity_progress_info")
	proto.RegisterType((*ActivityBaseInfo)(nil), "pbd.activity_base_info")
	proto.RegisterType((*CombinationSkillInfo)(nil), "pbd.combination_skill_info")
	proto.RegisterType((*FightRiskInfo)(nil), "pbd.fight_risk_info")
	proto.RegisterType((*PackageCount)(nil), "pbd.package_count")
	proto.RegisterType((*RoleOpenPackage)(nil), "pbd.role_open_package")
	proto.RegisterType((*ShopRecharge)(nil), "pbd.shop_recharge")
	proto.RegisterType((*RoleRechargeGet)(nil), "pbd.role_recharge_get")
	proto.RegisterType((*CommonShopGoodsInfo)(nil), "pbd.common_shop_goods_info")
	proto.RegisterType((*CommonShopInfo)(nil), "pbd.common_shop_info")
}

func init() { proto.RegisterFile("ProtoDef.proto", fileDescriptor_a0bf06cdc6a0a2b1) }

var fileDescriptor_a0bf06cdc6a0a2b1 = []byte{
	// 2818 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xdd, 0x8e, 0xdb, 0xc6,
	0xf5, 0xff, 0x53, 0x94, 0x76, 0x57, 0x47, 0x1f, 0x2b, 0xd1, 0xf6, 0x86, 0xf9, 0x80, 0xa1, 0x3f,
	0x63, 0xc7, 0xb2, 0xdd, 0xb8, 0xe8, 0x3a, 0x75, 0x11, 0xa0, 0x1f, 0x68, 0xd2, 0x45, 0xe2, 0x20,
	0x6d, 0xd2, 0xd8, 0x09, 0x9a, 0xde, 0x4c, 0x47, 0xe4, 0x48, 0x22, 0x96, 0x22, 0x69, 0xce, 0x70,
	0xbd, 0x2a, 0x10, 0x14, 0xbd, 0x2b, 0xd0, 0x17, 0x28, 0xfa, 0x02, 0xbd, 0x68, 0x2f, 0xfa, 0x18,
	0xb9, 0x29, 0xd0, 0x47, 0x08, 0xdc, 0x77, 0x68, 0x2f, 0x7a, 0x53, 0x9c, 0x33, 0x33, 0xfc, 0xd8,
	0x5d, 0x19, 0xe8, 0x5d, 0xaf, 0x24, 0x1e, 0x9e, 0x99, 0xf3, 0x7d, 0xce, 0xef, 0x10, 0xc6, 0x9f,
	0x16, 0x99, 0xca, 0x7e, 0x22, 0x96, 0x0f, 0x72, 0xfc, 0xe3, 0xb9, 0xf9, 0x22, 0x7a, 0x6d, 0x74,
	0x92, 0x96, 0x9b, 0x8a, 0x16, 0x7c, 0xed, 0xc0, 0xb8, 0x4c, 0xe3, 0x33, 0x51, 0x48, 0x9e, 0xb0,
	0x88, 0x2b, 0xee, 0x0d, 0xc0, 0x3d, 0x15, 0x5b, 0xdf, 0x99, 0x75, 0xe6, 0xae, 0x37, 0x84, 0xae,
	0xda, 0xe6, 0xc2, 0xef, 0xcc, 0x3a, 0xf3, 0x21, 0x3e, 0xa5, 0x7c, 0x23, 0x7c, 0x97, 0x9e, 0xfa,
	0xe0, 0x2c, 0xfc, 0xee, 0xcc, 0x9d, 0x1f, 0xe0, 0xdf, 0xa5, 0xdf, 0x9b, 0xb9, 0xf3, 0x0e, 0xfe,
	0x8d, 0xfc, 0xbd, 0x99, 0x3b, 0x77, 0xf0, 0xaf, 0xf0, 0xf7, 0x67, 0xee, 0x7c, 0x8a, 0x97, 0xc6,
	0x0f, 0x8f, 0xfd, 0x83, 0xea, 0xe1, 0xd1, 0x3b, 0x7e, 0x7f, 0xe6, 0xce, 0x3d, 0x7c, 0x28, 0x1f,
	0x1e, 0xfb, 0x30, 0x73, 0xe7, 0x23, 0x7a, 0x78, 0xf4, 0x8e, 0x3f, 0x98, 0xb9, 0xf3, 0x2e, 0x3e,
	0x48, 0x55, 0xf8, 0xc3, 0x99, 0x3b, 0x1f, 0x7a, 0x33, 0x70, 0x65, 0xb9, 0xf0, 0x47, 0x33, 0x77,
	0x3e, 0x38, 0xbe, 0xf6, 0x20, 0x5f, 0x44, 0x0f, 0xda, 0x7a, 0x07, 0x77, 0x60, 0x3f, 0x29, 0x39,
	0xcb, 0x33, 0xe9, 0x8d, 0xa0, 0x97, 0x67, 0x92, 0x9d, 0x93, 0x11, 0x53, 0xfb, 0xb8, 0x25, 0x2b,
	0xa6, 0xc1, 0x2f, 0x61, 0x10, 0x2d, 0xd8, 0x82, 0xaf, 0x58, 0xac, 0xc4, 0xc6, 0xf3, 0x00, 0xf0,
	0x97, 0xc5, 0x69, 0x24, 0xf4, 0x09, 0xcf, 0x3b, 0x84, 0x7d, 0x4d, 0x8b, 0xf4, 0x99, 0x8a, 0x29,
	0xcc, 0xca, 0x54, 0x91, 0xfd, 0x1e, 0xd1, 0x24, 0x53, 0x59, 0x19, 0xae, 0x45, 0xe4, 0x77, 0x67,
	0x9d, 0xf9, 0x41, 0xf0, 0x3d, 0x98, 0x26, 0xb1, 0x54, 0xac, 0x21, 0x40, 0x7a, 0x01, 0x1c, 0xd8,
	0x07, 0xdf, 0x21, 0x03, 0x26, 0x64, 0x40, 0x83, 0x29, 0xf8, 0xc6, 0x81, 0xa1, 0x79, 0x16, 0xcf,
	0xca, 0x38, 0xf7, 0xae, 0xc1, 0x80, 0xfe, 0xb4, 0xf4, 0x9a, 0xc0, 0x81, 0x21, 0x5a, 0xc5, 0x46,
	0xd0, 0x4b, 0xc4, 0x99, 0x48, 0x48, 0xa7, 0xa9, 0x37, 0x86, 0x3d, 0xae, 0x14, 0x0f, 0x4f, 0x49,
	0x9f, 0xa9, 0x37, 0x85, 0xbe, 0x48, 0xa3, 0xb2, 0xe0, 0x69, 0x28, 0xfc, 0x1e, 0x91, 0x0e, 0x61,
	0xff, 0x59, 0xc9, 0x93, 0x58, 0x6d, 0xfd, 0x3d, 0x22, 0xdc, 0x85, 0xbe, 0x8c, 0x95, 0x60, 0x14,
	0xe8, 0xfd, 0x59, 0x67, 0x3e, 0x3e, 0x3e, 0x22, 0xfd, 0x4e, 0xd8, 0xc9, 0xcf, 0x3f, 0x7f, 0xfc,
	0x29, 0x7b, 0xf2, 0xf8, 0xe9, 0x09, 0x7b, 0xfa, 0xe5, 0xa7, 0x27, 0x17, 0x4c, 0x3e, 0x40, 0x93,
	0xbd, 0x3b, 0xd0, 0x17, 0xe7, 0xaa, 0xe0, 0x2c, 0x17, 0x85, 0xdf, 0x9f, 0x39, 0xf3, 0xc1, 0xf1,
	0x75, 0x3a, 0xae, 0x35, 0xad, 0xde, 0x05, 0x7f, 0x73, 0x60, 0x14, 0x2d, 0x58, 0x91, 0x25, 0xe2,
	0x7f, 0xd9, 0xc6, 0x96, 0x3d, 0x07, 0x2f, 0xb1, 0xe7, 0x2b, 0x38, 0xbc, 0x40, 0x42, 0x55, 0x96,
	0xf1, 0x6a, 0xad, 0xe8, 0xac, 0x63, 0x55, 0x89, 0xc4, 0x92, 0x08, 0xda, 0x9a, 0x09, 0x1c, 0x84,
	0x45, 0xac, 0x59, 0x5c, 0x6b, 0xc0, 0x22, 0xc9, 0xc2, 0x53, 0x22, 0x55, 0x36, 0xc9, 0x5c, 0x88,
	0x88, 0x48, 0x3d, 0x6b, 0xf6, 0x3a, 0xa7, 0x67, 0x32, 0x29, 0x78, 0x46, 0x09, 0xb3, 0x8c, 0xcf,
	0x8d, 0x33, 0x8f, 0x60, 0xbc, 0x2c, 0x93, 0x84, 0xd5, 0xbe, 0x70, 0xac, 0x3c, 0x64, 0x52, 0xf1,
	0x46, 0x97, 0xb1, 0x87, 0x97, 0xa7, 0x78, 0x37, 0x91, 0xb4, 0x0a, 0xb7, 0xa0, 0x5f, 0xa5, 0x1e,
	0xa9, 0x30, 0x38, 0x9e, 0x36, 0x73, 0x94, 0x5e, 0x04, 0xef, 0x82, 0x67, 0xb3, 0xbb, 0x92, 0x2b,
	0xbd, 0x37, 0xb5, 0x80, 0x38, 0x5d, 0x66, 0x26, 0xbd, 0xab, 0xa3, 0x15, 0x57, 0xf0, 0x47, 0xa7,
	0x3e, 0x5b, 0x5d, 0x28, 0xdb, 0x72, 0x2f, 0x1c, 0xae, 0x6b, 0xe1, 0x08, 0xc6, 0x09, 0x97, 0x8a,
	0x15, 0xe2, 0x39, 0x2f, 0x22, 0x9d, 0x18, 0xce, 0x7c, 0xea, 0xdd, 0x80, 0x91, 0x4d, 0x15, 0x86,
	0x97, 0xfb, 0x2e, 0xf5, 0x97, 0x1b, 0x30, 0xc2, 0xb3, 0x61, 0x59, 0x14, 0x4c, 0xc6, 0xbf, 0x16,
	0x7e, 0x97, 0xb8, 0x7d, 0x98, 0xd0, 0x95, 0xe7, 0x4a, 0xa4, 0x91, 0xa9, 0xe4, 0x1e, 0xbe, 0x09,
	0x7e, 0x00, 0xd7, 0xac, 0x6e, 0x75, 0x76, 0x4a, 0xef, 0x2d, 0x80, 0xfa, 0xd1, 0x68, 0xe7, 0x59,
	0xed, 0xea, 0x37, 0xc1, 0x1c, 0x06, 0x56, 0xb3, 0x74, 0x99, 0x79, 0x00, 0x9d, 0x38, 0xaa, 0x5b,
	0x8f, 0x16, 0xa4, 0x5b, 0xcf, 0x6f, 0x1d, 0x18, 0xa3, 0x5b, 0x8a, 0x18, 0x55, 0x20, 0x6e, 0xcf,
	0x08, 0x69, 0x96, 0xc0, 0x08, 0x7a, 0x52, 0x71, 0xd5, 0x68, 0xbb, 0x55, 0xa8, 0xa8, 0xed, 0x24,
	0xd9, 0x2a, 0x4e, 0x75, 0xf8, 0xba, 0x44, 0xbb, 0x07, 0xfd, 0xd0, 0xca, 0xa7, 0x74, 0x19, 0x1c,
	0xbf, 0x42, 0x8a, 0x9e, 0xc5, 0x32, 0x56, 0x71, 0xba, 0x62, 0xd5, 0xeb, 0x40, 0x80, 0x17, 0x2d,
	0x18, 0x2f, 0x44, 0xca, 0xd9, 0x69, 0x9c, 0x24, 0xbb, 0xd5, 0x98, 0x42, 0x9f, 0x18, 0x22, 0xab,
	0xca, 0xd4, 0x9b, 0x43, 0x5f, 0xae, 0xb3, 0xe7, 0x5a, 0x90, 0x4b, 0x82, 0x6e, 0x90, 0xa0, 0x3c,
	0xe1, 0x5b, 0x51, 0xb0, 0xea, 0x65, 0x70, 0x0f, 0xfa, 0x74, 0xe1, 0x92, 0x87, 0xa2, 0x1a, 0x23,
	0x55, 0x49, 0x20, 0xb5, 0x8a, 0x63, 0xc0, 0xe0, 0x70, 0x13, 0xa7, 0xf1, 0x8a, 0x6f, 0x04, 0x2b,
	0x44, 0x98, 0x15, 0x91, 0xf7, 0x2a, 0x4c, 0xd7, 0xb1, 0x54, 0x59, 0xb1, 0x65, 0x1b, 0x7e, 0xce,
	0x64, 0x98, 0x15, 0x78, 0x1c, 0xe3, 0xf8, 0x0a, 0x1c, 0xaa, 0x2c, 0xe2, 0xcd, 0x17, 0x1d, 0x1b,
	0x60, 0x7b, 0x46, 0x65, 0x39, 0x2b, 0x78, 0x7a, 0xea, 0xbb, 0x24, 0x60, 0x0d, 0x5e, 0x25, 0x00,
	0x35, 0xd5, 0x36, 0xdf, 0x85, 0x01, 0x3d, 0x68, 0x91, 0x26, 0xc0, 0xba, 0xd6, 0x2f, 0xaa, 0x73,
	0x03, 0x46, 0x28, 0x71, 0x51, 0x6e, 0x99, 0x8d, 0xa7, 0xa3, 0x6b, 0x6b, 0x25, 0x14, 0x5b, 0x26,
	0x7c, 0x65, 0x24, 0xfd, 0xae, 0x03, 0x93, 0x8b, 0xbe, 0xa8, 0x1b, 0x58, 0x65, 0xff, 0x59, 0x9c,
	0xb3, 0xe4, 0x2c, 0x31, 0x5e, 0x1d, 0xc3, 0xde, 0x4a, 0xa4, 0x51, 0xb3, 0x21, 0xa4, 0x71, 0x78,
	0xca, 0x68, 0xd8, 0x76, 0x29, 0x07, 0xa6, 0xd0, 0x5f, 0x8b, 0x64, 0x23, 0x14, 0x7a, 0xad, 0x67,
	0x67, 0x52, 0x98, 0x64, 0x6a, 0x2d, 0x24, 0xd2, 0xf6, 0x6c, 0xb1, 0xcb, 0x75, 0xa6, 0x29, 0xfb,
	0x56, 0xd8, 0x73, 0x4c, 0x80, 0x58, 0xf7, 0x6b, 0xba, 0xfc, 0xb9, 0xe0, 0x79, 0x96, 0x22, 0xa9,
	0x6f, 0x6f, 0x3a, 0x13, 0xeb, 0x38, 0x4c, 0x28, 0x26, 0x60, 0xcf, 0xc9, 0x32, 0x26, 0x71, 0x03,
	0x22, 0xbc, 0x01, 0x5d, 0x8c, 0x9a, 0x3f, 0xa4, 0xa8, 0x8f, 0xc9, 0x4d, 0x75, 0x84, 0xa7, 0xd0,
	0x37, 0x66, 0xc7, 0x91, 0x3f, 0x42, 0x95, 0x03, 0x05, 0x53, 0x43, 0x3a, 0xe3, 0x49, 0x29, 0xaa,
	0xe2, 0x58, 0xe7, 0xc6, 0x0f, 0x03, 0x70, 0xb9, 0x3a, 0x35, 0x3e, 0x18, 0x80, 0x1b, 0x89, 0xa5,
	0x71, 0xc0, 0x10, 0xba, 0xd8, 0x23, 0x4d, 0x33, 0x1c, 0x41, 0x8f, 0xfa, 0xa3, 0xb1, 0x1b, 0xab,
	0x03, 0x7b, 0xa3, 0x31, 0x79, 0x04, 0x3d, 0xea, 0xb9, 0xfe, 0x3e, 0x05, 0xe0, 0x2f, 0x0e, 0x78,
	0x97, 0xb3, 0xbe, 0x9d, 0xb8, 0x0e, 0x75, 0xf5, 0xab, 0x13, 0xd7, 0xbb, 0xaf, 0xb3, 0x02, 0x2d,
	0x41, 0xde, 0x0e, 0xf1, 0x1e, 0x35, 0x79, 0x1b, 0xe6, 0xb4, 0xcb, 0x06, 0x53, 0xc0, 0xf3, 0xee,
	0xc3, 0xa8, 0x9a, 0x08, 0xa1, 0x48, 0x15, 0xb5, 0x9f, 0x5d, 0x43, 0xe4, 0x13, 0x98, 0xea, 0x52,
	0x6c, 0xc8, 0x44, 0xf3, 0x29, 0x79, 0xb5, 0x9b, 0xbe, 0x75, 0x51, 0xa1, 0x97, 0x96, 0xf7, 0x8f,
	0x60, 0xba, 0xe0, 0x4a, 0x25, 0x82, 0xc9, 0xba, 0xba, 0x2f, 0xb4, 0x24, 0x9d, 0x8c, 0x9d, 0x2a,
	0xce, 0xc8, 0x28, 0x22, 0xed, 0xfb, 0xe0, 0x9f, 0x0e, 0x78, 0xe6, 0x86, 0xa6, 0x4e, 0x0f, 0x60,
	0xd4, 0x92, 0x66, 0x9c, 0xb8, 0x4b, 0x0f, 0xef, 0x1e, 0x80, 0x56, 0x80, 0x1a, 0x73, 0x87, 0x6a,
	0x4b, 0x7b, 0xf1, 0xb2, 0x7a, 0xc8, 0x8b, 0xb9, 0x46, 0x24, 0xf2, 0xe2, 0x6e, 0xde, 0xa9, 0x69,
	0x75, 0x74, 0x6d, 0x97, 0xfa, 0xfd, 0x04, 0x0e, 0xf2, 0x0c, 0x15, 0xc8, 0x52, 0xdd, 0xd0, 0x91,
	0x89, 0x87, 0x4a, 0x07, 0xca, 0xdf, 0x23, 0xd2, 0xac, 0x1e, 0xcd, 0x3a, 0x55, 0x06, 0xc7, 0x23,
	0x1d, 0x54, 0xac, 0x29, 0xf4, 0xdc, 0x47, 0x36, 0x14, 0x46, 0x28, 0x89, 0xbb, 0x03, 0x7b, 0xda,
	0x0b, 0xe4, 0x3d, 0x6b, 0xef, 0x15, 0xfe, 0xb1, 0x31, 0xd3, 0x8d, 0x7e, 0x05, 0x07, 0x9f, 0xf1,
	0xf4, 0xf4, 0xf1, 0xae, 0xd6, 0x7a, 0xef, 0xaa, 0x98, 0xee, 0x48, 0x48, 0x7b, 0xb3, 0x5b, 0x65,
	0x3f, 0xf5, 0x3c, 0xea, 0xfc, 0xc1, 0x77, 0x61, 0xf8, 0x04, 0x9d, 0xf3, 0xb9, 0x14, 0x24, 0x0c,
	0x1b, 0x80, 0x76, 0x96, 0x8d, 0xf7, 0x35, 0x18, 0x68, 0x4a, 0x73, 0x10, 0x2d, 0x68, 0x08, 0x44,
	0x3c, 0x4e, 0xb6, 0x4c, 0x71, 0x79, 0x5a, 0x49, 0x6a, 0xb4, 0x69, 0x9d, 0x34, 0x9d, 0xf6, 0x1c,
	0xab, 0x1a, 0x94, 0xca, 0x94, 0xb9, 0xb1, 0x6b, 0x3b, 0x4f, 0xd5, 0x0a, 0x7b, 0x84, 0x85, 0xdf,
	0x87, 0x59, 0x25, 0x83, 0x87, 0x2a, 0x3e, 0x8b, 0xd5, 0x16, 0x73, 0x9e, 0x51, 0xfa, 0x5d, 0xd1,
	0x19, 0x7b, 0xad, 0x4b, 0x3a, 0x74, 0xc9, 0x33, 0x38, 0xba, 0x7c, 0x09, 0x1d, 0x7d, 0x03, 0xae,
	0xab, 0x4c, 0xf1, 0x84, 0xf1, 0x33, 0x43, 0xd6, 0xe1, 0xd6, 0xca, 0xbf, 0x0b, 0x50, 0x8b, 0x31,
	0xe9, 0x77, 0xdb, 0xce, 0xee, 0x97, 0xea, 0x14, 0x3c, 0x82, 0x03, 0x5c, 0x24, 0x0a, 0x11, 0x2a,
	0x5c, 0x61, 0xec, 0x16, 0xd1, 0x07, 0xc7, 0x6c, 0x10, 0xf8, 0xf7, 0xb9, 0xf1, 0x44, 0x1f, 0x9c,
	0xb5, 0xf6, 0x40, 0xf0, 0x33, 0x18, 0x9a, 0x05, 0x44, 0x9f, 0xc5, 0xca, 0x52, 0xbc, 0x50, 0xd5,
	0x1e, 0x52, 0x11, 0xb6, 0xb5, 0x57, 0x11, 0x07, 0x9c, 0xd7, 0xa1, 0xc5, 0xc7, 0xad, 0xb9, 0xef,
	0x18, 0x06, 0x66, 0xe7, 0x48, 0x97, 0xf1, 0xaa, 0xb9, 0x93, 0x38, 0x57, 0xec, 0x24, 0x3a, 0xae,
	0xdf, 0x81, 0x01, 0x8d, 0xd6, 0x5d, 0x67, 0xa6, 0xd0, 0x27, 0x42, 0x85, 0x06, 0xe9, 0x08, 0x15,
	0xdf, 0x7f, 0x71, 0xe4, 0x57, 0x30, 0xd9, 0xc4, 0x69, 0x26, 0xd9, 0x86, 0xc7, 0x09, 0x53, 0xb1,
	0x4a, 0x04, 0x6a, 0x43, 0x4f, 0xcd, 0x2c, 0xb7, 0x34, 0xe2, 0x30, 0x60, 0x66, 0x0a, 0x7d, 0x43,
	0xab, 0x10, 0x4d, 0x45, 0xc2, 0xdc, 0x23, 0xac, 0x16, 0xfc, 0xdb, 0x01, 0xa8, 0x45, 0x20, 0x00,
	0x94, 0x45, 0xc8, 0x2e, 0x95, 0xd1, 0x11, 0x8c, 0x15, 0x2f, 0x9a, 0x74, 0x8d, 0x70, 0xef, 0xb6,
	0x04, 0x37, 0x71, 0xca, 0x25, 0xbd, 0x2b, 0xe1, 0xe2, 0x5c, 0x99, 0x59, 0x7b, 0x17, 0x0e, 0x89,
	0x44, 0x98, 0x90, 0x56, 0x38, 0xda, 0x6d, 0xed, 0xda, 0xd6, 0x0c, 0x4a, 0x8b, 0x15, 0x3d, 0x2f,
	0x69, 0xf7, 0xb5, 0xac, 0xcd, 0x58, 0xb4, 0x58, 0xd1, 0xe3, 0x92, 0x76, 0x63, 0xcb, 0xda, 0x88,
	0x41, 0xf0, 0x36, 0x0c, 0xe3, 0x54, 0x89, 0x02, 0x7b, 0x58, 0x9a, 0x87, 0x88, 0x0f, 0xd2, 0x3c,
	0x64, 0xbb, 0x50, 0xe5, 0x7d, 0x18, 0x57, 0xec, 0x44, 0x7f, 0x19, 0x04, 0xbd, 0x05, 0x87, 0x15,
	0x73, 0x99, 0xe2, 0x58, 0xa5, 0x96, 0x9a, 0xa5, 0x91, 0x6e, 0xa0, 0x88, 0x82, 0xa6, 0xc1, 0x43,
	0x5b, 0x3e, 0xb8, 0x28, 0x10, 0x43, 0x69, 0x6a, 0xa4, 0x4e, 0x3e, 0xda, 0x21, 0x1a, 0xa3, 0x24,
	0xf8, 0xa1, 0xc9, 0x14, 0x3a, 0xd3, 0x54, 0xc1, 0x9c, 0xaf, 0xd5, 0xf0, 0xaa, 0xf3, 0x8d, 0x85,
	0x1a, 0x37, 0x78, 0x99, 0x57, 0x7d, 0x41, 0xe6, 0x2d, 0x83, 0xa5, 0xe2, 0x9b, 0x5c, 0x1f, 0x0e,
	0x8e, 0x61, 0x42, 0x21, 0x0f, 0x4b, 0xa9, 0xb2, 0x8d, 0x06, 0x20, 0x0d, 0x50, 0x59, 0x9d, 0x39,
	0xe3, 0x89, 0xed, 0x60, 0xc1, 0x02, 0xc6, 0xd8, 0xe9, 0x17, 0x5c, 0x0a, 0x46, 0x83, 0xa0, 0x01,
	0x45, 0xbc, 0x26, 0x14, 0xf1, 0x9a, 0x50, 0xc4, 0x6b, 0x41, 0x11, 0xaf, 0x0d, 0x45, 0xbc, 0x36,
	0x14, 0xf1, 0x82, 0x07, 0x00, 0x28, 0x43, 0xf1, 0x44, 0xa4, 0x8a, 0x9a, 0x24, 0xfd, 0x63, 0x3b,
	0x66, 0x6f, 0xf0, 0x67, 0x07, 0x0e, 0xec, 0xf8, 0xc1, 0x20, 0xe7, 0x62, 0x27, 0x2f, 0x2a, 0x25,
	0xce, 0x73, 0xa3, 0xd4, 0x5b, 0xb8, 0x36, 0x49, 0xc1, 0xb8, 0x52, 0x85, 0x59, 0xd7, 0xae, 0x55,
	0xc3, 0xac, 0x61, 0xe2, 0x2d, 0x18, 0x50, 0x97, 0x13, 0x7a, 0x5c, 0xea, 0x2c, 0x3e, 0xac, 0x38,
	0x8d, 0xa2, 0xb7, 0x61, 0x98, 0x73, 0x29, 0x2b, 0xb6, 0xbd, 0x2b, 0xd9, 0x82, 0xdf, 0xc0, 0x00,
	0x9f, 0x0a, 0xb1, 0x2c, 0x84, 0x5c, 0xa3, 0xbe, 0xb8, 0xa4, 0x94, 0xd2, 0xc0, 0xf2, 0x9b, 0x70,
	0x94, 0x8a, 0xf3, 0xea, 0x3d, 0x15, 0xb8, 0x0d, 0x1a, 0xc2, 0xa2, 0xda, 0x3e, 0xd7, 0x62, 0x67,
	0x19, 0x8a, 0x94, 0x22, 0xd6, 0x35, 0x37, 0xe0, 0x1c, 0xb7, 0x4b, 0x0c, 0x4e, 0xe8, 0x21, 0xe9,
	0x60, 0xba, 0x6a, 0xf0, 0x01, 0x0c, 0xd6, 0x59, 0x21, 0x05, 0x13, 0x67, 0x5a, 0x6d, 0x3b, 0xad,
	0x9c, 0xf9, 0xd8, 0x0c, 0xe6, 0x13, 0xf6, 0xe1, 0x27, 0x9f, 0x3d, 0x39, 0x61, 0x1f, 0x3f, 0xfe,
	0xe0, 0xc3, 0xa7, 0x7a, 0x9f, 0x47, 0x64, 0xca, 0x0b, 0x5e, 0xe3, 0x10, 0xca, 0x1f, 0x4a, 0x54,
	0x2a, 0x45, 0x53, 0x9e, 0x37, 0xa1, 0x7b, 0xe9, 0x03, 0x4d, 0xa3, 0xd2, 0x83, 0x8f, 0x60, 0xa2,
	0x85, 0x27, 0x84, 0x22, 0x62, 0x33, 0x6c, 0x35, 0xad, 0x99, 0xe9, 0x35, 0x72, 0x47, 0xbb, 0x87,
	0x6d, 0xf9, 0x2e, 0xc9, 0xff, 0x3e, 0x8c, 0x65, 0x19, 0x86, 0x42, 0x4a, 0x16, 0x09, 0x85, 0x0d,
	0xee, 0x06, 0x8c, 0x2c, 0x45, 0x57, 0x84, 0x4e, 0x4b, 0x9c, 0xdd, 0x86, 0x9c, 0x96, 0x1b, 0xed,
	0x48, 0x5c, 0xa5, 0x27, 0xab, 0x92, 0x47, 0x05, 0x57, 0x71, 0xc8, 0x0a, 0x21, 0xcb, 0x44, 0x79,
	0x6f, 0x42, 0x17, 0x11, 0x83, 0x41, 0x29, 0x3b, 0x90, 0xc4, 0x14, 0xfa, 0x09, 0x46, 0xb9, 0x6e,
	0xe5, 0x68, 0x02, 0x81, 0x03, 0xbc, 0xde, 0xb5, 0x2b, 0x5e, 0xe5, 0x1c, 0x93, 0x5b, 0x37, 0x6a,
	0x6f, 0x34, 0x5d, 0xd6, 0x06, 0x36, 0x54, 0x11, 0xc1, 0x2f, 0xe0, 0x5a, 0x43, 0xb7, 0x2c, 0x11,
	0xbb, 0xd7, 0xcb, 0x57, 0xc1, 0xcd, 0x33, 0x69, 0x00, 0x76, 0x2b, 0xd2, 0xb4, 0xda, 0x94, 0x45,
	0x81, 0xb5, 0xb3, 0xce, 0x0d, 0x2e, 0x7d, 0x08, 0xd3, 0x0b, 0x37, 0xaf, 0xf3, 0x2b, 0xef, 0xd5,
	0x75, 0xdd, 0xd9, 0x71, 0x28, 0x8c, 0x76, 0x1d, 0x0a, 0x6d, 0xab, 0xb8, 0x03, 0x7d, 0x29, 0x92,
	0x1a, 0xa1, 0x34, 0xf9, 0x06, 0xe0, 0xea, 0x48, 0x20, 0xe3, 0x9f, 0x1c, 0x98, 0x14, 0x22, 0x12,
	0x94, 0x25, 0x91, 0xa8, 0x40, 0x14, 0x3e, 0x10, 0xff, 0x10, 0xfd, 0xbb, 0xe0, 0x2a, 0x5c, 0xb3,
	0x34, 0x33, 0x03, 0xf0, 0x3a, 0x0c, 0x79, 0x48, 0x41, 0xd6, 0x03, 0xcf, 0x25, 0xe4, 0x83, 0x91,
	0x16, 0xc5, 0x99, 0x28, 0x58, 0x51, 0x26, 0x1a, 0xdc, 0xf5, 0xe8, 0x2b, 0x90, 0x26, 0x9a, 0xa5,
	0xaf, 0x87, 0x6d, 0x6e, 0x15, 0x2f, 0x95, 0xdd, 0xf8, 0x5c, 0xd4, 0x5c, 0x83, 0x0a, 0x0a, 0xea,
	0x3e, 0xd1, 0x26, 0x70, 0x80, 0x40, 0x82, 0x28, 0xb8, 0xf4, 0xb9, 0xc1, 0x4f, 0x2b, 0x45, 0xf5,
	0x69, 0x54, 0xb4, 0x71, 0x95, 0xb6, 0xad, 0x15, 0xf9, 0xce, 0x4b, 0x22, 0x1f, 0xfc, 0xcb, 0x81,
	0x49, 0x05, 0x9f, 0x64, 0xb9, 0xd9, 0xf0, 0x62, 0x5b, 0x75, 0x7c, 0x47, 0x83, 0xce, 0x3c, 0xe1,
	0x6a, 0x99, 0x15, 0x9b, 0xfa, 0x73, 0xcd, 0x08, 0x7a, 0x76, 0x20, 0x63, 0x61, 0x1c, 0xc2, 0x7e,
	0x98, 0xa5, 0xca, 0x6e, 0x48, 0xc3, 0x0a, 0x7e, 0x62, 0xed, 0x13, 0x16, 0x94, 0xe5, 0x42, 0xfb,
	0x68, 0x8f, 0x28, 0x17, 0x4d, 0x75, 0xcc, 0xd7, 0xc2, 0xda, 0x54, 0x47, 0xa3, 0x09, 0x89, 0xeb,
	0x3f, 0x91, 0xfa, 0x44, 0xc2, 0x80, 0x0b, 0x29, 0x8c, 0xc3, 0x81, 0x94, 0xa9, 0x68, 0xeb, 0xac,
	0x2c, 0xfc, 0x81, 0x55, 0x10, 0xbd, 0x2f, 0xfd, 0x21, 0xe9, 0x53, 0x1f, 0xc3, 0xab, 0x46, 0x54,
	0x7c, 0x7f, 0x75, 0x60, 0x54, 0x59, 0x8e, 0xcc, 0xa8, 0x01, 0xfe, 0xb2, 0x48, 0xe8, 0x4e, 0x38,
	0x6c, 0x69, 0xde, 0xb1, 0xfb, 0x48, 0xbb, 0x07, 0xd0, 0x47, 0xaa, 0x90, 0xa7, 0x0c, 0xe1, 0xae,
	0x85, 0xd1, 0x86, 0x73, 0x55, 0x21, 0xeb, 0x9e, 0xfd, 0xde, 0x81, 0x5c, 0x49, 0xbc, 0x89, 0xed,
	0x0b, 0xbd, 0xd2, 0xdc, 0xae, 0xbe, 0x3b, 0xd1, 0xbd, 0xfb, 0x3b, 0x3a, 0x97, 0x6a, 0x68, 0x6c,
	0x03, 0x7f, 0x26, 0x0a, 0xa9, 0xa7, 0x3d, 0x96, 0xfc, 0x7d, 0x18, 0x9a, 0x20, 0x36, 0x77, 0x5e,
	0x1d, 0xfb, 0x4b, 0x61, 0xbe, 0x0d, 0x7d, 0xb2, 0xb7, 0xb2, 0xc5, 0x7e, 0x14, 0x6b, 0xb9, 0x25,
	0x78, 0x0e, 0x47, 0x35, 0xc0, 0x2e, 0xb2, 0x55, 0x81, 0x4d, 0x8c, 0xc4, 0x07, 0x8d, 0x2d, 0x63,
	0x6c, 0xd6, 0xe2, 0x13, 0xf6, 0xe3, 0xf7, 0x9f, 0x3e, 0xfe, 0xe2, 0xf1, 0xd3, 0x2f, 0x75, 0xd3,
	0xbe, 0x77, 0xc1, 0x85, 0xe3, 0x63, 0xff, 0x22, 0xdf, 0x93, 0xcf, 0xdf, 0xd3, 0xbc, 0x23, 0xe8,
	0xa1, 0x73, 0x37, 0xda, 0xb1, 0xc1, 0xdb, 0xe0, 0x55, 0x82, 0x69, 0x14, 0xb6, 0x36, 0x60, 0x47,
	0x8f, 0xd2, 0x33, 0xfa, 0x1c, 0x8b, 0x48, 0xf3, 0x2e, 0x1c, 0x85, 0xd9, 0x66, 0x11, 0xa7, 0x1c,
	0xe1, 0x4f, 0x73, 0xd3, 0xc4, 0xfc, 0x34, 0x99, 0xe5, 0x50, 0xec, 0x39, 0x1c, 0xea, 0x15, 0xb2,
	0x88, 0xed, 0xc6, 0x84, 0x8d, 0x6a, 0xcd, 0x73, 0xa5, 0x4b, 0x54, 0x5f, 0x3f, 0x86, 0xbd, 0xa8,
	0xcc, 0x5b, 0x5f, 0x29, 0x65, 0xb9, 0xc0, 0xe0, 0x99, 0x79, 0xe9, 0xda, 0x12, 0x89, 0x78, 0xba,
	0x12, 0x05, 0xdb, 0x60, 0xbb, 0xd0, 0xb8, 0xf7, 0x18, 0x46, 0x39, 0x0f, 0x4f, 0xf9, 0x4a, 0x18,
	0x24, 0xe7, 0x01, 0x58, 0xc2, 0x2e, 0x44, 0xf7, 0x08, 0xa6, 0xd4, 0xce, 0xb2, 0x5c, 0xa4, 0xcc,
	0x30, 0x7b, 0xff, 0x6f, 0x79, 0x9a, 0x9f, 0x2d, 0x5b, 0x57, 0x07, 0xbf, 0x77, 0x60, 0x24, 0xd7,
	0x59, 0x8e, 0xdb, 0xca, 0x9a, 0x17, 0x2b, 0xd1, 0x72, 0x52, 0xbb, 0xd8, 0x3a, 0x97, 0x8a, 0x4d,
	0x7f, 0xeb, 0xb8, 0x85, 0x25, 0x82, 0x29, 0xf8, 0xb1, 0x5d, 0xc7, 0xaf, 0x42, 0xc9, 0x01, 0x1c,
	0xbc, 0x9f, 0x49, 0xf5, 0x71, 0x8d, 0x41, 0x2e, 0x67, 0xe9, 0x17, 0xc6, 0x0a, 0xab, 0x0c, 0x56,
	0x46, 0x6b, 0x1f, 0xbc, 0x1c, 0x3b, 0x2f, 0x80, 0x3d, 0x2d, 0xdd, 0x7c, 0x33, 0xd0, 0x56, 0xb6,
	0x6c, 0x0a, 0xbe, 0xa2, 0xf8, 0x6e, 0x30, 0xb4, 0x48, 0x5f, 0x65, 0x59, 0x24, 0xab, 0xf8, 0xb6,
	0x37, 0x9d, 0xb6, 0x5f, 0xe9, 0x43, 0x3d, 0x0d, 0xa1, 0x70, 0x5b, 0x2f, 0x68, 0x79, 0x11, 0x87,
	0xc2, 0xac, 0xbc, 0x63, 0xd8, 0x8b, 0x25, 0x5b, 0x94, 0x5b, 0xbd, 0xf0, 0x92, 0xcb, 0x50, 0x86,
	0x9e, 0x17, 0xfa, 0x2b, 0xfd, 0xd7, 0x0e, 0x4c, 0x9a, 0xf2, 0x49, 0xf2, 0xb7, 0x01, 0x6a, 0x3d,
	0x4c, 0x84, 0x5e, 0x27, 0xdd, 0x77, 0xa8, 0xfa, 0x26, 0xbc, 0x4e, 0xa4, 0x97, 0x02, 0xac, 0x37,
	0xe0, 0xba, 0x1d, 0x21, 0x86, 0xc3, 0x82, 0x6b, 0x87, 0x3e, 0xdf, 0x5d, 0xdf, 0xf0, 0xb4, 0xe4,
	0xc9, 0x85, 0xb7, 0x5d, 0xe3, 0xc9, 0xd7, 0xcc, 0x5b, 0xbd, 0x53, 0xb7, 0x79, 0xa8, 0x0f, 0xbd,
	0x37, 0xf9, 0xfa, 0xc5, 0x4d, 0xe7, 0xef, 0x2f, 0x6e, 0x3a, 0xdf, 0xbc, 0xb8, 0xe9, 0xfc, 0xe1,
	0x1f, 0x37, 0xff, 0xef, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x34, 0x48, 0x72, 0x2a, 0x62, 0x1c,
	0x00, 0x00,
}

func (m *UniversalData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UniversalData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(*m.Key))
	}
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Name == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.B) > 0 {
		for _, b := range m.B {
			dAtA[i] = 0x20
			i++
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.F) > 0 {
		for _, num := range m.F {
			dAtA[i] = 0x2d
			i++
			f1 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f1))
			i += 4
		}
	}
	if len(m.D) > 0 {
		for _, num := range m.D {
			dAtA[i] = 0x31
			i++
			f2 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f2))
			i += 8
		}
	}
	if len(m.E) > 0 {
		for _, num := range m.E {
			dAtA[i] = 0x38
			i++
			x3 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x3 >= 1<<7 {
				dAtA[i] = uint8(uint64(x3)&0x7f | 0x80)
				x3 >>= 7
				i++
			}
			dAtA[i] = uint8(x3)
			i++
		}
	}
	if len(m.I32) > 0 {
		for _, num := range m.I32 {
			dAtA[i] = 0x40
			i++
			x4 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x4 >= 1<<7 {
				dAtA[i] = uint8(uint64(x4)&0x7f | 0x80)
				x4 >>= 7
				i++
			}
			dAtA[i] = uint8(x4)
			i++
		}
	}
	if len(m.I64) > 0 {
		for _, num := range m.I64 {
			dAtA[i] = 0x48
			i++
			x5 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x5 >= 1<<7 {
				dAtA[i] = uint8(uint64(x5)&0x7f | 0x80)
				x5 >>= 7
				i++
			}
			dAtA[i] = uint8(x5)
			i++
		}
	}
	if len(m.U32) > 0 {
		for _, num := range m.U32 {
			dAtA[i] = 0x50
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(num))
		}
	}
	if len(m.U64) > 0 {
		for _, num := range m.U64 {
			dAtA[i] = 0x58
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(num))
		}
	}
	if len(m.Str) > 0 {
		for _, b := range m.Str {
			dAtA[i] = 0x62
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Sub) > 0 {
		for _, msg := range m.Sub {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LuaPos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaPos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PosX == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.PosX)<<1)^uint32((*m.PosX>>31))))
	}
	if m.PosY == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.PosY)<<1)^uint32((*m.PosY>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DbBagItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DbBagItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemIndex == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.ItemIndex)<<1)^uint64((*m.ItemIndex>>63))))
	}
	if m.ItemId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ItemId)<<1)^uint32((*m.ItemId>>31))))
	}
	if m.ItemCount == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.ItemCount)<<1)^uint64((*m.ItemCount>>63))))
	}
	if m.IsTouched == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		if *m.IsTouched {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListDbBagItems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDbBagItems) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BagItem) > 0 {
		for _, msg := range m.BagItem {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DbBagEquip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DbBagEquip) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EquipIndex == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.EquipIndex)<<1)^uint64((*m.EquipIndex>>63))))
	}
	if m.EquipId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.EquipId)<<1)^uint32((*m.EquipId>>31))))
	}
	if m.Level == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
	}
	if m.Attack == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Attack)<<1)^uint32((*m.Attack>>31))))
	}
	if m.Endurance == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Endurance)<<1)^uint32((*m.Endurance>>31))))
	}
	if m.Quality == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Quality)<<1)^uint32((*m.Quality>>31))))
	}
	if m.SiteType == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x38
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(*m.SiteType))
	}
	if m.IsTouched == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x40
		i++
		if *m.IsTouched {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ExtraPer != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.ExtraPer.Size()))
		n6, err6 := m.ExtraPer.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DbRoleEquip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DbRoleEquip) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EquipIndex == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.EquipIndex)<<1)^uint64((*m.EquipIndex>>63))))
	}
	if m.EquipId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.EquipId)<<1)^uint32((*m.EquipId>>31))))
	}
	if m.Level == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
	}
	if m.Attack == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Attack)<<1)^uint32((*m.Attack>>31))))
	}
	if m.Endurance == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Endurance)<<1)^uint32((*m.Endurance>>31))))
	}
	if m.Quality == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Quality)<<1)^uint32((*m.Quality>>31))))
	}
	if m.SiteType == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x38
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(*m.SiteType))
	}
	if m.ExtraPer != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.ExtraPer.Size()))
		n7, err7 := m.ExtraPer.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EquipExtraPer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipExtraPer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FightPer == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.FightPer)<<1)^uint32((*m.FightPer>>31))))
	}
	if m.DefPer == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.DefPer)<<1)^uint32((*m.DefPer>>31))))
	}
	if m.CritPer == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.CritPer)<<1)^uint32((*m.CritPer>>31))))
	}
	if m.BlockPer == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.BlockPer)<<1)^uint32((*m.BlockPer>>31))))
	}
	if m.SpeedPer == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.SpeedPer)<<1)^uint32((*m.SpeedPer>>31))))
	}
	if m.HpPer == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.HpPer)<<1)^uint32((*m.HpPer>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DbFixEquip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DbFixEquip) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FullEndurance == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.FullEndurance)<<1)^uint32((*m.FullEndurance>>31))))
	}
	if m.FixTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.FixTime)<<1)^uint64((*m.FixTime>>63))))
	}
	if m.NeedTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.NeedTime)<<1)^uint32((*m.NeedTime>>31))))
	}
	if m.BagEquip == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.BagEquip.Size()))
		n8, err8 := m.BagEquip.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListDbFixEquips) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDbFixEquips) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FixInfo) > 0 {
		for _, msg := range m.FixInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListDbBagEquips) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDbBagEquips) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BagEquip) > 0 {
		for _, msg := range m.BagEquip {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LastRewardId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.LastRewardId)<<1)^uint32((*m.LastRewardId>>31))))
	}
	if len(m.EquipIdList) > 0 {
		for _, num := range m.EquipIdList {
			dAtA[i] = 0x18
			i++
			x9 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x9 >= 1<<7 {
				dAtA[i] = uint8(uint64(x9)&0x7f | 0x80)
				x9 >>= 7
				i++
			}
			dAtA[i] = uint8(x9)
			i++
		}
	}
	if m.BagCurrSize != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.BagCurrSize)<<1)^uint32((*m.BagCurrSize>>31))))
	}
	if m.BagExtendCount != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.BagExtendCount)<<1)^uint32((*m.BagExtendCount>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListDbRoleEquips) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDbRoleEquips) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoleEquip) > 0 {
		for _, msg := range m.RoleEquip {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RewardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
	}
	if m.Count == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Count)<<1)^uint32((*m.Count>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DbFriendInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DbFriendInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoleIndex == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.RoleIndex)<<1)^uint64((*m.RoleIndex>>63))))
	}
	if m.State == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.Time == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.Time)<<1)^uint64((*m.Time>>63))))
	}
	if m.LoginTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.LoginTime)<<1)^uint64((*m.LoginTime>>63))))
	}
	if m.CardInfo == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.CardInfo.Size()))
		n10, err10 := m.CardInfo.MarshalTo(dAtA[i:])
		if err10 != nil {
			return 0, err10
		}
		i += n10
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DbArenaKillInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DbArenaKillInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoleIndex == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.RoleIndex)<<1)^uint64((*m.RoleIndex>>63))))
	}
	if m.KillDate == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.KillDate)<<1)^uint32((*m.KillDate>>31))))
	}
	if m.ShowInfo == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.ShowInfo.Size()))
		n11, err11 := m.ShowInfo.MarshalTo(dAtA[i:])
		if err11 != nil {
			return 0, err11
		}
		i += n11
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoleFace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleFace) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
	}
	if m.FaceId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.FaceId)<<1)^uint32((*m.FaceId>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MinigameRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinigameRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HistoryMaxScore != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.HistoryMaxScore)<<1)^uint32((*m.HistoryMaxScore>>31))))
	}
	if m.TodayMaxScore != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.TodayMaxScore)<<1)^uint32((*m.TodayMaxScore>>31))))
	}
	if m.HistoryTopRank != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.HistoryTopRank)<<1)^uint32((*m.HistoryTopRank>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MinigamePlayInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinigamePlayInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PlayRecord) > 0 {
		for _, msg := range m.PlayRecord {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DayBuyCount != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.DayBuyCount)<<1)^uint32((*m.DayBuyCount>>31))))
	}
	if m.GetFlag != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.GetFlag)<<1)^uint32((*m.GetFlag>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PlayerShowInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerShowInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
	}
	if m.VipLvl == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.VipLvl)<<1)^uint32((*m.VipLvl>>31))))
	}
	if m.Gender == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Gender)<<1)^uint32((*m.Gender>>31))))
	}
	if m.NickName == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(len(m.NickName)))
		i += copy(dAtA[i:], m.NickName)
	}
	if m.HelmetId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.HelmetId)<<1)^uint32((*m.HelmetId>>31))))
	}
	if m.ClothesId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ClothesId)<<1)^uint32((*m.ClothesId>>31))))
	}
	if m.ShoesId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x38
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ShoesId)<<1)^uint32((*m.ShoesId>>31))))
	}
	if m.WingId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x40
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.WingId)<<1)^uint32((*m.WingId>>31))))
	}
	if m.WeaponId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x48
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.WeaponId)<<1)^uint32((*m.WeaponId>>31))))
	}
	if m.VehicleId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x50
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.VehicleId)<<1)^uint32((*m.VehicleId>>31))))
	}
	if m.SuitId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x58
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.SuitId)<<1)^uint32((*m.SuitId>>31))))
	}
	if m.Face == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x62
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.Face.Size()))
		n12, err12 := m.Face.MarshalTo(dAtA[i:])
		if err12 != nil {
			return 0, err12
		}
		i += n12
	}
	if m.PlayerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(len(m.PlayerId)))
		i += copy(dAtA[i:], m.PlayerId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PlayerValueInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerValueInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hp == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Hp)<<1)^uint32((*m.Hp>>31))))
	}
	if m.Atk == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Atk)<<1)^uint32((*m.Atk>>31))))
	}
	if m.Def == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Def)<<1)^uint32((*m.Def>>31))))
	}
	if m.Crit == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Crit)<<1)^uint32((*m.Crit>>31))))
	}
	if m.Block == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Block)<<1)^uint32((*m.Block>>31))))
	}
	if m.Speed == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Speed)<<1)^uint32((*m.Speed>>31))))
	}
	if m.Fight != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Fight)<<1)^uint32((*m.Fight>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VisitingCardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VisitingCardInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShowInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.ShowInfo.Size()))
		n13, err13 := m.ShowInfo.MarshalTo(dAtA[i:])
		if err13 != nil {
			return 0, err13
		}
		i += n13
	}
	if m.PlayerInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.PlayerInfo.Size()))
		n14, err14 := m.PlayerInfo.MarshalTo(dAtA[i:])
		if err14 != nil {
			return 0, err14
		}
		i += n14
	}
	if m.RoleIndex != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.RoleIndex)<<1)^uint64((*m.RoleIndex>>63))))
	}
	if m.ExtraPercent != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.ExtraPercent.Size()))
		n15, err15 := m.ExtraPercent.MarshalTo(dAtA[i:])
		if err15 != nil {
			return 0, err15
		}
		i += n15
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ArenaPlayerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArenaPlayerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rank == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Rank)<<1)^uint32((*m.Rank>>31))))
	}
	if m.PlayerInfo == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.PlayerInfo.Size()))
		n16, err16 := m.PlayerInfo.MarshalTo(dAtA[i:])
		if err16 != nil {
			return 0, err16
		}
		i += n16
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BattleSkillInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BattleSkillInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
	}
	if m.Level == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
	}
	if m.Skilled == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Skilled)<<1)^uint32((*m.Skilled>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BattlePlayerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BattlePlayerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VisitingCard != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.VisitingCard.Size()))
		n17, err17 := m.VisitingCard.MarshalTo(dAtA[i:])
		if err17 != nil {
			return 0, err17
		}
		i += n17
	}
	if len(m.SkillList) > 0 {
		for _, msg := range m.SkillList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SuitSkill != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.SuitSkill.Size()))
		n18, err18 := m.SuitSkill.MarshalTo(dAtA[i:])
		if err18 != nil {
			return 0, err18
		}
		i += n18
	}
	if len(m.CardList) > 0 {
		for _, num := range m.CardList {
			dAtA[i] = 0x20
			i++
			x19 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x19 >= 1<<7 {
				dAtA[i] = uint8(uint64(x19)&0x7f | 0x80)
				x19 >>= 7
				i++
			}
			dAtA[i] = uint8(x19)
			i++
		}
	}
	if m.Position != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Position)<<1)^uint32((*m.Position>>31))))
	}
	if m.ActValue != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ActValue)<<1)^uint32((*m.ActValue>>31))))
	}
	if m.FightPet != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.FightPet.Size()))
		n20, err20 := m.FightPet.MarshalTo(dAtA[i:])
		if err20 != nil {
			return 0, err20
		}
		i += n20
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ArenaBattleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArenaBattleInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Player == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.Player.Size()))
		n21, err21 := m.Player.MarshalTo(dAtA[i:])
		if err21 != nil {
			return 0, err21
		}
		i += n21
	}
	if m.Rank == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Rank)<<1)^uint32((*m.Rank>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RankInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoleIndex == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.RoleIndex)<<1)^uint64((*m.RoleIndex>>63))))
	}
	if m.PlayerInfo == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.PlayerInfo.Size()))
		n22, err22 := m.PlayerInfo.MarshalTo(dAtA[i:])
		if err22 != nil {
			return 0, err22
		}
		i += n22
	}
	if m.Rank == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Rank)<<1)^uint32((*m.Rank>>31))))
	}
	if m.Score == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.Score)<<1)^uint64((*m.Score>>63))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SkillUseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillUseInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SkillId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.SkillId)<<1)^uint32((*m.SkillId>>31))))
	}
	if m.SkillCount == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.SkillCount)<<1)^uint32((*m.SkillCount>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DbDailyTaskInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DbDailyTaskInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Type)<<1)^uint32((*m.Type>>31))))
	}
	if m.Id == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
	}
	if m.Count == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Count)<<1)^uint32((*m.Count>>31))))
	}
	if m.TotCount == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.TotCount)<<1)^uint32((*m.TotCount>>31))))
	}
	if m.GetFlag == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		if *m.GetFlag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DbDailyActivityPerLevelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DbDailyActivityPerLevelInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(*m.Level))
	}
	if m.GetFlag == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		if *m.GetFlag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DbDailyActivityInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DbDailyActivityInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalAvtivityValue == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.TotalAvtivityValue)<<1)^uint32((*m.TotalAvtivityValue>>31))))
	}
	if len(m.LevelInfo) > 0 {
		for _, msg := range m.LevelInfo {
			dAtA[i] = 0x12
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LuaRect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaRect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.X)<<1)^uint32((*m.X>>31))))
	}
	if m.Y == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Y)<<1)^uint32((*m.Y>>31))))
	}
	if m.W == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.W)<<1)^uint32((*m.W>>31))))
	}
	if m.H == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.H)<<1)^uint32((*m.H>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LuaPosRect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LuaPosRect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartX == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.StartX)<<1)^uint32((*m.StartX>>31))))
	}
	if m.StartY == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.StartY)<<1)^uint32((*m.StartY>>31))))
	}
	if m.EndX == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.EndX)<<1)^uint32((*m.EndX>>31))))
	}
	if m.EndY == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.EndY)<<1)^uint32((*m.EndY>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ItemConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ItemId)<<1)^uint32((*m.ItemId>>31))))
	}
	if m.ItemCount == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ItemCount)<<1)^uint32((*m.ItemCount>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FaceConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FaceConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ItemId)<<1)^uint32((*m.ItemId>>31))))
	}
	if m.ItemTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ItemTime)<<1)^uint32((*m.ItemTime>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SuitConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuitConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ItemId)<<1)^uint32((*m.ItemId>>31))))
	}
	if m.ItemTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ItemTime)<<1)^uint32((*m.ItemTime>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MinosMailTitle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinosMailTitle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MailIndex == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.MailIndex)<<1)^uint64((*m.MailIndex>>63))))
	}
	if m.MailTitle == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(len(m.MailTitle)))
		i += copy(dAtA[i:], m.MailTitle)
	}
	if m.MailTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.MailTime)<<1)^uint64((*m.MailTime>>63))))
	}
	if m.MailType != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.MailType)<<1)^uint32((*m.MailType>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MinosMail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinosMail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrcRoleIndex == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.SrcRoleIndex)<<1)^uint64((*m.SrcRoleIndex>>63))))
	}
	if m.TarRoleIndex == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.TarRoleIndex)<<1)^uint64((*m.TarRoleIndex>>63))))
	}
	if m.MailTitle == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.MailTitle.Size()))
		n23, err23 := m.MailTitle.MarshalTo(dAtA[i:])
		if err23 != nil {
			return 0, err23
		}
		i += n23
	}
	if m.MailText == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(len(m.MailText)))
		i += copy(dAtA[i:], m.MailText)
	}
	if len(m.MailListItems) > 0 {
		for _, msg := range m.MailListItems {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MailListFaces) > 0 {
		for _, msg := range m.MailListFaces {
			dAtA[i] = 0x32
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MailListSuits) > 0 {
		for _, msg := range m.MailListSuits {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InteractNpc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InteractNpc) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NpcId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.NpcId)<<1)^uint32((*m.NpcId>>31))))
	}
	if m.Count == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Count)<<1)^uint32((*m.Count>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InteractCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InteractCount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
	}
	if m.Count == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Count)<<1)^uint32((*m.Count>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InteractUnlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InteractUnlock) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Condition) > 0 {
		for _, num := range m.Condition {
			dAtA[i] = 0x8
			i++
			x24 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x24 >= 1<<7 {
				dAtA[i] = uint8(uint64(x24)&0x7f | 0x80)
				x24 >>= 7
				i++
			}
			dAtA[i] = uint8(x24)
			i++
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LevelNeed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LevelNeed) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurLevel == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.CurLevel)<<1)^uint32((*m.CurLevel>>31))))
	}
	if m.NeedLevel == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.NeedLevel)<<1)^uint32((*m.NeedLevel>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ItemNeed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemNeed) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
	}
	if m.CurCount == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.CurCount)<<1)^uint64((*m.CurCount>>63))))
	}
	if m.NeedCount == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.NeedCount)<<1)^uint64((*m.NeedCount>>63))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SpInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SpId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.SpId)<<1)^uint32((*m.SpId>>31))))
	}
	if m.Stamp == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.Stamp)<<1)^uint64((*m.Stamp>>63))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoleCustomFace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleCustomFace) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FaceId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.FaceId)<<1)^uint32((*m.FaceId>>31))))
	}
	if m.Valid == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Valid)<<1)^uint32((*m.Valid>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PetBaseFight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PetBaseFight) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hp == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.Hp)<<1)^uint64((*m.Hp>>63))))
	}
	if m.Atk == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.Atk)<<1)^uint64((*m.Atk>>63))))
	}
	if m.Def == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.Def)<<1)^uint64((*m.Def>>63))))
	}
	if m.Crit == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.Crit)<<1)^uint64((*m.Crit>>63))))
	}
	if m.Block == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.Block)<<1)^uint64((*m.Block>>63))))
	}
	if m.Speed == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.Speed)<<1)^uint64((*m.Speed>>63))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PetTalent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PetTalent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TalentId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.TalentId)<<1)^uint32((*m.TalentId>>31))))
	}
	if m.Level == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PetInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PetInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PetId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.PetId)<<1)^uint32((*m.PetId>>31))))
	}
	if m.Level == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Level)<<1)^uint32((*m.Level>>31))))
	}
	if m.Exp == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.Exp)<<1)^uint64((*m.Exp>>63))))
	}
	if m.BaseAttr == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.BaseAttr.Size()))
		n25, err25 := m.BaseAttr.MarshalTo(dAtA[i:])
		if err25 != nil {
			return 0, err25
		}
		i += n25
	}
	if len(m.ActiveList) > 0 {
		for _, msg := range m.ActiveList {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PassiveList) > 0 {
		for _, msg := range m.PassiveList {
			dAtA[i] = 0x32
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PetRefresh) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PetRefresh) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Status)<<1)^uint32((*m.Status>>31))))
	}
	if m.NextRefreshTimestamp != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.NextRefreshTimestamp)<<1)^uint64((*m.NextRefreshTimestamp>>63))))
	}
	if m.PetId != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.PetId)<<1)^uint32((*m.PetId>>31))))
	}
	if m.SceneId != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.SceneId)<<1)^uint32((*m.SceneId>>31))))
	}
	if m.PosInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.PosInfo.Size()))
		n26, err26 := m.PosInfo.MarshalTo(dAtA[i:])
		if err26 != nil {
			return 0, err26
		}
		i += n26
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HorseEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HorseEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(*m.Type))
	}
	if len(m.ParaList) > 0 {
		for _, num := range m.ParaList {
			dAtA[i] = 0x10
			i++
			x27 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x27 >= 1<<7 {
				dAtA[i] = uint8(uint64(x27)&0x7f | 0x80)
				x27 >>= 7
				i++
			}
			dAtA[i] = uint8(x27)
			i++
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ItemListConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemListConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Item) > 0 {
		for _, msg := range m.Item {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HorseLightInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HorseLightInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HorseId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.HorseId)<<1)^uint32((*m.HorseId>>31))))
	}
	if m.NickName != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(len(m.NickName)))
		i += copy(dAtA[i:], m.NickName)
	}
	if len(m.ParaList) > 0 {
		for _, num := range m.ParaList {
			dAtA[i] = 0x18
			i++
			x28 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x28 >= 1<<7 {
				dAtA[i] = uint8(uint64(x28)&0x7f | 0x80)
				x28 >>= 7
				i++
			}
			dAtA[i] = uint8(x28)
			i++
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SuccessDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuccessDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SuccessCount == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.SuccessCount)<<1)^uint64((*m.SuccessCount>>63))))
	}
	if m.SuccessNum != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.SuccessNum)<<1)^uint64((*m.SuccessNum>>63))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GuadraticResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuadraticResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Show == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.Show.Size()))
		n29, err29 := m.Show.MarshalTo(dAtA[i:])
		if err29 != nil {
			return 0, err29
		}
		i += n29
	}
	if m.LiveTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.LiveTime)<<1)^uint32((*m.LiveTime>>31))))
	}
	if m.KillNum == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.KillNum)<<1)^uint32((*m.KillNum>>31))))
	}
	if m.ItemList == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.ItemList.Size()))
		n30, err30 := m.ItemList.MarshalTo(dAtA[i:])
		if err30 != nil {
			return 0, err30
		}
		i += n30
	}
	if m.RoleIndex == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.RoleIndex)<<1)^uint64((*m.RoleIndex>>63))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GuadraticRoleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuadraticRoleInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoleIndex == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.RoleIndex)<<1)^uint64((*m.RoleIndex>>63))))
	}
	if m.Pos != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.Pos.Size()))
		n31, err31 := m.Pos.MarshalTo(dAtA[i:])
		if err31 != nil {
			return 0, err31
		}
		i += n31
	}
	if m.CurrentHp == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.CurrentHp)<<1)^uint32((*m.CurrentHp>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GuadraticRoleHp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuadraticRoleHp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoleIndex == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.RoleIndex)<<1)^uint64((*m.RoleIndex>>63))))
	}
	if m.Hp == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Hp)<<1)^uint32((*m.Hp>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GuadraticRoleCd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuadraticRoleCd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoleIndex == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.RoleIndex)<<1)^uint64((*m.RoleIndex>>63))))
	}
	if m.Cd == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Cd)<<1)^uint32((*m.Cd>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SellInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SellInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.Index)<<1)^uint64((*m.Index>>63))))
	}
	if m.Num == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Num)<<1)^uint32((*m.Num>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RedeemCodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedeemCodeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if m.BatchNo == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(len(m.BatchNo)))
		i += copy(dAtA[i:], m.BatchNo)
	}
	if m.AccountType == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(*m.AccountType))
	}
	if m.ServerRule == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(*m.ServerRule))
	}
	if m.ServerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(*m.ServerId))
	}
	if m.GiftId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(*m.GiftId))
	}
	if m.StartTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x38
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(*m.StartTime))
	}
	if m.EndTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x40
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(*m.EndTime))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RedeemGiftInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedeemGiftInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GiftId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.GiftId)<<1)^uint64((*m.GiftId>>63))))
	}
	if m.ItemList == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.ItemList.Size()))
		n32, err32 := m.ItemList.MarshalTo(dAtA[i:])
		if err32 != nil {
			return 0, err32
		}
		i += n32
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ActivitySummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivitySummary) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
	}
	if m.PlatformId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.PlatformId)<<1)^uint32((*m.PlatformId>>31))))
	}
	if m.Title != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.Content != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.Type != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(*m.Type))
	}
	if m.SubType != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(*m.SubType))
	}
	if m.StartTime != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.StartTime)<<1)^uint64((*m.StartTime>>63))))
	}
	if m.EndTime != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.EndTime)<<1)^uint64((*m.EndTime>>63))))
	}
	if m.StopTime != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.StopTime)<<1)^uint64((*m.StopTime>>63))))
	}
	if m.ResetType != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ResetType)<<1)^uint32((*m.ResetType>>31))))
	}
	if m.ResetHour != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ResetHour)<<1)^uint32((*m.ResetHour>>31))))
	}
	if m.Rules != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(len(m.Rules)))
		i += copy(dAtA[i:], m.Rules)
	}
	if m.ResetTime != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.ResetTime)<<1)^uint64((*m.ResetTime>>63))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ActivityRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RuleDes != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(len(m.RuleDes)))
		i += copy(dAtA[i:], m.RuleDes)
	}
	if m.SubType != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.SubType)<<1)^uint32((*m.SubType>>31))))
	}
	if len(m.ParaList) > 0 {
		for _, num := range m.ParaList {
			dAtA[i] = 0x18
			i++
			x33 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x33 >= 1<<7 {
				dAtA[i] = uint8(uint64(x33)&0x7f | 0x80)
				x33 >>= 7
				i++
			}
			dAtA[i] = uint8(x33)
			i++
		}
	}
	if m.CanGetCount != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.CanGetCount)<<1)^uint32((*m.CanGetCount>>31))))
	}
	if m.GotCount != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.GotCount)<<1)^uint32((*m.GotCount>>31))))
	}
	if m.GetLimitCount != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.GetLimitCount)<<1)^uint32((*m.GetLimitCount>>31))))
	}
	if len(m.RewardList) > 0 {
		for _, msg := range m.RewardList {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ActivityInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Version)<<1)^uint32((*m.Version>>31))))
	}
	if m.SummaryInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.SummaryInfo.Size()))
		n34, err34 := m.SummaryInfo.MarshalTo(dAtA[i:])
		if err34 != nil {
			return 0, err34
		}
		i += n34
	}
	if len(m.RuleList) > 0 {
		for _, msg := range m.RuleList {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ActivityProgressInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityProgressInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(*m.Type))
	}
	if m.SubType != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(*m.SubType))
	}
	if len(m.Param) > 0 {
		for _, num := range m.Param {
			dAtA[i] = 0x18
			i++
			x35 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x35 >= 1<<7 {
				dAtA[i] = uint8(uint64(x35)&0x7f | 0x80)
				x35 >>= 7
				i++
			}
			dAtA[i] = uint8(x35)
			i++
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ActivityBaseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityBaseInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
	}
	if m.Ver != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Ver)<<1)^uint32((*m.Ver>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CombinationSkillInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombinationSkillInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CdTime != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.CdTime)<<1)^uint64((*m.CdTime>>63))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FightRiskInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightRiskInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChapterId != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ChapterId)<<1)^uint32((*m.ChapterId>>31))))
	}
	if m.DupId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.DupId)<<1)^uint32((*m.DupId>>31))))
	}
	if m.SubmitStatus != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.SubmitStatus)<<1)^uint32((*m.SubmitStatus>>31))))
	}
	if m.DangerMode != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.DangerMode)<<1)^uint32((*m.DangerMode>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PackageCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PackageCount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PackageId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.PackageId)<<1)^uint32((*m.PackageId>>31))))
	}
	if m.Count == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Count)<<1)^uint32((*m.Count>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoleOpenPackage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleOpenPackage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Count) > 0 {
		for _, msg := range m.Count {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShopRecharge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShopRecharge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Id)<<1)^uint32((*m.Id>>31))))
	}
	if m.StartTime != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.StartTime)<<1)^uint64((*m.StartTime>>63))))
	}
	if m.EndTime != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.EndTime)<<1)^uint64((*m.EndTime>>63))))
	}
	if len(m.RewardList) > 0 {
		for _, msg := range m.RewardList {
			dAtA[i] = 0x22
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CostList) > 0 {
		for _, msg := range m.CostList {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoleRechargeGet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleRechargeGet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GetFlag != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.GetFlag)<<1)^uint32((*m.GetFlag>>31))))
	}
	if m.Ver != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Ver)<<1)^uint32((*m.Ver>>31))))
	}
	if m.Reward != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64(m.Reward.Size()))
		n36, err36 := m.Reward.MarshalTo(dAtA[i:])
		if err36 != nil {
			return 0, err36
		}
		i += n36
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommonShopGoodsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonShopGoodsInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ItemId)<<1)^uint32((*m.ItemId>>31))))
	}
	if m.Count == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Count)<<1)^uint32((*m.Count>>31))))
	}
	if m.Currency == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Currency)<<1)^uint32((*m.Currency>>31))))
	}
	if m.Price == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.Price)<<1)^uint32((*m.Price>>31))))
	}
	if m.IsBuy == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		if *m.IsBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ShopIndex == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ShopIndex)<<1)^uint32((*m.ShopIndex>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommonShopInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonShopInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GoodsInfo) > 0 {
		for _, msg := range m.GoodsInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProtoDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ShopNextRefreshTimestamp != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint64(*m.ShopNextRefreshTimestamp)<<1)^uint64((*m.ShopNextRefreshTimestamp>>63))))
	}
	if m.ServerRefreshCount != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ServerRefreshCount)<<1)^uint32((*m.ServerRefreshCount>>31))))
	}
	if m.ManualRefreshCount != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ManualRefreshCount)<<1)^uint32((*m.ManualRefreshCount>>31))))
	}
	if m.ManualTotalRefreshCount != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtoDef(dAtA, i, uint64((uint32(*m.ManualTotalRefreshCount)<<1)^uint32((*m.ManualTotalRefreshCount>>31))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintProtoDef(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *UniversalData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		n += 1 + sovProtoDef(uint64(*m.Key))
	}
	if m.Type != nil {
		l = len(m.Type)
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.Name != nil {
		l = len(m.Name)
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if len(m.B) > 0 {
		n += 2 * len(m.B)
	}
	if len(m.F) > 0 {
		n += 5 * len(m.F)
	}
	if len(m.D) > 0 {
		n += 9 * len(m.D)
	}
	if len(m.E) > 0 {
		for _, e := range m.E {
			n += 1 + sozProtoDef(uint64(e))
		}
	}
	if len(m.I32) > 0 {
		for _, e := range m.I32 {
			n += 1 + sozProtoDef(uint64(e))
		}
	}
	if len(m.I64) > 0 {
		for _, e := range m.I64 {
			n += 1 + sozProtoDef(uint64(e))
		}
	}
	if len(m.U32) > 0 {
		for _, e := range m.U32 {
			n += 1 + sovProtoDef(uint64(e))
		}
	}
	if len(m.U64) > 0 {
		for _, e := range m.U64 {
			n += 1 + sovProtoDef(uint64(e))
		}
	}
	if len(m.Str) > 0 {
		for _, b := range m.Str {
			l = len(b)
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if len(m.Sub) > 0 {
		for _, e := range m.Sub {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaPos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PosX != nil {
		n += 1 + sozProtoDef(uint64(*m.PosX))
	}
	if m.PosY != nil {
		n += 1 + sozProtoDef(uint64(*m.PosY))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DbBagItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemIndex != nil {
		n += 1 + sozProtoDef(uint64(*m.ItemIndex))
	}
	if m.ItemId != nil {
		n += 1 + sozProtoDef(uint64(*m.ItemId))
	}
	if m.ItemCount != nil {
		n += 1 + sozProtoDef(uint64(*m.ItemCount))
	}
	if m.IsTouched != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListDbBagItems) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BagItem) > 0 {
		for _, e := range m.BagItem {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DbBagEquip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EquipIndex != nil {
		n += 1 + sozProtoDef(uint64(*m.EquipIndex))
	}
	if m.EquipId != nil {
		n += 1 + sozProtoDef(uint64(*m.EquipId))
	}
	if m.Level != nil {
		n += 1 + sozProtoDef(uint64(*m.Level))
	}
	if m.Attack != nil {
		n += 1 + sozProtoDef(uint64(*m.Attack))
	}
	if m.Endurance != nil {
		n += 1 + sozProtoDef(uint64(*m.Endurance))
	}
	if m.Quality != nil {
		n += 1 + sozProtoDef(uint64(*m.Quality))
	}
	if m.SiteType != nil {
		n += 1 + sovProtoDef(uint64(*m.SiteType))
	}
	if m.IsTouched != nil {
		n += 2
	}
	if m.ExtraPer != nil {
		l = m.ExtraPer.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DbRoleEquip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EquipIndex != nil {
		n += 1 + sozProtoDef(uint64(*m.EquipIndex))
	}
	if m.EquipId != nil {
		n += 1 + sozProtoDef(uint64(*m.EquipId))
	}
	if m.Level != nil {
		n += 1 + sozProtoDef(uint64(*m.Level))
	}
	if m.Attack != nil {
		n += 1 + sozProtoDef(uint64(*m.Attack))
	}
	if m.Endurance != nil {
		n += 1 + sozProtoDef(uint64(*m.Endurance))
	}
	if m.Quality != nil {
		n += 1 + sozProtoDef(uint64(*m.Quality))
	}
	if m.SiteType != nil {
		n += 1 + sovProtoDef(uint64(*m.SiteType))
	}
	if m.ExtraPer != nil {
		l = m.ExtraPer.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EquipExtraPer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FightPer != nil {
		n += 1 + sozProtoDef(uint64(*m.FightPer))
	}
	if m.DefPer != nil {
		n += 1 + sozProtoDef(uint64(*m.DefPer))
	}
	if m.CritPer != nil {
		n += 1 + sozProtoDef(uint64(*m.CritPer))
	}
	if m.BlockPer != nil {
		n += 1 + sozProtoDef(uint64(*m.BlockPer))
	}
	if m.SpeedPer != nil {
		n += 1 + sozProtoDef(uint64(*m.SpeedPer))
	}
	if m.HpPer != nil {
		n += 1 + sozProtoDef(uint64(*m.HpPer))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DbFixEquip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FullEndurance != nil {
		n += 1 + sozProtoDef(uint64(*m.FullEndurance))
	}
	if m.FixTime != nil {
		n += 1 + sozProtoDef(uint64(*m.FixTime))
	}
	if m.NeedTime != nil {
		n += 1 + sozProtoDef(uint64(*m.NeedTime))
	}
	if m.BagEquip != nil {
		l = m.BagEquip.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListDbFixEquips) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FixInfo) > 0 {
		for _, e := range m.FixInfo {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListDbBagEquips) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BagEquip) > 0 {
		for _, e := range m.BagEquip {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if m.LastRewardId != nil {
		n += 1 + sozProtoDef(uint64(*m.LastRewardId))
	}
	if len(m.EquipIdList) > 0 {
		for _, e := range m.EquipIdList {
			n += 1 + sozProtoDef(uint64(e))
		}
	}
	if m.BagCurrSize != nil {
		n += 1 + sozProtoDef(uint64(*m.BagCurrSize))
	}
	if m.BagExtendCount != nil {
		n += 1 + sozProtoDef(uint64(*m.BagExtendCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListDbRoleEquips) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RoleEquip) > 0 {
		for _, e := range m.RoleEquip {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewardInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozProtoDef(uint64(*m.Id))
	}
	if m.Count != nil {
		n += 1 + sozProtoDef(uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DbFriendInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoleIndex != nil {
		n += 1 + sozProtoDef(uint64(*m.RoleIndex))
	}
	if m.State != nil {
		l = len(m.State)
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.Time != nil {
		n += 1 + sozProtoDef(uint64(*m.Time))
	}
	if m.LoginTime != nil {
		n += 1 + sozProtoDef(uint64(*m.LoginTime))
	}
	if m.CardInfo != nil {
		l = m.CardInfo.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DbArenaKillInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoleIndex != nil {
		n += 1 + sozProtoDef(uint64(*m.RoleIndex))
	}
	if m.KillDate != nil {
		n += 1 + sozProtoDef(uint64(*m.KillDate))
	}
	if m.ShowInfo != nil {
		l = m.ShowInfo.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoleFace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sozProtoDef(uint64(*m.Type))
	}
	if m.FaceId != nil {
		n += 1 + sozProtoDef(uint64(*m.FaceId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MinigameRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HistoryMaxScore != nil {
		n += 1 + sozProtoDef(uint64(*m.HistoryMaxScore))
	}
	if m.TodayMaxScore != nil {
		n += 1 + sozProtoDef(uint64(*m.TodayMaxScore))
	}
	if m.HistoryTopRank != nil {
		n += 1 + sozProtoDef(uint64(*m.HistoryTopRank))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MinigamePlayInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PlayRecord) > 0 {
		for _, e := range m.PlayRecord {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if m.DayBuyCount != nil {
		n += 1 + sozProtoDef(uint64(*m.DayBuyCount))
	}
	if m.GetFlag != nil {
		n += 1 + sozProtoDef(uint64(*m.GetFlag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayerShowInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sozProtoDef(uint64(*m.Level))
	}
	if m.VipLvl != nil {
		n += 1 + sozProtoDef(uint64(*m.VipLvl))
	}
	if m.Gender != nil {
		n += 1 + sozProtoDef(uint64(*m.Gender))
	}
	if m.NickName != nil {
		l = len(m.NickName)
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.HelmetId != nil {
		n += 1 + sozProtoDef(uint64(*m.HelmetId))
	}
	if m.ClothesId != nil {
		n += 1 + sozProtoDef(uint64(*m.ClothesId))
	}
	if m.ShoesId != nil {
		n += 1 + sozProtoDef(uint64(*m.ShoesId))
	}
	if m.WingId != nil {
		n += 1 + sozProtoDef(uint64(*m.WingId))
	}
	if m.WeaponId != nil {
		n += 1 + sozProtoDef(uint64(*m.WeaponId))
	}
	if m.VehicleId != nil {
		n += 1 + sozProtoDef(uint64(*m.VehicleId))
	}
	if m.SuitId != nil {
		n += 1 + sozProtoDef(uint64(*m.SuitId))
	}
	if m.Face != nil {
		l = m.Face.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.PlayerId != nil {
		l = len(m.PlayerId)
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayerValueInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hp != nil {
		n += 1 + sozProtoDef(uint64(*m.Hp))
	}
	if m.Atk != nil {
		n += 1 + sozProtoDef(uint64(*m.Atk))
	}
	if m.Def != nil {
		n += 1 + sozProtoDef(uint64(*m.Def))
	}
	if m.Crit != nil {
		n += 1 + sozProtoDef(uint64(*m.Crit))
	}
	if m.Block != nil {
		n += 1 + sozProtoDef(uint64(*m.Block))
	}
	if m.Speed != nil {
		n += 1 + sozProtoDef(uint64(*m.Speed))
	}
	if m.Fight != nil {
		n += 1 + sozProtoDef(uint64(*m.Fight))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VisitingCardInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowInfo != nil {
		l = m.ShowInfo.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.PlayerInfo != nil {
		l = m.PlayerInfo.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.RoleIndex != nil {
		n += 1 + sozProtoDef(uint64(*m.RoleIndex))
	}
	if m.ExtraPercent != nil {
		l = m.ExtraPercent.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArenaPlayerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rank != nil {
		n += 1 + sozProtoDef(uint64(*m.Rank))
	}
	if m.PlayerInfo != nil {
		l = m.PlayerInfo.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BattleSkillInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozProtoDef(uint64(*m.Id))
	}
	if m.Level != nil {
		n += 1 + sozProtoDef(uint64(*m.Level))
	}
	if m.Skilled != nil {
		n += 1 + sozProtoDef(uint64(*m.Skilled))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BattlePlayerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VisitingCard != nil {
		l = m.VisitingCard.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if len(m.SkillList) > 0 {
		for _, e := range m.SkillList {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if m.SuitSkill != nil {
		l = m.SuitSkill.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if len(m.CardList) > 0 {
		for _, e := range m.CardList {
			n += 1 + sozProtoDef(uint64(e))
		}
	}
	if m.Position != nil {
		n += 1 + sozProtoDef(uint64(*m.Position))
	}
	if m.ActValue != nil {
		n += 1 + sozProtoDef(uint64(*m.ActValue))
	}
	if m.FightPet != nil {
		l = m.FightPet.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArenaBattleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.Rank != nil {
		n += 1 + sozProtoDef(uint64(*m.Rank))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoleIndex != nil {
		n += 1 + sozProtoDef(uint64(*m.RoleIndex))
	}
	if m.PlayerInfo != nil {
		l = m.PlayerInfo.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.Rank != nil {
		n += 1 + sozProtoDef(uint64(*m.Rank))
	}
	if m.Score != nil {
		n += 1 + sozProtoDef(uint64(*m.Score))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SkillUseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SkillId != nil {
		n += 1 + sozProtoDef(uint64(*m.SkillId))
	}
	if m.SkillCount != nil {
		n += 1 + sozProtoDef(uint64(*m.SkillCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DbDailyTaskInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sozProtoDef(uint64(*m.Type))
	}
	if m.Id != nil {
		n += 1 + sozProtoDef(uint64(*m.Id))
	}
	if m.Count != nil {
		n += 1 + sozProtoDef(uint64(*m.Count))
	}
	if m.TotCount != nil {
		n += 1 + sozProtoDef(uint64(*m.TotCount))
	}
	if m.GetFlag != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DbDailyActivityPerLevelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != nil {
		n += 1 + sovProtoDef(uint64(*m.Level))
	}
	if m.GetFlag != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DbDailyActivityInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalAvtivityValue != nil {
		n += 1 + sozProtoDef(uint64(*m.TotalAvtivityValue))
	}
	if len(m.LevelInfo) > 0 {
		for _, e := range m.LevelInfo {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaRect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != nil {
		n += 1 + sozProtoDef(uint64(*m.X))
	}
	if m.Y != nil {
		n += 1 + sozProtoDef(uint64(*m.Y))
	}
	if m.W != nil {
		n += 1 + sozProtoDef(uint64(*m.W))
	}
	if m.H != nil {
		n += 1 + sozProtoDef(uint64(*m.H))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LuaPosRect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartX != nil {
		n += 1 + sozProtoDef(uint64(*m.StartX))
	}
	if m.StartY != nil {
		n += 1 + sozProtoDef(uint64(*m.StartY))
	}
	if m.EndX != nil {
		n += 1 + sozProtoDef(uint64(*m.EndX))
	}
	if m.EndY != nil {
		n += 1 + sozProtoDef(uint64(*m.EndY))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ItemConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemId != nil {
		n += 1 + sozProtoDef(uint64(*m.ItemId))
	}
	if m.ItemCount != nil {
		n += 1 + sozProtoDef(uint64(*m.ItemCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FaceConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemId != nil {
		n += 1 + sozProtoDef(uint64(*m.ItemId))
	}
	if m.ItemTime != nil {
		n += 1 + sozProtoDef(uint64(*m.ItemTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SuitConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemId != nil {
		n += 1 + sozProtoDef(uint64(*m.ItemId))
	}
	if m.ItemTime != nil {
		n += 1 + sozProtoDef(uint64(*m.ItemTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MinosMailTitle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MailIndex != nil {
		n += 1 + sozProtoDef(uint64(*m.MailIndex))
	}
	if m.MailTitle != nil {
		l = len(m.MailTitle)
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.MailTime != nil {
		n += 1 + sozProtoDef(uint64(*m.MailTime))
	}
	if m.MailType != nil {
		n += 1 + sozProtoDef(uint64(*m.MailType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MinosMail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcRoleIndex != nil {
		n += 1 + sozProtoDef(uint64(*m.SrcRoleIndex))
	}
	if m.TarRoleIndex != nil {
		n += 1 + sozProtoDef(uint64(*m.TarRoleIndex))
	}
	if m.MailTitle != nil {
		l = m.MailTitle.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.MailText != nil {
		l = len(m.MailText)
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if len(m.MailListItems) > 0 {
		for _, e := range m.MailListItems {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if len(m.MailListFaces) > 0 {
		for _, e := range m.MailListFaces {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if len(m.MailListSuits) > 0 {
		for _, e := range m.MailListSuits {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InteractNpc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NpcId != nil {
		n += 1 + sozProtoDef(uint64(*m.NpcId))
	}
	if m.Count != nil {
		n += 1 + sozProtoDef(uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InteractCount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozProtoDef(uint64(*m.Id))
	}
	if m.Count != nil {
		n += 1 + sozProtoDef(uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InteractUnlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Condition) > 0 {
		for _, e := range m.Condition {
			n += 1 + sozProtoDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LevelNeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurLevel != nil {
		n += 1 + sozProtoDef(uint64(*m.CurLevel))
	}
	if m.NeedLevel != nil {
		n += 1 + sozProtoDef(uint64(*m.NeedLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ItemNeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozProtoDef(uint64(*m.Id))
	}
	if m.CurCount != nil {
		n += 1 + sozProtoDef(uint64(*m.CurCount))
	}
	if m.NeedCount != nil {
		n += 1 + sozProtoDef(uint64(*m.NeedCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpId != nil {
		n += 1 + sozProtoDef(uint64(*m.SpId))
	}
	if m.Stamp != nil {
		n += 1 + sozProtoDef(uint64(*m.Stamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoleCustomFace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FaceId != nil {
		n += 1 + sozProtoDef(uint64(*m.FaceId))
	}
	if m.Valid != nil {
		n += 1 + sozProtoDef(uint64(*m.Valid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PetBaseFight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hp != nil {
		n += 1 + sozProtoDef(uint64(*m.Hp))
	}
	if m.Atk != nil {
		n += 1 + sozProtoDef(uint64(*m.Atk))
	}
	if m.Def != nil {
		n += 1 + sozProtoDef(uint64(*m.Def))
	}
	if m.Crit != nil {
		n += 1 + sozProtoDef(uint64(*m.Crit))
	}
	if m.Block != nil {
		n += 1 + sozProtoDef(uint64(*m.Block))
	}
	if m.Speed != nil {
		n += 1 + sozProtoDef(uint64(*m.Speed))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PetTalent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TalentId != nil {
		n += 1 + sozProtoDef(uint64(*m.TalentId))
	}
	if m.Level != nil {
		n += 1 + sozProtoDef(uint64(*m.Level))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PetInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PetId != nil {
		n += 1 + sozProtoDef(uint64(*m.PetId))
	}
	if m.Level != nil {
		n += 1 + sozProtoDef(uint64(*m.Level))
	}
	if m.Exp != nil {
		n += 1 + sozProtoDef(uint64(*m.Exp))
	}
	if m.BaseAttr != nil {
		l = m.BaseAttr.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if len(m.ActiveList) > 0 {
		for _, e := range m.ActiveList {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if len(m.PassiveList) > 0 {
		for _, e := range m.PassiveList {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PetRefresh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		n += 1 + sozProtoDef(uint64(*m.Status))
	}
	if m.NextRefreshTimestamp != nil {
		n += 1 + sozProtoDef(uint64(*m.NextRefreshTimestamp))
	}
	if m.PetId != nil {
		n += 1 + sozProtoDef(uint64(*m.PetId))
	}
	if m.SceneId != nil {
		n += 1 + sozProtoDef(uint64(*m.SceneId))
	}
	if m.PosInfo != nil {
		l = m.PosInfo.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HorseEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovProtoDef(uint64(*m.Type))
	}
	if len(m.ParaList) > 0 {
		for _, e := range m.ParaList {
			n += 1 + sozProtoDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ItemListConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Item) > 0 {
		for _, e := range m.Item {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HorseLightInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HorseId != nil {
		n += 1 + sozProtoDef(uint64(*m.HorseId))
	}
	if m.NickName != nil {
		l = len(m.NickName)
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if len(m.ParaList) > 0 {
		for _, e := range m.ParaList {
			n += 1 + sozProtoDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SuccessDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SuccessCount != nil {
		n += 1 + sozProtoDef(uint64(*m.SuccessCount))
	}
	if m.SuccessNum != nil {
		n += 1 + sozProtoDef(uint64(*m.SuccessNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuadraticResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Show != nil {
		l = m.Show.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.LiveTime != nil {
		n += 1 + sozProtoDef(uint64(*m.LiveTime))
	}
	if m.KillNum != nil {
		n += 1 + sozProtoDef(uint64(*m.KillNum))
	}
	if m.ItemList != nil {
		l = m.ItemList.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.RoleIndex != nil {
		n += 1 + sozProtoDef(uint64(*m.RoleIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuadraticRoleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoleIndex != nil {
		n += 1 + sozProtoDef(uint64(*m.RoleIndex))
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.CurrentHp != nil {
		n += 1 + sozProtoDef(uint64(*m.CurrentHp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuadraticRoleHp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoleIndex != nil {
		n += 1 + sozProtoDef(uint64(*m.RoleIndex))
	}
	if m.Hp != nil {
		n += 1 + sozProtoDef(uint64(*m.Hp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuadraticRoleCd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoleIndex != nil {
		n += 1 + sozProtoDef(uint64(*m.RoleIndex))
	}
	if m.Cd != nil {
		n += 1 + sozProtoDef(uint64(*m.Cd))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SellInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != nil {
		n += 1 + sozProtoDef(uint64(*m.Index))
	}
	if m.Num != nil {
		n += 1 + sozProtoDef(uint64(*m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RedeemCodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != nil {
		l = len(m.Code)
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.BatchNo != nil {
		l = len(m.BatchNo)
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.AccountType != nil {
		n += 1 + sovProtoDef(uint64(*m.AccountType))
	}
	if m.ServerRule != nil {
		n += 1 + sovProtoDef(uint64(*m.ServerRule))
	}
	if m.ServerId != nil {
		n += 1 + sovProtoDef(uint64(*m.ServerId))
	}
	if m.GiftId != nil {
		n += 1 + sovProtoDef(uint64(*m.GiftId))
	}
	if m.StartTime != nil {
		n += 1 + sovProtoDef(uint64(*m.StartTime))
	}
	if m.EndTime != nil {
		n += 1 + sovProtoDef(uint64(*m.EndTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RedeemGiftInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GiftId != nil {
		n += 1 + sozProtoDef(uint64(*m.GiftId))
	}
	if m.ItemList != nil {
		l = m.ItemList.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivitySummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozProtoDef(uint64(*m.Id))
	}
	if m.PlatformId != nil {
		n += 1 + sozProtoDef(uint64(*m.PlatformId))
	}
	if m.Title != nil {
		l = len(m.Title)
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.Content != nil {
		l = len(m.Content)
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovProtoDef(uint64(*m.Type))
	}
	if m.SubType != nil {
		n += 1 + sovProtoDef(uint64(*m.SubType))
	}
	if m.StartTime != nil {
		n += 1 + sozProtoDef(uint64(*m.StartTime))
	}
	if m.EndTime != nil {
		n += 1 + sozProtoDef(uint64(*m.EndTime))
	}
	if m.StopTime != nil {
		n += 1 + sozProtoDef(uint64(*m.StopTime))
	}
	if m.ResetType != nil {
		n += 1 + sozProtoDef(uint64(*m.ResetType))
	}
	if m.ResetHour != nil {
		n += 1 + sozProtoDef(uint64(*m.ResetHour))
	}
	if m.Rules != nil {
		l = len(m.Rules)
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.ResetTime != nil {
		n += 1 + sozProtoDef(uint64(*m.ResetTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivityRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuleDes != nil {
		l = len(m.RuleDes)
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.SubType != nil {
		n += 1 + sozProtoDef(uint64(*m.SubType))
	}
	if len(m.ParaList) > 0 {
		for _, e := range m.ParaList {
			n += 1 + sozProtoDef(uint64(e))
		}
	}
	if m.CanGetCount != nil {
		n += 1 + sozProtoDef(uint64(*m.CanGetCount))
	}
	if m.GotCount != nil {
		n += 1 + sozProtoDef(uint64(*m.GotCount))
	}
	if m.GetLimitCount != nil {
		n += 1 + sozProtoDef(uint64(*m.GetLimitCount))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivityInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		n += 1 + sozProtoDef(uint64(*m.Version))
	}
	if m.SummaryInfo != nil {
		l = m.SummaryInfo.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if len(m.RuleList) > 0 {
		for _, e := range m.RuleList {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivityProgressInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovProtoDef(uint64(*m.Type))
	}
	if m.SubType != nil {
		n += 1 + sovProtoDef(uint64(*m.SubType))
	}
	if len(m.Param) > 0 {
		for _, e := range m.Param {
			n += 1 + sozProtoDef(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivityBaseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozProtoDef(uint64(*m.Id))
	}
	if m.Ver != nil {
		n += 1 + sozProtoDef(uint64(*m.Ver))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CombinationSkillInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CdTime != nil {
		n += 1 + sozProtoDef(uint64(*m.CdTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FightRiskInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChapterId != nil {
		n += 1 + sozProtoDef(uint64(*m.ChapterId))
	}
	if m.DupId != nil {
		n += 1 + sozProtoDef(uint64(*m.DupId))
	}
	if m.SubmitStatus != nil {
		n += 1 + sozProtoDef(uint64(*m.SubmitStatus))
	}
	if m.DangerMode != nil {
		n += 1 + sozProtoDef(uint64(*m.DangerMode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PackageCount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PackageId != nil {
		n += 1 + sozProtoDef(uint64(*m.PackageId))
	}
	if m.Count != nil {
		n += 1 + sozProtoDef(uint64(*m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoleOpenPackage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Count) > 0 {
		for _, e := range m.Count {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShopRecharge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sozProtoDef(uint64(*m.Id))
	}
	if m.StartTime != nil {
		n += 1 + sozProtoDef(uint64(*m.StartTime))
	}
	if m.EndTime != nil {
		n += 1 + sozProtoDef(uint64(*m.EndTime))
	}
	if len(m.RewardList) > 0 {
		for _, e := range m.RewardList {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if len(m.CostList) > 0 {
		for _, e := range m.CostList {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoleRechargeGet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetFlag != nil {
		n += 1 + sozProtoDef(uint64(*m.GetFlag))
	}
	if m.Ver != nil {
		n += 1 + sozProtoDef(uint64(*m.Ver))
	}
	if m.Reward != nil {
		l = m.Reward.Size()
		n += 1 + l + sovProtoDef(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommonShopGoodsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemId != nil {
		n += 1 + sozProtoDef(uint64(*m.ItemId))
	}
	if m.Count != nil {
		n += 1 + sozProtoDef(uint64(*m.Count))
	}
	if m.Currency != nil {
		n += 1 + sozProtoDef(uint64(*m.Currency))
	}
	if m.Price != nil {
		n += 1 + sozProtoDef(uint64(*m.Price))
	}
	if m.IsBuy != nil {
		n += 2
	}
	if m.ShopIndex != nil {
		n += 1 + sozProtoDef(uint64(*m.ShopIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommonShopInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GoodsInfo) > 0 {
		for _, e := range m.GoodsInfo {
			l = e.Size()
			n += 1 + l + sovProtoDef(uint64(l))
		}
	}
	if m.ShopNextRefreshTimestamp != nil {
		n += 1 + sozProtoDef(uint64(*m.ShopNextRefreshTimestamp))
	}
	if m.ServerRefreshCount != nil {
		n += 1 + sozProtoDef(uint64(*m.ServerRefreshCount))
	}
	if m.ManualRefreshCount != nil {
		n += 1 + sozProtoDef(uint64(*m.ManualRefreshCount))
	}
	if m.ManualTotalRefreshCount != nil {
		n += 1 + sozProtoDef(uint64(*m.ManualTotalRefreshCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovProtoDef(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProtoDef(x uint64) (n int) {
	return sovProtoDef(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UniversalData) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: universal_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: universal_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Key = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = append(m.Type[:0], dAtA[iNdEx:postIndex]...)
			if m.Type == nil {
				m.Type = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.B = append(m.B, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtoDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtoDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.B) == 0 {
					m.B = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtoDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.B = append(m.B, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.F = append(m.F, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtoDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtoDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.F) == 0 {
					m.F = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.F = append(m.F, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
		case 6:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.D = append(m.D, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtoDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtoDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.D) == 0 {
					m.D = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.D = append(m.D, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field D", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.E = append(m.E, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtoDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtoDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.E) == 0 {
					m.E = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtoDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.E = append(m.E, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field E", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.I32 = append(m.I32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtoDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtoDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.I32) == 0 {
					m.I32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtoDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.I32 = append(m.I32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field I32", wireType)
			}
		case 9:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.I64 = append(m.I64, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtoDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtoDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.I64) == 0 {
					m.I64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtoDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.I64 = append(m.I64, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field I64", wireType)
			}
		case 10:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.U32 = append(m.U32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtoDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtoDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.U32) == 0 {
					m.U32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtoDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.U32 = append(m.U32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field U32", wireType)
			}
		case 11:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.U64 = append(m.U64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtoDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtoDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.U64) == 0 {
					m.U64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtoDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.U64 = append(m.U64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field U64", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str = append(m.Str, make([]byte, postIndex-iNdEx))
			copy(m.Str[len(m.Str)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sub", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sub = append(m.Sub, &UniversalData{})
			if err := m.Sub[len(m.Sub)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaPos) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_pos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_pos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosX", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.PosX = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosY", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.PosY = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DbBagItem) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: db_bag_item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: db_bag_item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.ItemIndex = &v2
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.ItemCount = &v2
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTouched", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsTouched = &b
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDbBagItems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: list_db_bag_items: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: list_db_bag_items: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagItem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BagItem = append(m.BagItem, &DbBagItem{})
			if err := m.BagItem[len(m.BagItem)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DbBagEquip) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: db_bag_equip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: db_bag_equip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.EquipIndex = &v2
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EquipId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attack", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Attack = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endurance", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Endurance = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Quality = &v
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteType", wireType)
			}
			var v E_EQUIP_SITE_TYPE
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= E_EQUIP_SITE_TYPE(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SiteType = &v
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTouched", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsTouched = &b
			hasFields[0] |= uint64(0x00000080)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraPer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraPer == nil {
				m.ExtraPer = &EquipExtraPer{}
			}
			if err := m.ExtraPer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DbRoleEquip) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: db_role_equip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: db_role_equip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.EquipIndex = &v2
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EquipId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attack", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Attack = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endurance", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Endurance = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Quality = &v
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteType", wireType)
			}
			var v E_EQUIP_SITE_TYPE
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= E_EQUIP_SITE_TYPE(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SiteType = &v
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraPer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraPer == nil {
				m.ExtraPer = &EquipExtraPer{}
			}
			if err := m.ExtraPer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipExtraPer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: equip_extra_per: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: equip_extra_per: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightPer", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FightPer = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefPer", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DefPer = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CritPer", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CritPer = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockPer", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BlockPer = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedPer", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SpeedPer = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpPer", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.HpPer = &v
			hasFields[0] |= uint64(0x00000020)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DbFixEquip) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: db_fix_equip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: db_fix_equip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullEndurance", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FullEndurance = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.FixTime = &v2
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NeedTime = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagEquip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BagEquip == nil {
				m.BagEquip = &DbBagEquip{}
			}
			if err := m.BagEquip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDbFixEquips) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: list_db_fix_equips: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: list_db_fix_equips: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FixInfo = append(m.FixInfo, &DbFixEquip{})
			if err := m.FixInfo[len(m.FixInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDbBagEquips) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: list_db_bag_equips: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: list_db_bag_equips: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagEquip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BagEquip = append(m.BagEquip, &DbBagEquip{})
			if err := m.BagEquip[len(m.BagEquip)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRewardId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.LastRewardId = &v
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.EquipIdList = append(m.EquipIdList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtoDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtoDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EquipIdList) == 0 {
					m.EquipIdList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtoDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.EquipIdList = append(m.EquipIdList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipIdList", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagCurrSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BagCurrSize = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagExtendCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.BagExtendCount = &v
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDbRoleEquips) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: list_db_role_equips: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: list_db_role_equips: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleEquip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleEquip = append(m.RoleEquip, &DbRoleEquip{})
			if err := m.RoleEquip[len(m.RoleEquip)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: reward_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: reward_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Count = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DbFriendInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: db_friend_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: db_friend_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.RoleIndex = &v2
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Time = &v2
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.LoginTime = &v2
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CardInfo == nil {
				m.CardInfo = &VisitingCardInfo{}
			}
			if err := m.CardInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DbArenaKillInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: db_arena_kill_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: db_arena_kill_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.RoleIndex = &v2
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillDate", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.KillDate = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowInfo == nil {
				m.ShowInfo = &PlayerShowInfo{}
			}
			if err := m.ShowInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleFace) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: role_face: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: role_face: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FaceId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MinigameRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: minigame_record: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: minigame_record: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryMaxScore", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.HistoryMaxScore = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TodayMaxScore", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.TodayMaxScore = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryTopRank", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.HistoryTopRank = &v
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MinigamePlayInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: minigame_play_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: minigame_play_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayRecord = append(m.PlayRecord, &MinigameRecord{})
			if err := m.PlayRecord[len(m.PlayRecord)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayBuyCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DayBuyCount = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetFlag", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GetFlag = &v
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerShowInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: player_show_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: player_show_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipLvl", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.VipLvl = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gender", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Gender = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = append(m.NickName[:0], dAtA[iNdEx:postIndex]...)
			if m.NickName == nil {
				m.NickName = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelmetId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.HelmetId = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClothesId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ClothesId = &v
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShoesId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ShoesId = &v
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WingId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.WingId = &v
			hasFields[0] |= uint64(0x00000080)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeaponId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.WeaponId = &v
			hasFields[0] |= uint64(0x00000100)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VehicleId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.VehicleId = &v
			hasFields[0] |= uint64(0x00000200)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuitId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SuitId = &v
			hasFields[0] |= uint64(0x00000400)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Face", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Face == nil {
				m.Face = &RoleFace{}
			}
			if err := m.Face.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000800)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerId = append(m.PlayerId[:0], dAtA[iNdEx:postIndex]...)
			if m.PlayerId == nil {
				m.PlayerId = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00001000)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000100) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000200) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000400) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000800) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00001000) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerValueInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: player_value_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: player_value_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Hp = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atk", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Atk = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Def = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Crit = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Block = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Speed = &v
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fight", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Fight = &v
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VisitingCardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: visiting_card_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: visiting_card_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShowInfo == nil {
				m.ShowInfo = &PlayerShowInfo{}
			}
			if err := m.ShowInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlayerInfo == nil {
				m.PlayerInfo = &PlayerValueInfo{}
			}
			if err := m.PlayerInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.RoleIndex = &v2
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraPercent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraPercent == nil {
				m.ExtraPercent = &EquipExtraPer{}
			}
			if err := m.ExtraPercent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArenaPlayerInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: arena_player_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: arena_player_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Rank = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlayerInfo == nil {
				m.PlayerInfo = &VisitingCardInfo{}
			}
			if err := m.PlayerInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BattleSkillInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: battle_skill_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: battle_skill_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skilled", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Skilled = &v
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BattlePlayerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: battle_player_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: battle_player_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VisitingCard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VisitingCard == nil {
				m.VisitingCard = &VisitingCardInfo{}
			}
			if err := m.VisitingCard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkillList = append(m.SkillList, &BattleSkillInfo{})
			if err := m.SkillList[len(m.SkillList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuitSkill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SuitSkill == nil {
				m.SuitSkill = &BattleSkillInfo{}
			}
			if err := m.SuitSkill.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.CardList = append(m.CardList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtoDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtoDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CardList) == 0 {
					m.CardList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtoDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.CardList = append(m.CardList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CardList", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Position = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActValue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ActValue = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightPet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FightPet == nil {
				m.FightPet = &PetInfo{}
			}
			if err := m.FightPet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArenaBattleInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: arena_battle_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: arena_battle_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player == nil {
				m.Player = &BattlePlayerInfo{}
			}
			if err := m.Player.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Rank = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.RoleIndex = &v2
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlayerInfo == nil {
				m.PlayerInfo = &PlayerShowInfo{}
			}
			if err := m.PlayerInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Rank = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Score = &v2
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillUseInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillUseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillUseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SkillId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SkillCount = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DbDailyTaskInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: db_daily_task_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: db_daily_task_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Count = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.TotCount = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.GetFlag = &b
			hasFields[0] |= uint64(0x00000010)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DbDailyActivityPerLevelInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: db_daily_activity_per_level_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: db_daily_activity_per_level_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Level = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.GetFlag = &b
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DbDailyActivityInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: db_daily_activity_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: db_daily_activity_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAvtivityValue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.TotalAvtivityValue = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LevelInfo = append(m.LevelInfo, &DbDailyActivityPerLevelInfo{})
			if err := m.LevelInfo[len(m.LevelInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaRect) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_rect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_rect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.X = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Y = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.W = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.H = &v
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LuaPosRect) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lua_pos_rect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lua_pos_rect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartX", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.StartX = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartY", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.StartY = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndX", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EndX = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndY", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.EndY = &v
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemConfig) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: item_config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: item_config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemCount = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FaceConfig) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: face_config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: face_config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemTime = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuitConfig) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: suit_config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: suit_config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemTime = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MinosMailTitle) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: minos_mail_title: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: minos_mail_title: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.MailIndex = &v2
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailTitle", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailTitle = append(m.MailTitle[:0], dAtA[iNdEx:postIndex]...)
			if m.MailTitle == nil {
				m.MailTitle = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.MailTime = &v2
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.MailType = &v
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MinosMail) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: minos_mail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: minos_mail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcRoleIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.SrcRoleIndex = &v2
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TarRoleIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.TarRoleIndex = &v2
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailTitle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MailTitle == nil {
				m.MailTitle = &MinosMailTitle{}
			}
			if err := m.MailTitle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailText", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailText = append(m.MailText[:0], dAtA[iNdEx:postIndex]...)
			if m.MailText == nil {
				m.MailText = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailListItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailListItems = append(m.MailListItems, &ItemConfig{})
			if err := m.MailListItems[len(m.MailListItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailListFaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailListFaces = append(m.MailListFaces, &FaceConfig{})
			if err := m.MailListFaces[len(m.MailListFaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailListSuits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailListSuits = append(m.MailListSuits, &SuitConfig{})
			if err := m.MailListSuits[len(m.MailListSuits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InteractNpc) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: interact_npc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: interact_npc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NpcId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NpcId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Count = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InteractCount) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: interact_count: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: interact_count: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Count = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InteractUnlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: interact_unlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: interact_unlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Condition = append(m.Condition, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtoDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtoDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Condition) == 0 {
					m.Condition = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtoDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Condition = append(m.Condition, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LevelNeed) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: level_need: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: level_need: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CurLevel = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.NeedLevel = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemNeed) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: item_need: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: item_need: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.CurCount = &v2
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.NeedCount = &v2
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sp_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sp_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SpId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stamp", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Stamp = &v2
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleCustomFace) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: role_custom_face: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: role_custom_face: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.FaceId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valid", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Valid = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PetBaseFight) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: pet_base_fight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: pet_base_fight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Hp = &v2
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atk", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Atk = &v2
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Def = &v2
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crit", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Crit = &v2
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Block = &v2
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Speed = &v2
			hasFields[0] |= uint64(0x00000020)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PetTalent) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: pet_talent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: pet_talent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TalentId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.TalentId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PetInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: pet_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: pet_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PetId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.PetId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Level = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Exp = &v2
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseAttr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseAttr == nil {
				m.BaseAttr = &PetBaseFight{}
			}
			if err := m.BaseAttr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveList = append(m.ActiveList, &PetTalent{})
			if err := m.ActiveList[len(m.ActiveList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassiveList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PassiveList = append(m.PassiveList, &PetTalent{})
			if err := m.PassiveList[len(m.PassiveList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PetRefresh) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: pet_refresh: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: pet_refresh: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Status = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextRefreshTimestamp", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.NextRefreshTimestamp = &v2
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PetId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.PetId = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SceneId = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PosInfo == nil {
				m.PosInfo = &LuaPos{}
			}
			if err := m.PosInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HorseEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: horse_event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: horse_event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v E_HORSE_LIGHT_TYPE
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= E_HORSE_LIGHT_TYPE(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.ParaList = append(m.ParaList, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtoDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtoDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ParaList) == 0 {
					m.ParaList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtoDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.ParaList = append(m.ParaList, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ParaList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemListConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: item_list_config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: item_list_config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Item = append(m.Item, &ItemConfig{})
			if err := m.Item[len(m.Item)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HorseLightInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: horse_light_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: horse_light_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HorseId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.HorseId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = append(m.NickName[:0], dAtA[iNdEx:postIndex]...)
			if m.NickName == nil {
				m.NickName = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.ParaList = append(m.ParaList, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtoDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtoDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ParaList) == 0 {
					m.ParaList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtoDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.ParaList = append(m.ParaList, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ParaList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuccessDetail) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: success_detail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: success_detail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.SuccessCount = &v2
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessNum", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.SuccessNum = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuadraticResult) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: guadratic_result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: guadratic_result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Show", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Show == nil {
				m.Show = &PlayerShowInfo{}
			}
			if err := m.Show.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveTime", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.LiveTime = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.KillNum = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemList == nil {
				m.ItemList = &ItemListConfig{}
			}
			if err := m.ItemList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.RoleIndex = &v2
			hasFields[0] |= uint64(0x00000010)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuadraticRoleInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: guadratic_role_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: guadratic_role_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.RoleIndex = &v2
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &LuaPos{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentHp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CurrentHp = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuadraticRoleHp) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: guadratic_role_hp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: guadratic_role_hp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.RoleIndex = &v2
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Hp = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuadraticRoleCd) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: guadratic_role_cd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: guadratic_role_cd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleIndex", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.RoleIndex = &v2
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cd", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Cd = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SellInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sell_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sell_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Index = &v2
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Num = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedeemCodeInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: redeem_code_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: redeem_code_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = append(m.Code[:0], dAtA[iNdEx:postIndex]...)
			if m.Code == nil {
				m.Code = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchNo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchNo = append(m.BatchNo[:0], dAtA[iNdEx:postIndex]...)
			if m.BatchNo == nil {
				m.BatchNo = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AccountType = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerRule", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ServerRule = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ServerId = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GiftId = &v
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StartTime = &v
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EndTime = &v
			hasFields[0] |= uint64(0x00000080)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedeemGiftInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: redeem_gift_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: redeem_gift_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.GiftId = &v2
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemList == nil {
				m.ItemList = &ItemListConfig{}
			}
			if err := m.ItemList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivitySummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: activity_summary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: activity_summary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.PlatformId = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = append(m.Title[:0], dAtA[iNdEx:postIndex]...)
			if m.Title == nil {
				m.Title = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SubType = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.StartTime = &v2
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.EndTime = &v2
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.StopTime = &v2
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ResetType = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetHour", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ResetHour = &v
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules[:0], dAtA[iNdEx:postIndex]...)
			if m.Rules == nil {
				m.Rules = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.ResetTime = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: activity_rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: activity_rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleDes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleDes = append(m.RuleDes[:0], dAtA[iNdEx:postIndex]...)
			if m.RuleDes == nil {
				m.RuleDes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SubType = &v
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.ParaList = append(m.ParaList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtoDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtoDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ParaList) == 0 {
					m.ParaList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtoDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.ParaList = append(m.ParaList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ParaList", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanGetCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.CanGetCount = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GotCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GotCount = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetLimitCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GetLimitCount = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ItemConfig{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: activity_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: activity_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Version = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SummaryInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SummaryInfo == nil {
				m.SummaryInfo = &ActivitySummary{}
			}
			if err := m.SummaryInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleList = append(m.RuleList, &ActivityRule{})
			if err := m.RuleList[len(m.RuleList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityProgressInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: activity_progress_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: activity_progress_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v E_ACTIVITY_TYPE
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= E_ACTIVITY_TYPE(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubType", wireType)
			}
			var v E_ACTIVITY_SUB_TYPE
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= E_ACTIVITY_SUB_TYPE(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SubType = &v
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Param = append(m.Param, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtoDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtoDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Param) == 0 {
					m.Param = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtoDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Param = append(m.Param, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityBaseInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: activity_base_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: activity_base_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Ver = &v
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombinationSkillInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: combination_skill_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: combination_skill_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.CdTime = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightRiskInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: fight_risk_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: fight_risk_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChapterId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ChapterId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DupId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DupId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitStatus", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.SubmitStatus = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DangerMode", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DangerMode = &v
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PackageCount) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: package_count: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: package_count: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.PackageId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Count = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleOpenPackage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: role_open_package: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: role_open_package: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Count = append(m.Count, &PackageCount{})
			if err := m.Count[len(m.Count)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShopRecharge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: shop_recharge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: shop_recharge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Id = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.StartTime = &v2
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.EndTime = &v2
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardList = append(m.RewardList, &ItemConfig{})
			if err := m.RewardList[len(m.RewardList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CostList = append(m.CostList, &ItemConfig{})
			if err := m.CostList[len(m.CostList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleRechargeGet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: role_recharge_get: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: role_recharge_get: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetFlag", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.GetFlag = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Ver = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reward == nil {
				m.Reward = &ShopRecharge{}
			}
			if err := m.Reward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonShopGoodsInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: common_shop_goods_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: common_shop_goods_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ItemId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Count = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Currency = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Price = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsBuy = &b
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopIndex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ShopIndex = &v
			hasFields[0] |= uint64(0x00000020)
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonShopInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: common_shop_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: common_shop_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtoDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtoDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsInfo = append(m.GoodsInfo, &CommonShopGoodsInfo{})
			if err := m.GoodsInfo[len(m.GoodsInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopNextRefreshTimestamp", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.ShopNextRefreshTimestamp = &v2
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerRefreshCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ServerRefreshCount = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualRefreshCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ManualRefreshCount = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualTotalRefreshCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.ManualTotalRefreshCount = &v
		default:
			iNdEx = preIndex
			skippy, err := skipProtoDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtoDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProtoDef(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtoDef
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtoDef
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProtoDef
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthProtoDef
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProtoDef
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProtoDef(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthProtoDef
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProtoDef = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtoDef   = fmt.Errorf("proto: integer overflow")
)
